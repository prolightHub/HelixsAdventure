var sketch = function(processing) /*Wrapper*/
{
    processing.size(400, 400, processing.P2D);
    processing.background(0xFFF);

    var mouseIsPressed = false;
    processing.mousePressed = function() 
    {
        mouseIsPressed = true;
    };
    processing.mouseReleased = function()
    {
        mouseIsPressed = false;
    };

    var keyIsPressed = false;
    processing.keyPressed = function()
    {
        keyIsPressed = true;
    };
    processing.keyReleased = function() 
    {
        keyIsPressed = false;
    };

    function getImage(s)
    {
        var url = "https://www.kasandbox.org/programming-images/" + s + ".png";
        processing.externals.sketch.imageCache.add(url);
        return processing.loadImage(url);
    }

    processing.loadBase64 = function(base64, onload)
    {
        var image = new Image();
        image.src = base64;
        image.crossOrigin = "Anonymous"; 
        image.onload = function() 
        {
            var context = canvas.getContext('2d');
            processing.background(0, 0, 0, 0);
            context.drawImage(image, 0, 0);
            onload(processing.get(0, 0, image.width, image.height));
            processing.background(0, 0, 0, 0);
        };
        return image;
    };

    String.prototype.upper = function() 
    {
        return this.charAt(0).toUpperCase() + this.slice(1);
    };
    String.prototype.startsWithVowel = function()
    {
        return (['a', 'e', 'i', 'o', 'u'].indexOf(this.charAt(0).toLowerCase()) !== -1);
    };

    function getLocalImage(url) 
    {
        processing.externals.sketch.imageCache.add(url);
        return processing.loadImage(url);
    }

    // use degrees rather than radians in rotate functions
    var rotateFn = processing.rotate;
    processing.rotate = function(angle) {
        rotateFn(processing.radians(angle));
    };
    
    processing.scaled = false;

    processing.hint(processing.DISABLE_OPENGL_ERROR_REPORT);

    window.ctx = processing.externals.context;
    // window.gl = processing.externals.gl = processing.externals.canvas.getContext("webgl");

    // if(gl)
    // {
    //     console.log("using webgl for images");
    // }

    var $pjs = processing;

    with(processing)
    {

/**   Hybrid Game Engine (Helix's Adventure (Planet Search 2))  **/
/**
    @Author Prolight
    @Version 1.0.0 beta (100% complete)

        100+ gameObjects!
        100+ levels!

    @How :
        Use the arrow keys to move. Down to go through 
        doors / set Checkpoints / collect keys / items.
        There are crates you can move. 'r' to restart level.
        Have fun, through it's a demo.
    
    @Info : 
        It's Called Hybrid Game Engine because it's a hybrid between 
        The Cartesian System and physics.
    
    @About Cartesian System :
        The cartesian system is a coordinate grid Designed to split up
        the objects into cells. Speeds up your game 3x by using cells for
        collision detection between adjacent cells. It only renders cells 
        with in the screen controlled by the camera. Will work with any 
        platformer with an array for the arrays for all of it's gameObjects. I hope
        you understand.
**/
/**
    Updates : 
        Note: Some logs are missing due to late logging in early development
    * v0.0.5 Full Cartesian System in place
    * v0.1.0 Circle and rectangle Physics reached
    * v0.1.5 Objects added 
    * v0.2.0 doors checkpoints keys
    * v0.2.1 Getting ready for graphics
    * v0.2.2 Cloud, dirt, ground and door graphics
    * v0.2.3 Image and screenUtils delegates / Json fully in place
    * v0.2.4 LoadImage function is pretty much done, added extra cloud graphics and a Sun, 
    plus checkPoints now are flags, 
    * v0.2.5 Added Dynamic rectangle physics and the key graphic, crates (with nicer collision) are 
    now in the game just needs the player sprite and then it will be to the next version
    * v0.2.6 Signs, oneways and moving platforms are added 
    * v0.2.7 Crate and ball physics are completely stablized
    * v0.2.8 Slope Prototype added
    * v0.2.9 Images can now load in khan academy mode
    * v0.3.0 completed slopes though they seem a little glitchy
    * v0.3.1 fps and physics adjusted
    * v0.3.2 Changed graphics to load
    * v0.3.3 - 0.3.4 Added a better player graphic. Made clouds in background move. Removed old background and code
    Title Screen added (too much like original) Pause Menu added. How and extras menu (For extra stuff) added.
    Added an infomation bar.
    * v0.3.5 Made the restart key 'r' so you can't hold it down and have the game keep restarting. Added a tutorial level
    * v0.3.6 Added platforms using oneways, added coins, got rid of suddle glitches with slopes and oneWays.
    * v0.3.7 Added water, ice, Falling blocks and ladders.
    * v0.3.8 +I have added a type to all the gameObjects. 
        +Added a lifeform object
        -Removed a glitch with the water enabling you to swim into the underside of blocks
        +Added an enemy gameObject
        +Made moving platforms realistic in terms of physics
        +Made starting checkpoints invisible     
    * v0.3.9
       + Made moving platforms on the x axis have a 
        custom bounding box, so they are more likely to come back.
        +Allowed enemies to push crates, made crate physics more realistic
        -Fixed bug where a circle on left wall disappears.
        +Added point-circle collision detection and point-slope collision detection
        +Added enemy raycasting  
    * v0.4.0 #The Debug update
      + Added a debug cartesian system on right click 
      + Extra settings with buttons!
        This is getting close to 5000 lines of code woah!
      + Added a loading screen with a percentage. 
        I might turn it off for small loading quantities 
      + The loading Screen now has a bar  
    * v0.4.1 
        +I've added fire beakers and water beakers   
        +Created ordered rendering
        +Beakers switch eyes
    * v0.4.2 
       +Added shooters
       +Shooters now have health 
       +Crates now drop items
       +There are now two types of crates, the ones that break and the ones that don't
       +Shooters now working ka mode
       -Fixed bug with invisible / reappearing objects
        by instead of deleting objects, hiding them by replacing them 
        with a gameObject class 
    * v0.4.3
        Cloud mines are now added
        We now have Sky vipers and Ninjas with Ninja stars
    * v0.4.4
        Spikes and clouds added!
    * v0.4.5 #The sound and saving update!
        sounds.js in place! (Incomplete)
        Saving menu and saver added
        Put the canvas in the middle of the screen.
        Turned background outside of canvas to black
        Added unsupported browser warnings.
    * v0.4.6
        +Added sound effects
        +Added trees
        +Added extra "night mode" effect
        +Starting to add in the story of the game into a cut scene,
            in Between the title screen and the select save file scenes.
        +Added a levels key
        +Made slopes somewhat more accurate
        The storyline is done
    * v0.4.7
        +Added clouds with rain and snow
        -Removed the dummy object and replaced it with a dummy delegate
        -Removed snow piling up off screen
        +Added a lighting - grid effect, still not too sure what to do with it though 
        +Added light Fixtures
        +Finished weather and daylight cycle
        +Added a sprint ability
    * v0.4.8
        +Making the second level
        +Slope physics tweaked
        *Fixed loading / checkpoint bug
        *Fixed saving / check point bugs
        +added an air background
        *Found a bug with oneways and fixed it!
    * v0.4.9
        +crates are now way easier to push!
        +Sorted the files
        +Fixed compatiabliatly but not with the save data.
        +Fixed the text box
        -Loading from undefined level bug removed
        +Crates are now way easier to push
        +Saving is now fixed for all browsers!
    * v0.5.0 #The revision
        +Level editor (but in another program)
        -level file enclosure (but still needs to be turned into a json file which I couldn't do)
        +Made buttons easier to push with npcs
        +Sliders updated
        +TextBoxes updated
        *Circles now support rotation!
        *Changed npc message logic and added images to the npcs of Abby and Jason
        *Doors that go to other levels or rooms are now blue.
        +Levels can now choose if the debug menu is white.
    * v0.5.1
        +Added more levels
        +Put top and bottom collision on slopes
        +Added a village with more houses
        +Made the defeat viper challenge in the 2nd house in the village.
        *You can now see the keys the player has and put them up and down!
        *Fixed touching slopes disables bottom block collision
        *Fixed minor slope collision bug
        
    * v0.5.2 # The more items update
        +Added chests
        +Added a chest in level ???
        +Made the CoreGround level
        +Added The first powerup - The Bubble Shield!
        *Fixed bugs with bubble Shield!
        *Fixed esc infinite restarting level bug
        +Fixed sound error
        +Now the sound settings let you hear
        the coin sound when you click the volume bar 

    * v0.5.3
        Added a dark background
        CoreGround level done!
        SpaceBreaker, rendering is complete!
        Added raycasting for SpaceBreaker
        Changed slope collision once again -> works better

    * 0.5.4 # The bug-fixing update
        Made a mini-Battle level
        Updated bubble-shield to block launch balls from space breakers
        Fixed bubble-shield bugs
        Slightly fixed falling through oneways after thouching slopes bug
        Finished mini-battle level
        Changed: When you are low on hp bubble shields don't refresh your hp
        
        Note: bubbleShields now function easier

        UI: Is now easier to use
            Fixed: The save-exit no entry-bug (Where you can't start)
            Forced the start screen background to be spaceFromEarth (A background we can see)
            Fixed: The fast button press of play causes the restart of game progress
            Fixed: Up/down keys causes box char in the textbox object
            You can now chose save files with-out the mouse  
   
    * 0.5.5 #Quick saves
        Added save file name into player object!
        Made it easier to create a new save file!
        Made it easier to see buttons 
        Made it easy to see game saved!
        Made other things (misc) easier 
        Made the "bridge" in coreground save so that you can actually get back!
        Finally fixed the beaker slope glitch mania (Fixed the beaker forced underground because of slope bug)
        Made things in coreground function easier
        'p' can now exit the pause menu:
            When pressing 'r' your game doesn't actually save, but the flag is set/green
        Fixed (by making it refresh the page): Fix exiting and saving: -If you exit and enter into the same save file it won't work.
      
    * 0.5.6 #The more like a game update
        Made level called "night"
        Fixed things with nighttime lighting
        The player now has lives
        Made a new level called "ninja Temple Entrance"
        Made keys not appear when the player already has it
        With gameover screen
        Added extra comments
        Fixed an uncaught error "this.restart is not a function" changed to game.restart broke save files

    * 0.5.7 #The bug fixing / easier to use update!
        Cleaned the core of the game.
        Fixed that night mode flickering
        Made the select save file screen nicer with bigger left-right buttons,
            start screen back button and a copy button.
        Fixed player's hp problems
        Found the most friendly cell size
        Made the text on the hp bar easier to see,
        Made it possible to open the game using the keyboard!
        Made the story handler more dynamic 
        You can now see the verison in the start, select-save-file, extras, sound and settings screen(s)!
        
    * 0.5.8
        Made the fps counter more accurate
        Fixed a bug with the keyboard pause menu
        Fixed -When you go through a door your hp maxes out/you die
        Moved debug mode so it doesn't get stuck with the image while loading
        Fast load is now available!
        Player is now faster and now has the abilty to jump at different heights  
        The player now has a death animation

    * 0.5.9 #Fastest Version so far!
        The lighting grid is now way less laggy!
        You can now save your sound level!
        Moved Npc data outside of the levels' code
        Fixed Save file disappearence bug
        Cleaned up levels folder
        Removed: Npc talks about boring storyline stuff
        It can now replace /username with the actual player's name in dialog!
        Fixed: Player gets on wrong first checkpoint bug
        Fixed: Bubble shield renders over sign
        Added a crop lighting fixture mode.

    * 0.6.0 #Smoothest
        Scorebar now renders when fading.
        Other things like not rendering title, story, menu screen while unfading is fixed!
        Loading bar smooths out now!
        Fixed: While pressing 'r' the player does not render
        Fixed: The death animation flickers the screen
        Fixed: Death animation pieces dissapear in midair now it sometimes does that.
        Fixed: Clouds from being trippy
        Textboxes now can be closed by restarting the level or pressing the 'x' button and now text auto reads / scrolls

    [Smaller Updates]

    * 0.6.1 #Outsiders update
        Added a rename save button and did some other stuff to the select save file scene
        Fixed: Background save-changing instant fade change
        Fixed: Most of the text box issues
        Finished up the rest of text box stuff 
 
    * 0.6.2 #The more buttony update
        Switched play and copy buttons to make more sense in select save file scene
        Fixed minor lighting issues 
        Starting working on inside of ninja temple
        Themes are added 
        First room of ninja temple complete
        Added 3 more rooms the Ninja temple
        touched up on crate physics
        We can now play multiple sounds at once!

    * 0.6.3 
        Changed sound a bit
        Finished code that applies a config but can be overriden by the level
        Created a take damage function/method
        Beakers are now less powerful in damage
        Springs bounce less 
        Added a theme settings file
        Fixed more lighting grid issues
        All enemies are now less powerful

    * 0.6.4
        We can now chose which objects get saved as deleted in our levels!
        Added to space-savers to the code
        Got rid of some unnecessary code (Maybe uncommented code)
        Cleaned up TODO and Future Updates

    * 0.6.5
        Speeded up loading 10x
        Fixed levelshading when loading
        ladders are now white in the ninja temple 
        Added a defense up power-up!
        FireBeakers/temple beakers now have particles effects 

    * 0.6.6
        Fixed: objectSaver!
        We can now add arrayNames to save 
        & remove arrayNames to save
        & override existing theme arrayNames to save
        Added a defense percentage bar
        Enhanced the info bars
        Made that level to replace the "bomb" level
        Added a chest room for ninjas
        We now have cut-scenes!

    * 0.6.7
        Checked ladders being white!
        Added a get damage function option to life form object
        Doubled ninja amt in the backyard level
        Made a secret path to the backyard of the ninja temple
        Did a lot of work on the ninja temple!

        Fixed item regen in chests that have regen wouldn't regen there items
        made a backgroundDarkGrid (Backblock) choice so that it won't lag as much in the minibattle level
        ladders are now white
        You can now chose '9' to autorun or you can chose '0' to turn it off

    * 0.6.8
        Fixed minor issues with save file screen and defense chest and other stuff
        (Remember when adding objects that make ablities that save even after you die to add the arraysToSave)
    
        Fixed config arrays to save system by replacing "objectSaver" with "configAreaSaver"!
        Completely removed objectSaver system    
        Fixed a minor erase save file bug -duplication instead of deletion
        Got rid of a little bit of unnecessary code

    * 0.6.9 # Abilities and rpg. 
        Sky vipers now have knockback! (So you don't die instantly when they touch you)
        Multiplied players attack by 10 and multiplied all objects with hp by 10 (except for the player of course)

        Player now blinks after attack by a life form.
        Fixed cannot read property toString of undefined (When esc is pressed)

        Changed lifeforms' attack and hp
        Improved spacebreakers

        Did more work on the Ninja temple. (Made more rooms like the [ninja tank, hallway, boss, end])
        Made doors be able to stay open when you go through them
    
        Got rid of a ton of now unnecessary keys in the Ninja Temple
        Added a error handler
        Made the door lock until ninjas are defeated in level ninjaTempleBackyard by adding a key to appear

        Fixed the text rendering in a key
        Improved text dialog box
        Made text appear saying "It is locked." or something when you try opening a locked door

        Made player's fallspeed faster.
        Changed what npcs say.
        Made the dialog skipable.
        Fixed the erase save file copy bug.
        _______________________________________________________________________________________________________________________________________________________________________
        For later or done or undecided : Todo :
            1. Fix forever defense / bailup getting in ninjaTempleRoom#3 (again) (Improvement items have been disabled while I fix this)
            2. Improve all objects to do less damage and change their style to work with attack and make the game easier. (Make it harder but so you can last and play longer)
        _______________________________________________________________________________________________________________________________________________________________________

    * 0.7.0
        Fixed rectangle physics for real this time!
        Fixed the main loop(s) or the core.
        Fixed suddle oneway and AI glitches due to the new the systems works.
        Replaced width / 2 with halfWidth and also with height.
        Fixed that stupid measure text width bug.
        Crates now render over doors.
        Fixed that stupid beaker getting locked on blocks glitch.
        Fixed spike bouncing that wouldn't work.
        Fixed that strange bouncing thing with vertical moving platforms.
        Fixed spring padding!
        Made this room:
            ninjaTempleRoom#3 (beaker trial)
            Less of a pain!
        Added overworld theme to all levels before the ninja temple. [Coins will now be saved in those levels]
        Fixed slope physics!

    * 0.7.1
        Added spikes and a switch to the ninja temple boss room!
        Updated spike to fall down and go up and they now have a 
        green bar that show that they're connected to the ceiling.
        Added graphics to the lever. (Or switch)
        Made the lever (Or switch) have a handle.
        Made the boss, but without AI.
        Added trigger events to the level and lever.
        The boss now presses the lever to make the spikes come down on you.
        When a spike is defeated by jumping on it, it sheds small hp coins.
        Made the image for the boss
        Made the boss AI and stats for it.
        Updated the spikes!
        Made: Make an item (A hp heart that gives you 10/5 more max hp) for you to collect after defeating the boss
        Fixed hp Heart coming down when player has already collected it in the ninja temple boss room.
        Adjusted Levels
            
    * 0.7.2
        Fixed block being the same color when loaded glitch.
        Made the screen bigger.
        Made a crash screen.
        Fixed Spikes!
        Fixed ninja AI
        Added a cool way to end the world

        Added Levels :
            ninjaTempleWalkWay
            behindTheNinjaTemple

        Added a tower @behindTheNinjaTemple

        Made it so you can still play in 30 fps mode without slow downs in other browsers
        Hid the powerups you collect that are unused.

    * 0.7.3
        You now don't need to press down to activate a checkpoint
        You can still damage enemies while blinking
        Changed the cursor to cross when press mouse Right button instead of a sqaure.
        Made it so when jumping on an edge of a block next to water it does not stop you from jumping on it.

        Changed ninja temple room #1 (the room with all the doors) into ninja temple hub
        Fixed the door loading bug.
        Fixed strange save loading bugs with try catches
        Changed: that pesky level ninjaTempleRoom#3 to make it dynamic and easier.
        Added a lever into coreground (where it says touch lava for...)
        Added Hardcase block
        Added fog maachines!
        Finally added a power up handler.
        Finally added the Ninja Guard Power-up!

        Removed old defense power-ups from the code...

    * 0.7.4
        Simplified but fixed text boxes.
        Fixed minor level issues.
        Replaced getObject from the core engine of the code. (It is slow and also change raycasting)
        Doubled levelStepRows 10 -> 20 To speed up level loading.
        Removed defense up from the levels.
        Speed run game
        Fixed dialog text boxes.
        Added a winter background.
        Updated snow clouds with snow layers.
        Added super ice that is super slippy.
        Added messages that show which area you're in!
        Added a place after the Ninja Temple.

    * 0.7.5
        Changed running controls.
        Fixed the level fading.
        Removed upside spikes where they didn't belong in a level.
        Fixed an important ai bug with the Ninja Temple Boss where 
        he becomes defeatable while running. 
        Made slippy slopes only for the winter place.
        Made water blocks freeze over when next to ice.
        Fixed minor snow layer ai glitch where they would just stop.
        Fixed snow painting blocks -Snowballs and snowlayers will now 
        only paint the top of the block when they're there.
        Made it possible to set the alpha of the image you're saving.
        Snow balls are here but the circle-rect collision is unstable.
        Created an air bar.
        Fixed text width on air bar and intro title bar.
        Removed minor game.starting at wrong time bug.

    * 0.7.6
        Added game auto-delaging feature.
        Made a good cloud sleep timer.
        Created an ice beaker.
        Added two different types of snow blocks.
        Created snow blocks you can now move with your Ninjastar, but they teleport instead of move.
        Made a way to make 3x3 or largers blocks of water in winter levels because I overrided that property.
        Snow layers will now not spawn on snowblocks
        Made snowblocks transmit force, so that they work like a Newton's Cradle!
        Snow blocks are now more realistic and won't sink in water.
        Changed what it says on the power-up after the boss.
        Changed the dialog in all of houses in the village in the beginning of the game.
        (Got rid of that guy in the 2nd house)
        We now have nets yay!
        We now have a new cooler looking ice graphic!
        Added a lot of stuff to the level interX.

    * 0.7.7
        Made a bottom hud to go with the top one.
        Fixed the strange regeneration of hp when not needed on checkpoints.
        Fixed a message glitch (caused the game to crash) when going to the first level in the game.
        Fixed a few things with transistions.
        We now have an inventory!
        Made a way to re-save.
        Saving now covers adding new config areas into the game!
        The current power-up won't change when you die!
        Changed a door to not be locked so you can get the Ninja Guard power-up without having to find the secret entrance.
        We now have a new enemy but it's animation is incomplete.
        Fixed a few things that wouldn't let you beat the game
        Added another huge level, icy plains
        Fixed something with browser detection.
        Refined Wisps' Ice, aka the player can now get frozen.
        You can now deflect Wisps' ice
        Fixed the velocity animation on the player.
        
    * 0.7.8 
        Added 2 more levels!
        Super charged the game with fps by not calling frameRate all the time
        Fixed background resolution
        Added a dirty block!
        Added dirty Cat!
        Added catdog statue -moves when you can't see them
        Made doorsound.mp3 sound effect work with doors
        Added delag modes to the space breaker!
        Cat dog statues are done, they now have lasers!
        Changed the controls a bit, added more levels!
        Added the ice splicer power-up

    * 0.7.9
        Fixed new bugs that have popped up with things.
        Added more to the inventory menu.
        Like the item slots.
        Finished item slots and stuff.
        Fixed a bug with level saving.
        Added more levels.
        Started to make the ice dragon boss. Still need to figure out how to make the movement.
        Added a underground background!
        Added a level secret to "entry" level. You have to put the "energy" in the chest then it will destroy some ice.
        Fixed the freeze hit bug.
        Fixed bugs with the inventory items, where it was very unclear what was going on.
        Save files now must all have their own seperate name.
        Changed text with the rect in keys to be more reliable.

    * 0.8.0
        Removed 'x' button on text boxes, and the escape key.
        Made spikes in Ninja Temple Boss room move same speed in 30 fps mode.
        Zooming in or out of Night Mode is Fixed!
        The screen size/scale on the crash screen is now fixed.
        Changed the applyFps function to set the frameRate, and got rid of the setFrameRate function, it makes the game run faster!
        Fixed going into a level without a scene!
        Fixed the bug where the game crashes right after you collect a new power-up (Fixed but untested)
        The time the player takes to die is now consistent.
        Added a anti-undefined fps system.
        Fixed cave-background snapping.
        Changed the low alpha on intro text.
        Updated the tutorial level to include what things have changed.
        Key text length is verfied, it works!
        Reduced the intro story.
        Way better textboxes, they are fixed!

    * 0.8.1 #Faster fps!
        Fixed the gap between ground and tree.
        The player's autoRun variable will now be saved,
        so next time you play you can get right to it!
        Sort-of found a fix for the auto-button glitch.
        Made the npc abby say a thank you after you open the back door.
        The game now goes into cutscene mode when the player is doing his death animation.
        Completely fixed the background snapping.
        Commented out unnecessary things in the createArray to speed up performance!
        Updated weather effects, doesn't really work with the game though.
        Sped up get place on grid function.
        Night mode now renders faster!
        Changed clouds to be faster!
        Collision loop is now slightly faster.
        Got rid of unecessary code in the createArray!
        Completely removed weather object from the game.
        Completely removed the npc Owen from the game.
        Removed unneeded code from the messageHandler/talkHandler object(s).
        Just made it impossible to get out of a dialog box for cutscene error reasons.
    
    * 0.8.2 #Debugged!
        Fixed zooming in while not looking at the player.
        Sped up gameObjects.applyCollision function!
        Fixed a weird cloud bug where snow instead of rain falls.
        Modified processing.js to run a bit faster with images.
        We now have 2 different frameRate modes! p.doRaf & p.doSt!
        Added another delag button -F11, changes fpsTypes, auto/manual
        Hid the canvas border.
        Fixed backspace press goes back in Firefox.
        Did a few things to try to make this run in other browsers.
        Made a index.css file
        Fixed the keys: Enter, Esc and Backspace!
        There is now a scoring system for Enemies and xStars work as well.
        We now have wiggling falling ice.
        The Voxelizer is now in the game!

    * 0.8.3
        Fixed the cut-scene zoom in bug.
        Added the cut-scene to get the energy item.
        Fixed spike falling bug.
        Fixed water does not appear bug.
        Fixed another cut=scene bug.
        Fixed the door/sign entrance bug.
        Fixed the 30-fps mode can't see gameObjects when loading sometimes.
        Fixed the disappearance bug on cut-scenes.
        Added more to the existing levels in the ice place.
        Changed the text on the scoring system to fit.
        Made a special chest harder to get to.
        Removed all unnecessary comments
        Removed tiles object and array as it was unnecessary.
        Crystals are now in the game!

    * 0.8.4
        The save and exit button is now just the exit button.
        Added a new level: trek
        FireBeakers no longer hop on slopes.
        The player no longer walks when reading a sign.
        Fixed a few no-rendering glitches, and made the rendering a little bit faster!
        Added fps settings
        Fixed beaker glitch!
        Updated Moving platforms to not go back and forth when hitting water.
        Added a new level: Trek2!
        Fixed a minor chest ui bug where the hover won't show.
        Added a new level smooth!
        Added an override settings option!
        Added a different type of tree, the fur tree!
        We now have fairies!
        We now have have level fold2!
        Finished level fold2.
        Changed the special "up" image from '~' to all of '<', '>', '^' and 'v'.
        We now have the Sonic boomer!

    * 0.8.5
        Made deflected Ninja Stars do more damage.
        Fixed weird graphics for a moving platform in the winter theme.        
        Changed level fold2 to be easier!
        Disabled zooming in option.
        Removed text about the zooming in option.
        Fixed bug with snowblocks travel too far.
        Upgraded the Ninja Guard to avoid voxelizers.
        Added boss room door.

    * 0.8.6
        Added extra defense against 20 player hp bug.
        Changed rectangle on score text to extend.
        Made readspeed and inventoryMenu opening speed the same in 30 fps.
        Made the debugTool not be openable in non-debugMode
        Removed streaks.update function from voxelizer.
        Changed objectExists from bool form to binary/number form to save space in localstorage!
        Fixed save file bug where save file button goes down according to screen scaling.
        Added Music 3 different kinds.
        Added more sound code for supporting music/songs.
        Updated sound just a little more.
        Added per level/configLevel music and a song/music on/off button.
        Updated IceDragon 1/2 done!
        Added 2 more levels
        Fixed fps settings.

    * 0.8.7
        Sped up colliding and solveCollision functions in Observer!
        Added the "high" background!
        Finished level mountain and mountain2
        Slightly improved performance.
        Fixed the debug color in "high" background levels.
        Voxelizers now do less damage.
        Made the noSong option available.
        Updated some text for a power-up.
        Voxelizers now can't damage you if you have a bubbleShield.
        Fixed enemy edge detection!
        Updated ice dragon collision to work on both sides. Now all I have to do to is put it on the track.

    * 0.8.8 # Faster fps & Ice Dragon
        Re-added dragon track.
        Finished making points work at same speed (relative) for both loops.
        Finished dragon collision. 
        Now I just have to make it move correctly.
        Finished dragon physics and movement.
        Now rendering.
        Improved image rendering for better fps
        Added speedLetImage, speeds up image rendering.
        Added fps to change between setInterval and requestAnimationFrame
        Finished tweaking ice Dragon boss.
        Finished boss room level.
        Created head
        Created tail
        Completed IceDragon
        
    * 0.8.9 "The Underwhere"
        Made ice dragon more easy to defeat.
        Fixed boss removal.
        Made image rendering faster.
        Added hookshot power up.
        Added hit/damage sound.
        Added 2 more sounds.
        Improved hp bar to add health and boss name. 
        Made a block that costs coins to heal your.
        Finished the hookshot power up
        Fixed a bug dealing with the inventory menu's home page buttons, it had a limited supply!
        Added boss keys.
        Added a new room in the Ninja Temple.
        Fixed the rumble effect.

    * 0.9.0
        Turned off dark grid in the level in the Ninja Temple, that my dad said was lagging.
        BubbleShields now allow you to go underwater!
        Added a bubbleShield in the "underwater" room in the Ninja Temple.
        Fixed lag in Ninja Temple with the turrets/shooters cause lag +Needed to be easier.
        Changed from a try catch to a different way, so there won't be an error in the console, 
        when collecting the key in "ninjaTempleBackyard".
        IceDragon now moves at the same speed in 30 fps mode.
        Finished Boss Intros.
        Added auto checkpoints into settings.
        Fixed a glitch with chests not having enough slots, but appeared to have full slots.
        Gems are now in the game!
        Finished styling for the underground.
        Finished the cave level! Its a looong drop!
        Added different blocks (base64)
            --darkBlock
            --triangleBlockBlue
            --triangleBlockGreen
            --triangleBlockYellow
        You can now shoot voxelizers with the grapping hook.
        Extra controls for weapons added.
        Added level cave 2

    * 0.9.1
        Added Slashers!
        You can now rotate UnderGroundBlock(s)!
        You can now collect gems with the hookshot power-up.
        Added blue and green stalactites.
        We now have the slimeBeaker!
        Bats are now in the game.
        Bats are finished (mostly)
        All beakers now drop coins and/or hp coins, Except for Slime Beakers --Which drop only hpCoins
        Added descriptions for crystals.
        Added level cave3!
        Added level cave4!
        Added level path1!
        Added level path2!
        Added level path1FollowUp!
        Added level intersection!
        Added level secretPath!
        Added a lever puzzle in the "intersection" level that allows you to collect a gem and a chest with a fairy.
        You can now ride on top of the ice dragon's head.
        Minor changes:
            --gem message.
            --hookshot power-up collection message
            --amount of switches in intersection level
            --ceiling height in intersection level
        Imported new music for overworld and ninjatemple

    * 0.9.2
        There is a now the poisonousSlimeBeaker enemy --If you get hit with it 
        Fixed a few bugs in the game and made it easier.
        Added a room that you have to kill everything in there.
        Added levels:
            --CatRoom!
            --pathways
            --moreCaves
        Added a new Enemy a stomper!
        Distributed the new enemy!
        Fixed object charging!
        You can't go back now if you fall off that cliff!
        Added level(s):
            --moreCaves2
        Added blue stalagmites!
        Distributed blue stalagmites!
        Added levels:
            --DEEPEntrance
            --DEEPEntrance2
            --DEEPEntrance3
            --DEEPEntrance4
            --DEEPEntrance5
        Getting ready to make the DEEP

    * 0.9.3
        Deep background added
        Added lamps!
        Lamps can now be turned on and off.
        Made a chest that costs coins to unlock it is granted by Agent X aka Leopard X!
        Added Level DEEP!
        Fixed lighting wouldn't appear glitch
        Made lighting more efficient
        Added levels:
            --DEEPBoxRoom1
            --DEEPBoxRoom2
            --DEEPBoxRoom3
            --DEEPBoxRoom4
            --DEEPBoxRoom5
            --DEEPRoom2
            --DEEPLeverRoom
            --DEEPRoom3
        Added the deep lever room level script.
        Added levels:
            --DEEPOutside

    * 0.9.4
        Added levels:
            --LightTower
        Added laser blocks.
        Added Exclamation Block
        Made minor level changes.
        Somewhat finished the laser blocks.
        Finally finished lazer blocks.
        Added levels:
            --LightTowerP1
            --LightTowerP2
        Fixed laser blocks. 
        Getting ready to make more puzzles.
        Added levels:
            --LightTowerTopFloor
            --LightTowerP3
            --LightTowerP4
            --LightTowerP5
            --LightTowerP6
            --LightTowerP7
            --LightTowerP8
        
    * 0.9.5 #Finishing DEEP
        Finished light tower!
        Fixed 2 songs playing at once bug.
        Removed numerous getObject calls to player and made player a global object!
        backgrounds now render with ctx.drawImage so it's faster!
        The sign in LightTowerTopFloor now tells you how much of "something" you need!
        Altered lamp image to be different than the others (in those repeating rooms!)
        Finally fixed the door glitch in cutscene LightTowerTopFloor
        Refined fix to be "unbreakable"!
        Gems now serve a purpose --Expand your max coin space!
        Added levels:
            --DEEPRoom4
            --DEEPRoom5
            --DEEPCorridor
            --FlashLightRoom /w levelScript
        Added flashLight power-up
        Added levels:
            --DEEPHallway
            --DEEPRoom6
            --DEEPBossRoom
        Added new effect:
        RedHurt effect will hurt you in a less than a second if you don't press the shake button
        Fixed projectile collision!
        Fixed item loss (when reloading a save you lose items you used).
        Created Captain Fleep Boss.
        Finished BossRoom
        Added warp ability.

    * 0.9.6 # Desert and sound update.
        Created the FlashLight upgraded power-up.
        Added feature to release memory from the cameraGrid every 60 seconds.
        Created desert.
        Added swamp tree.
        Created sand blocks.
        Added levels:
            --backToOverworld
            --desert
            --desert 2
            --desert path 1
            --desert path 2
            --desert plain
            --desert plains 2
            --desert plains 3
        Imported:
            --icy_slopes.mp3
            --underground.mp3
            --space.mp3
        Added quicksand.
        Added levels:
            --desert x
            --desert y
            --desert z
        Checked gems and it looks like we have 20
        Added level(s):
            -desert oasis

    * 0.9.7
        Added HelixShip.
        Imported graphics for HelixShip
        Removed air background.
        Created palm trees
        Imported palm trees
        Made palm trees randomized
        Made interior of HelixShip
        Made first prototype of HelixShip blasting off.
        The bubble shield now doesn't go into the negatives.
        Added falling blocks in the "night" level.
        Remade storyHandler, now has less code and you can read at your own pace.
        Remade tutorial level (It had too many descriptions).
        Got rid of some obscure things in desert oasis.
        Got rid of some (other) obscure with the ship.
        Made desert quick sand want to drag you down more.
        Game will now not go into 30 fps mode when in the start/story/selectSaveFile game states.
        Made helixShip be able to go to space.     
        Added extra launching details.
        Created space.
        Made helixShip flame trail more realistic.
        Made text/messages places update.
        Figured out the variables for the launch to space to work.
        Finalized space and ship.
        Fixed bug where the cameraGrid's cellSize is left too big after exiting space.
        Fixed exit block from appearing.

    * 0.9.8
        Fixed minor bugs.
        Fixed border in space.
        Added blasters to helix's Ship
        Fixed cam, it now can have a normal boundingBox while scaling.
        Got rid of unnecessary camera code.
        Fixed: when creating a new save file would result in a bluescreen because of forgotten type check on game.data.ship.
        Imported Talon's Ship
        Thinking about collision and movement --I'll be back for this.
        Replayed Ice World
        Fixed several things in Ice World
        Made a boss fight place.
        Added a barrier to it.
        Added the boss's dialog.
        Added hp bars.
        Updated boss (now has ai, green flames), still not finished but at a good stopping point for now.
        Moved a few thing around.
        Fixed a few things.
        Moved fight area.
        Updated boss to have smarter ai, and he can now drop green bombs/mines. 
        He can now shoot homing missles and has better ai.
        Furthed along boss.
        Finished this boss.
        Fixed a minor bug.
        Fixed minor bugs with the select save file game state.

    * 0.9.9
        HelixShip can now shoot bombs.
        Added Talon's end text.
        Making credits:
            --Enemies Section
            --Boss Section
            --Other
        Finished credits!
        Finished the end screen.
        Got game's end done.
        Removed crash screen.
        You now get a different ending if you collect all gems!
        Fixed a glitch where your inventory is openable, when blasting off to outerspace.
        Fixed a bug where your space ship disappears when blasting off.
        Fixed a bug where the width of a moving platform changes.
        Fixed a bug where abby the npc wouldn't realize if you unlocked the back door for them.
        The airmeter now won't render over the message box.
        Cloudmines now explode underwater again.
        The ninja boss sprite now doesn't have cracks in it.
        Added helix's ship to the credits and named both ships.
        Updated ice sound effect.
        Made the locked_in level harder.
        Made the icyPuzzles2 level harder.
        Added sound ChestAppear.mp3
        Added sound lasered.mp3 (for when cat dog statues want to laser you!)

    * 1.0.0
        The oxygen bar now will not render over the inventory menu like it was rendering over message boxes.
        Fixed the bug where you couldn't use items that have a stack amount of 0, they now work anyway...
        Fixed fixture disappearance glitch in DEEP, had _lights in cells get deleted.
        Fixed a bug where you could in Laser Light Tower cheat and get infinite energy.
        Quickly fixed item duplication by disabling restoring items (that could be in another chest) still not ideal though...
        Fixed captain fleep from sticking to the ceiling in circle mode.
        Fixed a camera bug case where in cam.attach object is undefined.
        Fixed the cutscene (after defeating the boss) in DEEPBossRoom.
        Added enemy: LavaBeaker
        Distributed enemy: LavaBeaker
        Added LavaBeaker to credits
        Fixed stars not rendering in credits.
        Finished play testing game!
        Changed the name from Planet Search 2 to Helix's Adventure.

    Next :   
        Fix Light Tower energy item bugs.

        Test game in its entirety.
        Make final boss fight more epic. (Add minion ships maybe?) 
        Release this game already!

    Maybe:
        Get rid of with statement --Would give about 20% speed increase.
        Enemy damage sound effect?
        Speed up image rendering by doing it directly!
        Update sound settings.
        Make bubbleShield block all projectiles.

    ===========================================================================================================================================================================
    ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    ===========================================================================================================================================================================

    Credits:
        Sound:
            Most mp3s by Khan Academy. (In www.kasandbox.org)
            Other sounds were created by using Bfxr and Chiptone: https://sfbgames.com/chiptone/ (Under CC0 licence)
            Libraries: processing.js (http://processingjs.org)

            Music:
               See bottom of scripts/sounds.js 

        Code:
            CookieHandler object and isEmpty function in saver.js 
            and browserDetection.js were made by their respectable authors on stackoverflow :)

        Levels:
            All levels made by ProlightHub, except one by my brother.

        All other code is by (Me) ProlightHub on Github & Phantom Falcon on Khan Academy!

        Some images made by Shotty
**/

//////////////////////////////////////////////////Feel free to look through the code!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
/*****************************************************************Code*********************************************************************/
////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

var game = {
    fps : 60, 
    loadFps : 160,
    gameState : "start", // Default = "start"
    version : "       v1.0.0",
    fpsType : "auto", // Default = "manual"
    debugMode : false, // Turn this to true to see the fps
    showDebugPhysics : false,
    boundingBoxes : false,
    debugMenuWhite : true,
    
    overrideDebugSettings : false,
    sounds : {
        titleScreen: "planet_search_2.mp3"
    },

    autoCheckPoints : true,
    globalize : true
};
var levelInfo = {
    level : "intro", // Default = "intro"
    xPos : 0,
    yPos : 0,
    width : width,
    height : height,
    /*Changing this will effect game performance. (And maybe collision)
    Too low means that there will be too many cells for the camera to loop through.
    Too high and it means that too many collisions will be checked*/
    //This should be more than the unitSize and less than the cameraSize, If you have a stronger pc turn this up.
    cellWidth : 130, //30-400 (width) best~=80-130
    cellHeight : 130, //30-400 (height) best~=80-130
    /*Changing this will also effect game performance
    Too low means too many objects in each cell and there for lower fps.
    Too high and you won't be able to see anything but you'll get higher fps*/
    unitWidth : 30,
    unitHeight : 30,
    theme : " ",
};
var loader = {
    firstLoad : true, //keep this to true or toggle it if you can't load the game
    lastLevelStepRows : 20,
    levelStepRows : 20, //Loading boost (Turn this to 1 if you're having problems loading)
};
var fonts = {
    title : createFont("cursive"),
    menu : createFont("cursive"),
};

var firstGameState = function() { return game.gameState; } ();
game.startMillis = millis();

var fpsCatcher = {
    actualFps : game.fps,
    lastTime : 0,

    speed : 1,
    deltaTime : 1000 / 60,
    update : function()
    {        
        this.deltaTime = (performance.now() - this.lastTime);
        var delta = this.deltaTime / 1000;
        this.speed = delta * 60;

        if(performance.now() % 15 >= 14)
        {
            this.actualFps = (1 / delta).toFixed(0);
        }

        this.lastTime = performance.now();
    },
};

// Reload when crashing?
game.reload = false;

var RAD_TO_DEG = (180 / Math.PI);
var DEG_TO_RAD = (Math.PI / 180);

//Constants
var PI_MULT = PI / 180;
var MODE = "pjs";//Ka or pjs

//Make sure we have the right angle mode.
angleMode = "degrees";

//Predefine (Globals)
var cam, cameraGrid, GameObject, observer, gameObjects, loader;

//Constants
const WIDTH = width;
const HEIGHT = height;
const HALF_WIDTH = width / 2;
const HALF_HEIGHT = height / 2; 
const BTN_COLOR = color(11, 68, 153, 200);

//Smooth out textures
// smooth();

// No smoothing for performance
noSmooth();

var shipGoto = {};

shipGoto.launch = function()
{
    shipGoto.launched = true;

    loader.startLoadLevel("desert oasis", "door", 0, function()
    {
        cameraGrid.removeReference(player);
    });
};

var keyIsPressed = false;

var BACKSPACE_KEY = false;
var ESC_KEY = false;
var ENTER_KEY = false;

var keys = [];
var keyPressed = function()
{
    keys[keyCode] = true;
    keys[(key || "").toString()] = true;
    keyIsPressed = true;

    BACKSPACE_KEY = keys[BACKSPACE];
    ENTER_KEY = keys[ENTER];
    ESC_KEY = keys[ESC];
};
var keyReleased = function()
{
    keys[keyCode] = false;
    keys[(key || "").toString()] = false;

    keyIsPressed = false;
    BACKSPACE_KEY = false;

    ENTER_KEY = keys[ENTER];
    ESC_KEY = keys[ESC];
};

function accelerateImg(img)
{
     if(img.__isDirty)
    {
        img.updatePixels();
    }

    if(!img.toImageData && img.loadPixels)
    {
        img.loadPixels();
    }
    
    if(!img.noSourceImg && img.toImageData)
    {
        img.sourceImg = getSourceImg(img);
    }
}

if(MODE === "pjs")
{
    canvas.onkeydown = function(event)
    {
        keyCode = event.keyCode;

        if(event.keyCode === 8)
        {
            keyPressed();
            event.preventDefault();
        }
    };

    println = console.log;

    window.loadedImages = {};

    function _load_(index)
    {
        loadedImages[index] = processing.loadBase64(storage.base64[index], function(img)
        {
            loadedImages[index] = img;
        });
    }

    for(var i in storage.base64)
    {
        if(typeof storage.base64[i] === "string")
        { 
            _load_(i);
        }
    }
};

// Found in numerous Khan Academy projects
var Font = (function () {
    return this.Function ( "gfName", 
        "gfName = gfName.replace (/\\s+/g, '+');" + 
        "var subsets = Array.prototype.slice.call(arguments, 1, arguments.length - 1);" + 
        "var url = 'https://fonts.googleapis.com/css?family=' + gfName + ( subsets.length > 0 ? '&amp;subset=' + subsets : ''), callback = arguments[arguments.length - 1];" +
        "var gfs = document.querySelectorAll('link[href=\"' + url+'\"]');" + 
        "if (!gfs.length) {" + 
            "var f = document.createElement('link');" + 
            "f.setAttribute('rel', 'stylesheet');" + 
            "f.setAttribute('type', 'text/css');" + 
            "f.onload = callback;" +    
            "f.setAttribute('href', url);" + 
            "document.head.appendChild(f);" + 
        "} else if (typeof callback === 'function') {" + 
            "callback.call(gfs[0]);" + 
        "}"
    );
})();

try{
    Font("Lora");
}
catch(e)
{
    console.log(e);
}

function removeEndIfNum(v)
{
    if(v.slice(v.length - 1).match(new RegExp('[0-9]'))) 
    {
        return v.slice(0, -1);
    }

    return v;
}

// This gets referenced a lot and I mean a LOT!
var player = {};

////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
/******************************************************************UI**********************************************************************/
////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

var Button = function(xPos, yPos, width, height, colorVal, message, _round, _textSize)
{
    this.xPos = xPos;
    this.yPos = yPos;
    this.width = width;
    this.height = height;

    this.color = colorVal;
    this.message = message;
    
    this.defaultXPos = xPos;
    this.defaultYPos = yPos;

    this.halfWidth = this.width / 2;
    this.halfHeight = this.height / 2;

    this.isButton = true;

    this.firstColor = this.color;

    this.textColor = color(0, 0, 0);

    this.round = _round;

    this.textSize = _textSize || 12;

    this.draw = function()
    {
        noStroke();
        fill(this.color);
        $pjs.rect(this.xPos, this.yPos, this.width, this.height, this.round);
        fill(0, 0, 0);
        textAlign(CENTER, CENTER);
        textSize(this.textSize);
        if(this.font !== undefined)
        {
            textFont(this.font);
        }
        fill(this.textColor || this.color);
        text(this.message + (this.extra || ""), this.xPos + this.halfWidth, this.yPos + this.halfHeight);

        if(this.highlightColor !== undefined)
        {
            fill(this.highlightColor);
            $pjs.rect(this.xPos, this.yPos, this.width, this.height, this.round);
        }

        if(this.highlightStroke !== undefined)
        {
            strokeWeight(1.5);
            stroke(this.highlightStroke);
            noFill();
            $pjs.rect(this.xPos, this.yPos, this.width, this.height, this.round);
            noStroke();
        }
    };
    
    this.onClick = function() {};

    this.clicked = function(override)
    {
        var is = ((mouseIsPressed || override) && observer.collisionTypes.pointrect.colliding({xPos : mouseX, yPos : mouseY}, this));  

        if(is)
        {
            this.onClick(override);
        }

        return is;
    };
};

//Pretty chunky, eh?
var buttons = {
    play : new Button(160, 210, 80, 25, BTN_COLOR, "Play"),
    how : new Button(160, 245, 80, 25, BTN_COLOR, "How"),
    extras : new Button(160, 280, 80, 25, BTN_COLOR, "Extras"),
    back : new Button(160, 210 - 30, 80, 25, BTN_COLOR, "Back"),
    restart : new Button(160, 245 - 30, 80, 25, BTN_COLOR, "Restart"),
    menu : new Button(160, 280 - 30, 80, 25, BTN_COLOR, "Menu"),
    back2 : new Button(0, 375, 75, 25, BTN_COLOR, "Back"),
    settings : new Button(160, 210, 80, 25, BTN_COLOR, "Debug"),
    sound : new Button(160, 245, 80, 25, BTN_COLOR, "Sound"),
    other : new Button(160, 280, 80, 25, BTN_COLOR, "Fps"),
    volumeOn : new Button(160, 230, 80, 25, BTN_COLOR, "Volume"),
    music : new Button(160, 195, 80, 25, BTN_COLOR, "Music"),
    debugMode : new Button(145, 185, 110, 25, BTN_COLOR, "DebugMode " + game.debugMode),
    debugPhysics : new Button(145, 220, 110, 25, BTN_COLOR, "DebugPhysics " + game.showDebugPhysics || false),
    boundingBoxes : new Button(145, 255, 110, 25, BTN_COLOR, "BoundingBoxes"),
    fps : new Button(145, 200, 110, 25, BTN_COLOR, "Fps " + game.fps),
    fpsType : new Button(145, 230, 110, 25, BTN_COLOR, "Fps Type " + game.fpsType),
    info : new Button(145, 290, 110, 25, BTN_COLOR, "Info"),
    save : new Button(155, 285, 90, 25, BTN_COLOR, "Exit"),
    erase : new Button(205, 235, 80, 30, BTN_COLOR, "Erase"),
    back3 : new Button(115, 235, 80, 30, BTN_COLOR, "Back"),
    back4 : new Button(115, 235 + 30, 80, 30, BTN_COLOR, "Back"),
    back5 : new Button(0, 290, 30, 30, BTN_COLOR, "<<"),
    create : new Button(205, 235 + 30, 80, 30, BTN_COLOR, "Create"),
    rename : new Button(205, 235 + 30, 80, 30, BTN_COLOR, "Rename"),
    controls : new Button(160, 175, 80, 25, BTN_COLOR, "Controls"),
    auto : new Button(150, 225, 100, 25, BTN_COLOR, "Auto save " + game.autoCheckPoints),
};
buttons.boundingBoxes.textSize = 11;
buttons.debugPhysics.textSize = 11;

buttons.load = function(something)
{
    for(var i in (something || this))
    {
        (something || this)[i].round = 7; 
        (something || this)[i].textColor = color(20, 20, 20, 150);
    }
};

var storyHandler = {
    scroll : 0,
    message : "",
    storyIndex : 0,
    color : color(31, 173, 88),
    index : 0,
    set : function(i)
    {
        if(i >= this.story.length)
        {
            return;
        }

        this.message = this.story[i].message;
        this.color = this.story[i].color;
        this.scroll = 0;
    },
    show : function()
    {
        if(this.storyIndex >= this.story.length)
        {
            this.set(this.story.length - 1);
            return;
        }

        if(!this.init)
        {
            this.storyIndex = 0;
            this.set(0);
            this.init = true;
        }

        if((ENTER_KEY || mouseIsPressed) && !screenUtils.fade.fading)
        {
            screenUtils.fade.start(20, 0);  
            this.startingFromHere = true;
        }

        if(this.startingFromHere && screenUtils.fade.full())
        {
            this.storyIndex++;
            this.set(this.storyIndex);
            delete this.startingFromHere;
        }
    },
    story : [{
        message : "Enter/Click to start intro!"
    }, {
        message : "2,000 years ago, a hypercrystal\nwas born inside of Titan."
    }, {
        message : "Titan is a noble planet found\nwith-in the center of this galaxy.",
    }, {
        message : "This hypercrystal contains an\nultimate binding of power!"
    }, {
        message : "Aliens constructed by the evil\nforces of Talon have obstructed this crystal!",
    }, {
        message : "A battle between aliens lasted for \n1,000 years!"
    }, {
        message : "Finally it was divided into multiple\ncrystals and its power was sealed away.",
    }, {
        message : "These crystals have been scattered\nacross this galaxy."
    }, {
        message : "Talon has re-discovered a green crystal!\nThis crystal has the power to\nsend a virus to a planet!",
    }, {
        message : "Fortunately you escaped Planet Search\nbefore it was infected."
    }, {
        message : "You were sent to Amber by a spacecraft\non a mission to find 3 of the crystals.",
    }, {
        message : "Unfortunately you had to eject in an\nescape pod on entry."
    }, {
        message : "You are now seperated by thousands\nof miles from your ship."
    }, {
        message : "Your new mission is to find 3 crystals, and harness\ntheir power to find your ship.",
    }, {
        message : "Now go hero! Choose your path wisely!\nGood luck!"
    }],
};

var saveDataHandler = {
    saveFiles : [],
    buttons : {
        new : new Button(85, 290, 60, 30, color(11, 68, 153, 140), "New"),
        copy : new Button(170 + 35, 255, 60, 30, color(11, 68, 153, 140), "Copy"),
        rename : new Button(170 - 35, 255, 60, 30, color(11, 68, 153, 140), "Rename"),
        play : new Button(155, 290, 90, 30, color(11, 68, 153, 140), "Play"),
        erase : new Button(255, 290, 60, 30, color(11, 68, 153, 140), "Erase"),
        left : new Button(0, 160, 30, 100, color(0, 0, 0, 100), "<"),
        right : new Button(370, 160, 30, 100, color(0, 0, 0, 100), ">"),
    },
    draw : function()
    {
        for(var i in this.buttons)
        {
            this.buttons[i].draw();
        }

        for(var i = 0; i < this.saveFiles.length; i++)
        {
            this.saveFiles[i].draw();
        }
    },
    props : {
        slide : 140,
        startSlide : 140,
        slideSpeed : 5,
        spacing : 160,
        scale : 0.7,
        range : {
            min : 100,
            max : 300, 
        },
    },
    sortSaveFiles : function()
    {
        var newSaveFiles = [];
        var names = {};

        //Sort by save file name
        for(var i = 0; i < this.saveFiles.length; i++)
        {
            if(names[this.saveFiles[i].name])
            {
                var name = this.saveFiles[i].name;
                this.saveFiles[i].message = this.saveFiles[i].name = (
                isNaN(Number(name[name.length - 1])) ? name : name.slice(0, -1)) + ((Number(name[name.length - 1]) || 0) + 1);
            }else{
                names[this.saveFiles[i].name] = 1;
            }

            var num = Number((this.saveFiles[i].saveFileName.match(/[0-9]+/) || [0])[0]) - 1;

            if(newSaveFiles[num] === undefined)
            {
                newSaveFiles[num] = this.saveFiles[i];
            }else{
                newSaveFiles.splice(num, 0, this.saveFiles[i]);
            }
        }

        //Get rid of empty temp files
        var newSaveFiles2 = [];
        for(var i = 0; i < newSaveFiles.length; i++)
        {
            if(newSaveFiles[i] !== undefined && newSaveFiles[i].saveFileName !== undefined)
            {
                newSaveFiles2.push(newSaveFiles[i]);
            }
        }

        this.saveFiles = newSaveFiles2;
    },
    getSelectedSaveFile : function()
    {
        for(var i = 0; i < this.saveFiles.length; i++)
        {
            if(this.saveFiles[i].selected)
            {
                return this.saveFiles[i];
            }
        }
        return false;
    },
    erase : function(saveDataName, saveFile)
    {
        for(var i = this.saveFiles.length - 1; i >= 0; i--)
        {
            if(this.saveFiles[i].saveFileName === saveDataName)
            {
                saver.eraseSaveData(saveDataName);
                this.saveFiles.splice(i, 1);
                break;
            }
        }
        this.sortSaveFiles();
    },
    getNumName : function()
    {
        var exists = [];

        for(var i in saver.saveData)
        {
            exists[Number((i.match(/[0-9]+/) || [0])[0])] = true;
        }

        exists.shift();

        var j = 0;
        while(j < exists.length)
        {
            if(exists[j])
            {
                j++;
            }else{
                break;
            }
        }

        return j + 1;
    },
    addNew : function(saveDataName, name, replace, no, replaceName)
    {
        var saveName = (saveDataName || "save");
        if(!no)
        {
            saveName += this.getNumName();
        }
        saver.newSaveData(saveName, name, replace, replaceName);
        saveDataHandler.createSaveBtn(saveName, saver.saveData);
        buttons.load(this.saveFiles);
        this.sortSaveFiles();
        this.props.slide = -(this.props.spacing * this.saveFiles.length) + width * 0.75 - this.props.startSlide;
        this.slid = true;
        return saveName;
    },
    copySelectedSaveFile : function()
    {
        if(this.saveFiles.length < saver.maxSaves)
        {
            var svf = this.getSelectedSaveFile();
            if(svf)
            {
                this.addNew("save", "", saver.readSaveData(svf.saveFileName), undefined);
            }
        }
    },
    renameSaveFile : function(rename)
    {
        var svf = this.getSelectedSaveFile();
        if(svf)
        {
            //Get rid of the saveFile displayer
            for(var i = 0; i < this.saveFiles.length; i++)
            {
                if(this.saveFiles[i].saveFileName === svf.saveFileName)
                {
                    this.saveFiles.splice(i, 1);
                    break;
                }
            }

            //Remake it!
            this.addNew(svf.saveFileName, "", saver.readSaveData(svf.saveFileName), true, rename);

            this.sortSaveFiles();

            //Slide back to selectedSaveFile
            var num = Number(svf.saveFileName.match(/[0-9]+/)[0]) - 1;
            this.props.slide += (num * this.saveFiles[this.saveFiles.length - 1].width + this.props.spacing) - this.props.spacing * 0.25;
        }
    },
    update : function()
    {
        if(this.saveFiles.length > 0)
        {
            //Slide back if to far
            if(this.saveFiles[this.saveFiles.length - 1].xPos < this.props.startSlide * 0.9)
            {
                this.props.slide += this.props.slideSpeed;
            }

            if((keys[LEFT] || keys.a || this.buttons.left.clicked()) && this.saveFiles[0].xPos <= this.props.startSlide)
            {
                this.props.slide += this.props.slideSpeed * (game.fps === 30 ? 2 : 1);
            }
            else if((keys[RIGHT] || keys.d || this.buttons.right.clicked()) && this.saveFiles[this.saveFiles.length - 1].xPos >= this.props.startSlide)
            {
                this.props.slide -= this.props.slideSpeed * (game.fps === 30 ? 2 : 1);
            }

            if(this.slid)
            {
                this.slid = false;
                if(this.saveFiles[0].xPos >= this.props.startSlide && this.saveFiles.length > 1)
                {
                    this.props.slide -= this.props.slideSpeed * 4;
                    this.slid = true;
                }
                else if(this.saveFiles[this.saveFiles.length - 1].xPos <= this.props.startSlide)
                {
                    this.props.slide += this.props.slideSpeed * 4;
                    this.slid = true;
                }
            }
        }
        for(var i = 0; i < this.saveFiles.length; i++)
        {
            var saveFile = this.saveFiles[i];
            saveFile.xPos = this.props.slide + (this.props.spacing * i); 

            if(saveFile.xPos > this.props.range.min && saveFile.xPos + saveFile.lastWidth < this.props.range.max)
            {
                saveFile.width = saveFile.lastWidth;
                saveFile.height = saveFile.lastHeight;
                saveFile.yPos = saveFile.lastYPos;
                saveFile.selected = true;
                saveFile.color = color(0, 50, 0, 100);
            }else{
                saveFile.width = saveFile.lastWidth * this.props.scale;
                saveFile.height = saveFile.lastHeight * this.props.scale;
                saveFile.yPos = saveFile.lastYPos + saveFile.height * 0.25;
                saveFile.selected = false;
                saveFile.color = saveFile.lastColor;
            }

            saveFile.halfWidth = saveFile.width / 2;
            saveFile.halfHeight = saveFile.height / 2;
        }

        if(!this.init || mouseIsPressed || keyIsPressed)
        {
            this.sortSaveFiles();
            this.init = true;
        }
    },
    createSaveBtn : function(input, data)
    {
        var btnWidth = 130;
        var btnHeight = 75;

        var btn = new Button(HALF_WIDTH - btnWidth / 2, HALF_HEIGHT * 2 / 1.9 - btnHeight / 2, btnWidth, btnHeight, color(0, 0, 0, 100), data[input].name);
        btn.lastDraw = btn.draw;
        btn.saveFileName = input;
        btn.name = data[input].name;
        btn.draw = function()
        {
            var sfn = (saveDataHandler.getSelectedSaveFile() || {}).saveFileName;

            btn.lastDraw();
            fill(0, 0, 0, 100);
            textSize((sfn === this.saveFileName) ? 17 : 11);
            textAlign(CENTER, CENTER);
            text(/*input*/"save", this.xPos + this.halfWidth, this.yPos + this.height * 0.21);            
           
            fill(0, 0, 0, 100);
            textSize((sfn === this.saveFileName) ? 12 : 9);
            text("Coins " + ((data[input].player || {}).coins || 0) + "\nScore " + ((data[input].player || {}).score || 0), 
                 this.xPos + this.halfWidth, this.yPos + this.height * 0.8);
        };
        btn.lastWidth = btn.width;
        btn.lastHeight = btn.height;
        btn.lastYPos = btn.yPos;
        btn.lastColor = btn.color;
        this.saveFiles.push(btn);
    },
    load : function()
    {
        buttons.load(saveDataHandler.buttons);
        this.buttons.left.textColor = color(200, 200, 200, 200);
        this.buttons.right.textColor = color(200, 200, 200, 200);

        //Add in the save files (buttons)
        for(var j in saver.saveData)
        {
            this.createSaveBtn(j, saver.saveData);
        }

        while(this.saveFiles.length > saver.maxSaves)
        {
            saver.eraseSaveData(this.saveFiles[this.saveFiles.length - 1].saveFileName, true);
            this.saveFiles.pop();
        }
        
        saver.apply();
        buttons.load(this.saveFiles);
    },
};
saveDataHandler.load();

window.saveDataHandler = saveDataHandler;

var Slider = function(xPos, yPos, width, height, colorValue, message)
{
    this.xPos = xPos;
    this.yPos = yPos;
    this.width = width;
    this.height = height;
    this.color = colorValue;
    
    this.halfWidth = this.width / 2;
    this.halfHeight = this.height / 2;

    this.notchSize = 0.15;
    this.notch = {
        xPos : this.xPos,
        yPos : this.yPos,
        width : this.width * this.notchSize,
        height : this.height * this.notchSize,
    };
    
    this.xDiv = (this.width > this.height) ? this.width * this.notchSize * 2 : 0;
    this.yDiv = (this.height > this.width) ? this.height * this.notchSize * 2 : 0;
    
    this.message = message;

    this.draw = function()
    {
        noStroke();
        fill(this.color);
        $pjs.rect(this.xPos, this.yPos, this.width, this.height, this.round);
        
        noStroke();
        fill(this.color);
        if(this.width > this.height)
        {
            $pjs.rect(this.notch.xPos, this.notch.yPos,
            this.notch.width, this.height, this.round * 1.5);
            if(!this.using)
            {
                this.yDiv = 0;
                this.xDiv = this.width * this.notchSize * 2;
            }
        }else{
            $pjs.rect(this.notch.xPos, this.notch.yPos, 
            this.width, this.notch.height, this.round * 1.5);
            if(!this.using)
            {
                this.xDiv = 0;
                this.yDiv = this.height * this.notchSize * 2;
            }
        }
        this.using = false;

        fill(0, 0, 0);
        textAlign(CENTER, CENTER);
        textSize(this.textSize || 12);
        if(this.font !== undefined)
        {
            textFont(this.font);
        }
        fill(this.textColor || this.color);
        text(this.message, this.xPos + this.halfWidth, this.yPos + this.halfHeight);
    };
    
    this.isInside = function(mouse)
    {
        return observer.collisionTypes.pointrect.colliding(mouse, this, this.xDiv, this.yDiv);
    };
    
    this.getPercent = function()
    {
        if(this.width > this.height)
        {
            this.max = this.width - this.notch.width;
            this.min = this.notch.xPos - this.xPos;
        }else{
            this.max = this.height - this.notch.height;
            this.min = this.notch.yPos - this.yPos;
        }
        return (this.min * 100) / this.max;
    };

    this.set = function(percent)
    {
        var max = this.width - this.notch.width;
        var input = this.xPos + (percent * max / 100);
        if(this.width > this.height)
        {
            this.notch.xPos = constrain(input,
            this.xPos, this.xPos + this.width - this.notch.width);
        }else{
            this.notch.yPos = constrain(input,
            this.yPos, this.yPos + this.height - this.notch.height);
        }
    };

    this.onClick = function(mouse)
    {
        if(this.width > this.height)
        {
            this.notch.xPos = constrain(mouse.xPos,
            this.xPos, this.xPos + this.width - this.notch.width);
        }else{
            this.notch.yPos = constrain(mouse.yPos,
            this.yPos, this.yPos + this.height - this.notch.height);
        }
        this.yDiv = 300;
        this.xDiv = 300;
        this.using = true;
    };
};

var sliders = {
    volume : new Slider(160, 265, 80, 25, color(11, 68, 153, 100), 100 + "%"),
};
sliders.load = function()
{
    for(var i in this)
    {
        this[i].round = 7;
        this[i].textColor = color(20, 20, 20, 150);
    }
    this.volume.set(sounds.settings.mainVolume * 100);
};

var Bar = function(xPos, yPos, width, height, colorValue, inRound, barColor, strokeColor)
{
    this.xPos = xPos;
    this.yPos = yPos;
    this.width = width;
    this.height = height;

    this.defaultWidth = this.width;
    this.defaultHeight = this.height;

    this.halfWidth = this.width / 2;
    this.halfHeight = this.height / 2;

    this.color = colorValue;
    this.barColor = barColor;
    this.strokeColor = strokeColor;

    this.input = 0;
    this.set = function(amt, max)
    {
        this.input = (this.width * amt) / max;
    };
    
    this.draw = function(amt, max) 
    {
        if(!this.barColor)
        {
            noFill();
        }else{
            fill(this.barColor);
        }

        $pjs.rect(this.xPos, this.yPos, this.width, this.height, (inRound || 0));

        fill(this.color);
        $pjs.rect(this.xPos, this.yPos, (amt !== undefined) ? ((this.width * amt) / max) : this.input, this.height, (inRound || 0));
        noFill();

        if(!this.noStroke) 
        { 
            strokeWeight(1);
            if(!this.strokeColor)
            {
                stroke(0, 0, 0, 50); 
            }else{
                stroke(this.strokeColor);
            }
        }

        $pjs.rect(this.xPos, this.yPos, this.width, this.height, (inRound || 0));
        noStroke();
    };
};
var TextBox = function(xPos, yPos, width, height, colorVal, secondColorValue, textColor)
{
    this.xPos = xPos;
    this.yPos = yPos;
    this.width = width;
    this.height = height;
    this.color = colorVal;

    this.message = "";
    this.selected = false;
    this.multipleLines = false;

    this.cursorIndex = 0;
    this.cursorMode = "line";

    this.textSize = 12;
    this.cursorIndex = 0;

    this.noSpaces = false;
    this.input = [];

    this.secondColorValue = secondColorValue || 100;
    this.textColor = textColor !== undefined ? textColor : color(0, 0, 0, 100);

    this.getCursorAscii = function()
    {
        if(millis() % 1000 > 500)
        {
            return "";
        }

        switch(this.cursorMode)
        {
            case "line" :
                return "|";

            case "insert" :
                return "_";
        }
    };

    this.draw = function()
    {
        fill(this.color);
        $pjs.rect(this.xPos, this.yPos, this.width, this.height, this.round);
        fill(0, 0, 0);
        textAlign(NORMAL, NORMAL);


        fill(this.textColor);
        textSize(this.textSize);
        text(this.message + this.getCursorAscii(), this.xPos + 3, this.yPos + this.height * 0.3, this.width, this.height);
        noStroke();

        /*************/

        if(this.maxLength && this.maxLength !== Infinity)
        {
            var msg = this.maxLength - this.message.length + " left";
            text(msg, this.xPos + this.width - 5 - textWidth(msg), this.yPos + this.height * 0.3, this.width, this.height);
        }

        this.color = (this.selected) ? colorVal : this.secondColorValue;

        if(!this.selected)
        {
            this.cursorIndex = this.message.length;
        }

        if(this.isMouseInside())
        {
            cursor("text");
            game.cursor = "text";
        }else{
            cursor("default");
            game.cursor = "default";
        }
    };

    this.maxLength = 9;

    this.edit = function()
    {
        if(!this.selected || !keyIsPressed)
        {
            return;
        }

        if(BACKSPACE_KEY)
        {
            this.input.pop();
            keyReleased();
        }
        else if(keyCode !== SHIFT && key.toString() !== "￿" && key.toString() !== "\n")
        {
            this.input.push(key.toString());
        }

        this.message = this.input.join("");

        textSize(this.textSize);

        if(this.maxLength < this.message.length || textWidth(this.message) > this.width - 10)
        {
            this.message = this.message.slice(0, -1);
            this.input = this.message.split("");
        }
    };

    this.isMouseInside = function()
    {
        return observer.collisionTypes.pointrect.colliding({xPos : mouseX, yPos : mouseY}, this);
    };

    this.clicked = function()
    {
        return (mouseIsPressed && observer.collisionTypes.pointrect.colliding({xPos : mouseX, yPos : mouseY}, this));
    };
};

var textBoxes = {
    naming : new TextBox(150, 210 + 25, 100, 20, 125),
};
textBoxes.naming.round = 7;
textBoxes.naming.safeStr = true;
textBoxes.naming.message = "Helix";

var MessageBox = function(xPos, yPos, width, height, colorValue)
{
    this.xPos = xPos;
    this.yPos = yPos;
    this.width = width;
    this.height = height;
    this.color = colorValue;

    this.message = "";

    var sz = this.width * 0.06;
 
    this.readingIndex = 0;
    this.lastReadingIndex = 0;
    this.counter = 0;
    this.counterFull = true;

    this.readSpeed = 0.55;

    this.draw = function()
    {
        noStroke();
        fill(this.color);
        $pjs.rect(this.xPos, this.yPos, this.width, this.height, 5);
        fill(this.textColor || color(255, 255, 255, 175));
        if(this.font !== undefined)
        {
            textFont(this.font);
        }
        textAlign(NORMAL, NORMAL);
        textSize(this.textSize || 12);
        if(this.messages !== undefined && this.messages.length > 0)
        {
            var str = "";
            for(var i = 0; i < this.readingIndex; i++)
            {
                var message = this.messages[i];
                var messageArray = message.message.split("");

                var colorPack = message.colorPack;
                if(colorPack !== undefined)
                {
                    message.color = color(colorPack.red || 255, colorPack.green || 255, colorPack.blue || 255, colorPack.alpha || 255);
                }

                fill(message.color || this.textColor);

                var msg = message.message;

                if(!this.doneReading && i === this.readingIndex - 1)
                {
                    var val = Math.floor(this.counter) - msg.length;

                    if(Math.floor(this.counter) >= msg.length)
                    {
                        this.counterFull = true;
                    }

                    msg = msg.slice(0, val);
                }

                text(msg, this.xPos + 10 + textWidth(str), this.yPos + 20);
                str += message.message + " ";
            }

            if(this.skipAll)
            {
                this.counter = this.message.length;
                this.counterFull = true;
                this.skipAll = false;
                return;
            }

            if(!this.doneReading)
            {
                this.counter += this.readSpeed;

                if(game.fps <= 40)
                {
                    this.counter += this.readSpeed;
                }
            }

            if(this.counterFull)
            {
                this.readingIndex += 1;
                if(this.readingIndex <= this.messages.length)
                {
                    this.counter = 0;
                }else{
                    this.doneReading = true;
                }
                this.counterFull = false;
            }
            
            this.readingIndex = Math.min(this.readingIndex, this.messages.length);

            this.lastReadingIndex = this.readingIndex;
        }else{
            var msg = this.message;

            if(this.skipAll)
            {
                this.counter = this.message.length;
                this.doneReading2 = true;
                this.skipAll = false;
                return;
            }

            if(!this.doneReading2)
            {
                var val = Math.floor(this.counter) - msg.length;

                if(this.counter >= msg.length)
                {
                    this.doneReading2 = true;
                }

                msg = msg.slice(0, val);

                this.counter += this.readSpeed;

                if(game.fps <= 40)
                {
                    this.counter += this.readSpeed;
                }
            }
            text(msg, this.xPos + 10, this.yPos + 20);
        }
    };
};

var messageBoxes = {};
var choiceButtons = [];
var messageHandler = {
    choices : {},
    active : false,
    newMessage : function(name, message, messages, font, up)
    {
        if(messageBoxes[name] === undefined)
        {
            var yDiv = 50;

            var setY = ((typeof up === "boolean") ? yDiv : ((typeof up === "number") ? up : 0)); 

            this.origSetWidth = 250;
            this.origSetHeight = 60;

            this.origSetX = (HALF_WIDTH - this.origSetWidth / 2);
            this.origSetY = (setY || HEIGHT - (this.origSetHeight + yDiv));

            this.up = up;

            messageBoxes[name] = new MessageBox(this.origSetX, this.origSetY, this.origSetWidth, this.origSetHeight, color(0, 0, 0, 100));
            messageBoxes[name].message = message || "?";
            messageBoxes[name].messages = messages || messageBoxes[name].messages;
            messageBoxes[name].font = font;

            this.currentName = name;

            this.setup = true;
        }
    },
    removeMessage : function(name)
    {
        delete messageBoxes[name];
    },
    addChoice : function(name, message, config)
    {
        this.choices[name] = config || {
            message : message,
        };
    },
    draw : function()
    {
        if(!this.active)
        {
            return;
        }

        var alphaAmt = 100;

        if(this.setup)
        {
            this.choiceAmt = 0;
            for(var i in this.choices)
            {
                this.choiceAmt++;
            }

            this.btnSpacing = 4;
            this.btnHeight = 20;

            var minY = (this.choiceAmt * (this.btnHeight + this.btnSpacing) / 2);
            var diff = (HALF_HEIGHT - minY);
            var setX;

            var minSetX = WIDTH;
            var maxBtnWidth = 0;

            var textAlpha = 175;

            var j = 0;
            for(var i in this.choices)
            {
                if(choiceButtons[i] === undefined)
                {
                    var btnWidth;

                    try{
                        btnWidth = textWidth(this.choices[i].message)
                    }
                    catch(e)
                    {
                        console.log(e);
                    }
                    
                    this.btnWidth = Math.max(this.defMinBtnWidth || 60, (btnWidth || 310) * (this.choices[i].resize || 0.5));

                    setX = (HALF_WIDTH - this.btnWidth / 2);
                    if(minSetX > setX)
                    {
                        minSetX = setX;
                    }

                    if(maxBtnWidth < this.btnWidth)
                    {
                        maxBtnWidth = this.btnWidth;
                    }

                    if(this.choiceAmt === 1)
                    {
                        choiceButtons[i] = new Button(setX, this.origSetY + this.origSetHeight - this.btnHeight / 2, this.btnWidth, this.btnHeight, this.defButtonCollor || color(0, 0, 0, alphaAmt), this.choices[i].message);
                    }else{
                        choiceButtons[i] = new Button(setX, diff + j * (this.btnHeight + this.btnSpacing), this.btnWidth, this.btnHeight, this.defButtonCollor || color(0, 0, 0, alphaAmt), this.choices[i].message);
                    }

                    choiceButtons[i].textColor = this.choices[i].color || color(255, 255, 255, textAlpha);
                    choiceButtons[i].textSize = this.choices[i].textSize || choiceButtons[i].textSize;
                    choiceButtons[i].round = 5; 
                    choiceButtons[i].fromI = i;
                    choiceButtons[i].index = j;
                }
                j++;
            }

            if(this.choiceAmt > 1)
            {
                var div = this.btnSpacing + 3;
                this.planXPos = (minSetX - div);
                this.planYPos = (diff - div);
                this.planWidth = (maxBtnWidth + div * 2);
                this.planHeight = (HALF_HEIGHT + minY - diff + div * 2) - 2;
                this.highlightColor = this.defHighlightColor || color(0, 100, 200, 100);
            }
            this.highlightedNumber = 0;

            this.disableTime = millis() - 10000;

            this.setup = false;
        }

        for(var i in messageBoxes)
        {
            messageBoxes[i].draw();
        }

        if(this.choiceAmt > 1)
        {
            fill(0, 0, 0, alphaAmt + 20);
            $pjs.rect(this.planXPos, this.planYPos, this.planWidth, this.planHeight, 5);
        }

        var j = 0;
        for(var i in choiceButtons)
        {
            if(this.highlightedNumber === j)
            {
                choiceButtons[i].highlightColor = this.highlightColor;
            }

            if((choiceButtons[i].clicked() ||
               (this.highlightedNumber === j && (keys[32] || ENTER_KEY))) && 
               !messageHandler.pickedChoice && millis() - this.disableTime > 1000)
            {
                if((messageBoxes[this.currentName].doneReading || 
                    messageBoxes[this.currentName].doneReading2))
                {
                    messageHandler.choice = i;
                    messageHandler.pickedChoice = true;
                }else{
                    messageBoxes[this.currentName].skipAll = true;
                    this.disableTime = millis();
                }
            }

            choiceButtons[i].draw();
            choiceButtons[i].highlightColor = color(0, 0, 0, 1);

            j++;
        }

        try{
            textAlign(LEFT, CENTER);
            textSize(12);
            fill(this.defTextColor || color(255, 255, 255, 130));
            text(this.nameToShow || "", messageBoxes[this.currentName].xPos + 20,  messageBoxes[this.currentName].yPos);
        }
        catch(e)
        {
            console.warn("Error: " + e);
        }
    },
    keyPressed : function()
    {
        if(this.choiceAmt > 1)
        {
            if(keys.w || keys[UP])
            {
                this.highlightedNumber--;
            }
            else if(keys.s || keys[DOWN])
            {
                this.highlightedNumber++;
            }

            this.highlightedNumber = constrain(this.highlightedNumber, 0, this.choiceAmt - 1);
        }else{
            this.highlightedNumber = 0;
        }
    },
    keyReleased : function()
    {
        this.disableTime = millis() - 1000;
    },
    mouseReleased : function()
    {
        this.disableTime = millis() - 1000;
    }
};

var talkHandler = {
    messagePattern : {},
    up : true,
    timer : 0,
    start : function(messagePattern, message, name, up)
    {
        this.message = message;
        this.messagePattern = messagePattern || {};
        this.up = (this.messagePattern.up || up);
        this.setMessage(message);
        messageHandler.active = true;
        messageHandler.nameToShow = name;

        this.startup = true;
        this.onEnd = function() {};
    },
    cureMessage : function(message)
    {
        message = message.replace("/username", player.username);
        return message;
    },
    setMessage : function(message)
    {
        var input = this.messagePattern;
        if(input[message] !== undefined)
        {
            this.message = message;
            if(input[message].messages !== undefined)
            {
                if(!input[message].cured)
                {
                    for(var i = 0; i < input[message].messages.length; i++)
                    {
                        input[message].messages[i].message = this.cureMessage(input[message].messages[i].message);
                    }

                    input[message].cured = true;
                }
                
                messageHandler.newMessage(message, undefined, input[message].messages, input[message].font, this.messagePattern[this.message].up || this.up);
            }
            else if(input[message].message !== undefined)
            {
                if(!input[message].cured)
                {
                    input[message].message = this.cureMessage(input[message].message);
                    input[message].cured = true;
                }

                messageHandler.newMessage(message, input[message].message, undefined, input[message].font, this.messagePattern[this.message].up || this.up);
            }
            messageHandler.choices = {};
            messageHandler.pickedChoice = false;
            if(input[message].choices === undefined)
            {
                input[message].choices = {
                    "" : "Exit",
                };
            }
            for(var i in input[message].choices)
            {
                if(typeof input[message].choices[i] === "object")
                {
                    messageHandler.addChoice(i, undefined, input[message].choices[i]);
                }else{
                    messageHandler.addChoice(i, undefined, {
                        message : input[message].choices[i],
                    });
                }
            }
        }
    },
    mouseReleased : function(pass)
    {
        if(!messageHandler.active)
        {
            return;
        }

        if(messageHandler.pickedChoice)
        {
            this.clear();

            if(messageHandler.choice === "" || 
            typeof messageHandler.choice !== "string" || 
            this.messagePattern[messageHandler.choice] === undefined || 
            this.messagePattern[messageHandler.choice].setOver)
            {
                this.end();
            }else{
                this.setMessage(messageHandler.choice);
            } 
            messageHandler.choice = undefined;
        }

        if(pass)
        {
            return;
        }

        messageHandler.mouseReleased();
    },
    keyPressed : function()
    {
        if(!messageHandler.active)
        {
            return;
        }

        messageHandler.keyPressed();

        if((keyCode !== 32 && keyCode !== UP && keyCode !== DOWN) || this.startup)
        {
            keys[keyCode] = false;
        }
        if((key.toString() !== 'w' && key.toString() !== 's') || this.startup)
        {
            keys[key.toString() || ""] = false;
        }

        this.startup = false;
    },
    keyReleased : function()
    {
        if(!messageHandler.active)
        {
            return;
        }

        messageHandler.keyReleased();

        this.mouseReleased(true);

        keys = [];
        ENTER_KEY = false;
    },
    clear : function()
    {
        messageHandler.pickedChoice = false;
        choiceButtons = [];
        messageBoxes = [];
        messageHandler.choices = [];
    },
    onEnd : function()
    {
        // Set onEnd and do stuff here
    },
    end : function()
    {
        this.clear();
        messageHandler.active = false;

        this.onEnd();
        keys[keyCode] = false;
        keys[key.toString() || ""] = false;
        ENTER_KEY = false;
    },
};

////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
/***************************************************************Graphics*******************************************************************/
////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

var trees = {
    work : {},
    genLine : function(inputArray, col, row, col2, row2, ch, interval)
    {
        var array = inputArray;
        array[col][row] = ch;
        array[col2][row2] = ch;
        var workCol = col;
        var workRow = row;
      
        var pullX = 0;
        var pullY = 0;
        var pol = '';
        var pick = '';
      
        var interval = max(interval || 5, 3);
        
        var i = 0;
        //This loop might take a while
        while(i < 100)
        {
            i++;
            var xDiff = abs(workCol - col2);
            var yDiff = abs(workRow - row2);
            
            if(i % interval >= interval - 1)
            {
                pick = (xDiff > yDiff) ? 'x' : 'y';
            }
            
            if(pullX >= max(interval - 2, 1))
            {
                pullX = 0;  
                pick = 'y';
                continue;
            }
            if(pullY >= max(interval - 2, 1))
            {
                pullY = 0;
                pick = 'x';
                continue;
            }
            
            if(pick === 'x')
            {
                if(col2 > workCol)
                {
                    workCol++;
                }
                else if(col2 < workCol)
                {
                    workCol--;
                }
                if(pol === '' || pol === 'x')
                {
                    pullX++;
                }
                pol = 'x';
            }
            else if(pick === 'y')
            {
                if(row2 > workRow)
                {
                    workRow++;
                }
                else if(row2 < workRow)
                {
                    workRow--;
                }
                if(pol === '' || pol === 'y')
                {
                    pullY++;
                }
                pol = 'y';
            }
            array[workCol][workRow] = ch;
            if(workCol === col2 && workRow === row2)
            {
                break;    
            }
        }
    },
    genBranches : function(startingPoints, endingPoints)
    {
        for(var i = 0; i < min(startingPoints.length, endingPoints.length); i++)
        {
            this.genLine(this.treesArray, startingPoints[i][0], startingPoints[i][1], 
            endingPoints[i][0], endingPoints[i][1], 'b', 5);    
        }
    },
    genStartingPoints : function(startingPoints, branchAmt, range, rootLine)
    {
        for(var i = 0; i < branchAmt; i++)
        {
            startingPoints.push([round(random(range[0], range[1])), rootLine]);  
        }
    },
    genEndingPoints : function(endingPoints, branchAmt, endRangeX, endRangeY)
    {
        for(var i = 0; i < branchAmt; i++)
        {
            endingPoints.push([round(random(endRangeX[0], endRangeX[1])), 
                              Math.round(random(endRangeY[0], endRangeY[1]))]);
        }
    },
    render : function(inputArray)
    {
        for(var col = 0; col < inputArray.length; col++)
        {
            for(var row = 0; row < inputArray[col].length; row++)
            {
                var unitWidth = this.work.unitWidth;
                var unitHeight = this.work.unitHeight;
                var xPos = col * unitWidth;
                var yPos = row * unitHeight;

                this.work.img.noStroke();
                switch(inputArray[col][row])
                {
                    case 'b' :
                        if(random(0, 100) > 20)
                        {
                            this.work.img.fill(133, 79, 8);
                        }else{
                            this.work.img.fill(191, 100,100);
                        }
                        this.work.img.fastRect(xPos, yPos, unitWidth, unitHeight);
                        break;
                        
                    case 'B' :
                        this.work.img.fill(191, 157, 103);
                        this.work.img.fastRect(xPos, yPos, unitWidth, unitHeight);
                        break;
                        
                    case 'l' :
                        this.work.img.fill(0, 200, 0);
                        this.work.img.rect(xPos - unitWidth, yPos - unitHeight,
                        unitWidth * random(3, 7), unitHeight * random(3, 7));
                        break;
                        
                    case 'L' :
                        this.work.img.fill(0, 150, 120);
                        this.work.img.rect(xPos - unitWidth, yPos - unitHeight, unitWidth * random(3, 7), unitHeight * random(3, 7));
                        break;
                        
                    case 'x' :
                        this.work.img.fill(23, 189, 131);
                        this.work.img.fastRect(xPos, yPos, unitWidth, unitHeight);
                        break;
                        
                    case 'X' :
                        this.work.img.fill(75, 151, 209);
                        this.work.img.fastRect(xPos, yPos, unitWidth, unitHeight);
                        break;    
                }
            }
        }
    },
    createArray : function(width, height, unitWidth, unitHeight)
    {
        var array = [];
        var maxI = (floor(width * 10 / unitWidth) + 7) / 10;
        for(var i = 0; i < maxI; i++)
        {
            array.push([]);
            for(var j = 0; j < floor(height / unitHeight); j++)
            {
                array[i].push("");
            }
        }
        
        this.treesArray = array;
    },
    leaf : [
        " xxxxx ",
        "xxXXXxx",
        "xxXXXxx",
        "xxXXXxx",
        " xxxxx ",
    ],
    createTrunk : function(thickness, rootLine, midX, halfThickness, end0, rootConnections)
    {   
        var fail = false;
        for(var j = 0; j < thickness; j++)
        {
            for(var i = rootLine; i < this.treesArray[0].length; i++)
            {
                var x = midX + j - halfThickness;
                var y = i;
                
                if(this.treesArray[x] === undefined)
                {
                    if(!fail)
                    {
                        println("Failure to create roots, check your width.");
                    }
                    fail = true;
                    continue;
                }
               
                if(random(0, 100) <= 70)
                {
                    this.treesArray[x][y] = 'B';
                }else{
                    this.treesArray[x][y] = 'b';
                }
                
                if(i > end0 * 0.8)
                {
                    if(random(0, 100) > 90 || rootConnections.length <= 2)
                    {
                        rootConnections.push([x, y]);
                    }
                }
            }
        }
    },
    createTree : function(width, height, unitWidth, unitHeight)
    {
        this.work.img = createGraphics(width, height, P2D);
        this.work.img.beginDraw();
        
        //Clear the pixels
        this.work.img.noStroke();
        this.work.img.background(0, 0, 0, 0);
        
        //setup our work
        this.work.width = width;
        this.work.height = height;
        this.work.unitWidth = unitWidth;
        this.work.unitHeight = unitHeight;
        this.createArray(width, height, unitWidth, unitHeight);
        
        var end0 = (this.treesArray[0].length - 1);
        var rootLine = Math.round(random(end0 * 0.7, end0 * 0.90));
        var midX = ((this.treesArray.length - 1) / 2);
        
        var thickness = min((this.treesArray.length - 1), Math.round(random(1, 4)));
        
        var rootConnections = [];
        var halfThickness = floor(thickness / 2);
        
        //create trunk
        this.createTrunk(thickness, rootLine, midX, halfThickness, end0, rootConnections);
        
        //create roots
        for(var i = 0; i < rootConnections.length; i++)
        {
            this.genLine(this.treesArray, rootConnections[i][0], rootConnections[i][1], 
            Math.round(random(0, this.treesArray.length - 1)), end0, 'b', 5);
        }
        
        var range = [midX - halfThickness, midX + halfThickness];
        var startingPoints = [];
        var branchAmt = Math.round(random(3, 8));
        
        //min, max
        var end = (this.treesArray.length - 1);
        var endRangeX = [round(random(end * 0.2, end * 0.4)),
                         Math.round(random(end * 0.6, end * 0.9))];
        var endRangeY = [round(random(rootLine, rootLine + 2)), 
                         Math.round(random(end0 * 0.0, end0 * 0.4))];
        endRangeY[0] = constrain(endRangeY[0], 0, end0);
        
        var endingPoints = [];
        
        this.genStartingPoints(startingPoints, branchAmt, range, rootLine);
        this.genEndingPoints(endingPoints, branchAmt, endRangeX, endRangeY);
        
        //create branches
        this.genBranches(startingPoints, endingPoints);
        
        for(var i = 0; i < endingPoints.length; i++)
        {
            var col = endingPoints[i][0];
            var row = endingPoints[i][1];
            
            //Prevent thing
            if(row > end0 * 0.7)
            {
                continue;    
            }
            
            if(random(0, 100) < 40)
            {
                for(var j = 0; j < this.leaf.length; j++)
                {
                    for(var k = 0; k < this.leaf[j].length; k++)
                    {
                        if(col + j < this.treesArray.length && row + k < end0 + 1)
                        {
                            this.treesArray[col + j][row + k] = this.leaf[j][k]; 
                        }
                    }
                }
            }else{
                if(random(0, 100) < 20)
                {
                    this.treesArray[col][row] = 'L'; 
                }else{
                    this.treesArray[col][row] = 'l';
                }
            }
        }
        
        //Render the tree and finish
        this.render(this.treesArray);
        this.work.img.beginDraw();
        return this.work.img;
    },
};

var graphics = {};
graphics.Fade = function(colorValue)
{
    this.colorValue = colorValue;

    this.timer = 0;
    this.timerVel = 0.7;
    this.max = 100;
    this.fading = false;
    
    this.start = function(max, start)
    {
        this.max = max || this.max;
        this.timer = start || this.timer;
        this.fading = true; 
    };
    this.full = function()
    {
        return(this.timer >= this.max);
    };
    this.draw = function()
    {
        if(this.fading)
        {               
            if(!this.stopped)
            {
                if(this.timer < 0 || this.timer >= this.max)
                {
                    this.timerVel = -this.timerVel;
                }
                if(this.timer < 0)
                {
                    this.fading = false;
                }
                this.timer += this.timerVel;
            }
            noStroke();
            fill(red(this.colorValue), green(this.colorValue), blue(this.colorValue), this.timer * 255 / this.max);
            fastRect(0, 0, width, height);
        }
    };
};

graphics.inClouds = [];
graphics.inClouds.getSpeed = function()
{
    var speed = 0;
    var dir = Math.round(random(-1, 1));
    if(dir === -1)
    {
        speed = -random(0.25, 0.5)/1.5;
    }
    else if(dir === 1)
    {
        speed = random(0.25, 0.5)/1.5;
    }
    else if(dir === 0)
    {
        speed = 0;
    }
    return speed;
};
graphics.inClouds.create = function(amt)
{
    this.length = 0;
    var n = 0;
    while(n < amt)
    {
        var x = Math.round(random(0, width));
        var y = Math.round(random(130, 250));
        var speed = this.getSpeed();
        for(var i = 0; i < Math.round(random(1, 3)); i++)
        {
            var w = Math.round(random(30, 70));
            var h = Math.round(random(10, 25));
            var offX = (w / Math.round(random(2, 4))) * ((random(0, 100) > 50) ? 1 : -1);
            var offY = (h / Math.round(random(2, 4))) * ((random(0, 100) > 50) ? 1 : -1);
            this.push([x + offX, y + offY, w, h, {
                speed : speed,
                type : ((random(0, 100) <= 70) ? "rect" : "ellipse"),
            }]);
            n++;
        }
    }
};
graphics.inClouds.update = function() 
{
    for(var i = 0; i < this.length; i++)
    {
        this[i][0] += this[i][4].speed;
    }
};
graphics.inClouds.draw = function() 
{
    for(var i = 0; i < this.length; i++)
    {
        fill(255, 255, 255, 70);
        if(this[i][4].type === "rect")
        {
            $pjs.rect(this[i][0], this[i][1], this[i][2], this[i][3], 5);
            if(this[i][0] + this[i][2] < 0)
            {
                this[i][0] = width;
            }
            if(this[i][0] > width)
            {
                this[i][0] = -this[i][2];
            }
        }
        else if(this[i][4].type === "ellipse")
        {
            ellipse(this[i][0], this[i][1], this[i][2], this[i][3]);
            
            var radius = this[i][2] / 2;
            if(this[i][0] + radius < 0)
            {
                this[i][0] = width + radius;
            }
            if(this[i][0] - radius > width)
            {
                this[i][0] = -radius;
            }
        }
    }
};
graphics.stars = [];
graphics.stars.create = function(amt)
{
    for(var i = 0; i < amt; i++)
    {
        this.push([random(0, width), random(0, 115)]);
    }
};
graphics.stars.draw = function() 
{
    for(var i = 0; i < this.length; i++)
    {
        fill(200, 200, 255);
        circle(this[i][0], this[i][1], 2);
    }
};

var shapes = {
    bush : function(x, y, w, h)
    {
        for(var i = 0; i < width / 3; i += 70)
        {
            $pjs.pushMatrix();
            translate(x + i, y);
            rotate(150);
            fill(35, 153, 98);
            ellipse(0, 0, w, h);
            $pjs.popMatrix();
        }
        for(var i = 0; i < width / 3; i += 70)
        {
            $pjs.pushMatrix();
            translate(x + 10 + i, y);
            rotate(150);
            fill(16, 128, 62);
            ellipse(0, 0, w - 23, h - 23);
            $pjs.popMatrix();
        }
    },
    grass : function(x, y, w, h)
    {
        fill(50, 140, 30);
        var bladeW = w * 0.1;
        fastRect(x, y + h, bladeW, -h);
        fastRect(x + bladeW, y + h, bladeW, h * -0.4);
        fastRect(x + bladeW * 2, y + h, bladeW, h * -0.7);
        fastRect(x + bladeW * 3, y + h, bladeW, h * -0.2);
        fastRect(x + bladeW * 4, y + h, bladeW, h * -0.5);
        fastRect(x + bladeW * 5, y + h, bladeW, h * -0.8);
        fastRect(x + bladeW * 6, y + h, bladeW, h * -0.4);
        fastRect(x + bladeW * 7, y + h, bladeW, h * -0.9);
        fastRect(x + bladeW * 8, y + h, bladeW, h * -0.6);
        fastRect(x + bladeW * 9, y + h, bladeW, h * -0.4);
        fastRect(x + bladeW * 10, y + h, bladeW, h * -0.7);
    },
    sun : function(x, y)
    {
        fill(210, 210, 35);
        $pjs.rect(x, y, 50, 50, 10);
        fill(210, 200, 40);
        $pjs.rect(x + 5, y + 5, 40, 40, 10);
    },
    key : function(x, y, w, h)
    {
        var unitW = w / 3;
        var unitH = h / 6;
        var unitW2 = unitW * 2;
        var unitH2 = unitH * 2;

        noStroke();
        fill(235, 210 - 60, 70);
        fastRect(x + unitW * 2, y + 4 * unitH, 0.6 * unitW, unitH * 0.7);
        fastRect(x + unitW * 2, y + 5.3 * unitH, unitW, unitH * 0.7);
        fill(235, 210, 70);
        fastRect(x + unitW, y + unitH * 3, unitW, unitH * 3);
        fill(235, 210 - 80, 70);
        fastRect(x, y, unitW2, unitH);
        fill(235, 210 - 60, 70);
        fastRect(x + unitW2, y, unitW, unitH2);
        fill(235, 210 - 40, 70);
        fastRect(x + unitW, y + unitH2, unitW2, unitH);
        fill(235, 210 - 20, 70);
        fastRect(x, y + unitH, unitW, unitH2);
    },
};

var backgrounds = {
    background : "spaceFromEarth",
    backgrounds : {
        "dark" : {
            primeLoad : function()
            {
                background(3, 0, 123);

                strokeWeight(10);
                stroke(0, 0, 0, 160);
                fill(0, 0, 0, 100);
                for(var x = 5; x < width; x += 40)
                {
                    $pjs.rect(x, 5, 30, 30);
                    $pjs.rect(x, 375, 30, 30);

                    if(x > 30 && x < 370)
                    {
                        $pjs.rect(x, 5 + 35, 30, 30);
                        $pjs.rect(x, 375 - 35, 30, 30);
                    }
                }

                for(var y = 5 + 40; y < height - 50; y += 30)
                {
                    $pjs.rect(5, y, 30, 30);
                    $pjs.rect(365, y, 30, 30);

                    if(y > 30 && y < 370)
                    {
                        $pjs.rect(5 + 35, y, 30, 30);
                        $pjs.rect(375 - 35, y, 30, 30);
                    }
                }

                noStroke();
                for(var a = 200; a >= 0; a -= 50)
                {
                    fill(0, 30, 255 - a);
                    fastRect(200 - a / 2, 200 - a / 2, a, a);
                }

                backgrounds.backgrounds.dark.img = get(0, 0, width, height);

                // screenUtils.speedUpImage(backgrounds.backgrounds.dark.img);
                accelerateImg(backgrounds.backgrounds.dark.img);

                backgrounds.backgrounds.dark.streaks = [];

                for(var i = 0; i < random(30, 50); i++)
                {
                    backgrounds.backgrounds.dark.streaks.push({
                        xPos : random(0, width),
                        yPos : random(HALF_HEIGHT - 20, HALF_HEIGHT + 30),
                        width : random(40, 60),
                        height : 4,
                        yVel : 0,
                        xVel : random(-2, 2),
                    });
                }

                fill(255, 255, 255, 60);
                $pjs.rect(0, 0, width, height);
            },
            drawBackground : function()
            {
                if(backgrounds.backgrounds.dark.img)
                {
                    ctx.drawImage(backgrounds.backgrounds.dark.img.sourceImg, 0, 0, width, height);
                }

                var streaks = backgrounds.backgrounds.dark.streaks || [];
                for(var i = 0; i < streaks.length; i++)
                {
                    streaks[i].xPos += streaks[i].xVel;
                    streaks[i].yPos += streaks[i].yVel;

                    if(abs(streaks[i].xVel) > 0)
                    {
                        if(this.streaks[i].xPos + this.streaks[i].width < 0)
                        {
                            this.streaks[i].xPos = width;
                        }
                        else if(this.streaks[i].xPos > width)
                        {
                            this.streaks[i].xPos = -this.streaks[i].width;
                        }
                    }
                    if(abs(streaks[i].yVel) > 0)
                    {
                        if(this.streaks[i].yPos + this.streaks[i].height < 0)
                        {
                            this.streaks[i].yPos = height;
                        }
                        else if(this.streaks[i].yPos > height)
                        {
                            this.streaks[i].yPos = -this.streaks[i].height;
                        }
                    }

                    fill(0, 0, 0, 100);
                    $pjs.fastRect(streaks[i].xPos, streaks[i].yPos, streaks[i].width, streaks[i].height);
                }
            },
        },
        "underground" : {
            primeLoad : function()
            {
                var p_width = width, p_height = height;

                function Layer_1()
                {
                    background(2, 8, 30);
                    noStroke();
                    fill(0, 10, 70, 100);

                    var i = 0;
                    for(var y = 0; y < p_height; y += 30)
                    {
                        for(var x = (i % 2 === 0) ? 15 : 0; x < p_width; x += 30)
                        {
                            fastRect(x, y, 10, 10);
                        }

                        i++;
                    }

                    return get(0, 0, p_width, p_height);
                }

                function Layer_2()
                {
                    background(0, 0, 0, 0);

                    var map1 = [
                        "  cc      c c   c   ",
                        "  cc      ccc   cccc",
                        "   cc             cc",
                        "                    ",
                        "cccc                ",
                        "   cc    ccc      cc",
                        "cc  c    cc      ccc",
                        "ccc cc           c  ",
                        "  c  c        cccc  ",
                        "     cc     ccc  ccc",
                        "      ccc   c     cc",
                        "    c   c   c       ",
                        "   cc   c  cc       ",
                        "   cc   cccc        ",
                        "         c    ccc   ",
                        "         c     cc   ",
                        "         c          ",
                        "cc      cc          ",
                        "cccc    c   ccc   cc",
                        "   c    c   c c   cc",
                    ];

                    map1.unitWidth = 20;
                    map1.unitHeight = 20;

                    noStroke();
                    for(var i = 0; i < map1.length; i++)
                    {
                        for(var j = 0; j < map1[i].length; j++)
                        {
                            var xPos = j * map1.unitWidth,
                                yPos = i * map1.unitHeight;

                            switch(map1[i][j])
                            {
                                case "c" :
                                    fill(0, 0, 0, 30+50);
                                    fastRect(xPos, yPos, map1.unitWidth, map1.unitHeight);

                                    fill(0, 0, 0, 70+50);
                                    fastRect(xPos + 4, yPos + 4, map1.unitWidth - 8, map1.unitHeight - 8);

                                    if(j > 0 && map1[i][j - 1] === 'c')
                                    {
                                        fastRect(xPos, yPos + 4, 4, map1.unitHeight - 8);  
                                    }
                                    if(j < map1[i].length - 1 && map1[i][j + 1] === 'c')
                                    {
                                        fastRect(xPos + map1.unitWidth - 4, yPos + 4, 4, map1.unitHeight - 8);  
                                    }
                                    if(i > 0 && map1[i - 1][j] === 'c')
                                    {
                                        fastRect(xPos + 4, yPos, map1.unitWidth - 8, 4);  
                                    }
                                    if(i < map1.length - 1 && map1[i + 1][j] === 'c')
                                    {
                                        fastRect(xPos + 4, yPos + map1.unitHeight - 4, map1.unitWidth - 8, 4);  
                                    }
                                    break;
                            }
                        }
                    }

                    return get(0, 0, p_width, p_height);
                }

                function Layer_3()
                {
                    background(0, 0, 0, 0);
                    
                    var map1 = [
                        "    c        c  c   ",
                        " c  c c     cc cc   ",
                        " cccccc      ccc    ",                        
                        "    c cc   ccc cc   ",                       
                        "   cc      c   c    ", 
                        "   c                ",
                        "                    ", 
                        "                    ", 
                        "                    ", 
                        "                    ", 
                        "                    ", 
                        "                    ", 
                        "              c  c  ",  
                        "   cc  c     ccccc  ", 
                        "    c  c      c     ", 
                        "c c cccccc    cc    ", 
                        "ccc  c         c    ", 
                        "  cccc         ccc  ",  
                        "  c              c  ",  
                        "  c              c  ", 
                    ];

                    map1.unitWidth = 20;
                    map1.unitHeight = 20;

                    noStroke();
                    for(var i = 0; i < map1.length; i++)
                    {
                        for(var j = 0; j < map1[i].length; j++)
                        {
                            var xPos = j * map1.unitWidth,
                                yPos = i * map1.unitHeight;

                            switch(map1[i][j])
                            {
                                case "c" :
                                    fill(0, 80, 50, 28+10);
                                    fastRect(xPos, yPos, map1.unitWidth, map1.unitHeight);

                                    fill(0, 120, 40, 46+10);
                                    fastRect(xPos + 4, yPos + 4, map1.unitWidth - 8, map1.unitHeight - 8);

                                    if(j > 0 && map1[i][j - 1] === 'c')
                                    {
                                        fastRect(xPos, yPos + 4, 4, map1.unitHeight - 8);  
                                    }
                                    if(j < map1[i].length - 1 && map1[i][j + 1] === 'c')
                                    {
                                        fastRect(xPos + map1.unitWidth - 4, yPos + 4, 4, map1.unitHeight - 8);  
                                    }
                                    if(i > 0 && map1[i - 1][j] === 'c')
                                    {
                                        fastRect(xPos + 4, yPos, map1.unitWidth - 8, 4);  
                                    }
                                    if(i < map1.length - 1 && map1[i + 1][j] === 'c')
                                    {
                                        fastRect(xPos + 4, yPos + map1.unitHeight - 4, map1.unitWidth - 8, 4);  
                                    }
                                    break;
                            }
                        }
                    }

                    return get(0, 0, p_width, p_height);
                }

                function Layer_4()
                {
                    background(0, 0, 0, 0);
                    
                    // fill(6, 20, 60);
                    fill(45, 45, 45);

                    var extra = 0;
                    var start = 360 - 40;
                    var end = 313 - 40;

                    $pjs.pushMatrix();
                        translate(0, 10);
                        beginShape();
                            curveVertex(p_width + extra, 400);
                            curveVertex(-extra, 400);
                            for(var x = -25 - extra; x < p_width + extra; x += 70)
                            {
                                curveVertex(20 + x - 35, start + sin(x % 35) * 26);
                                curveVertex(20 + x, end + cos(x % 70) * 23);
                            }
                            curveVertex(p_width + extra, 400);
                            curveVertex(-extra, 400);
                        endShape();
                    $pjs.popMatrix();

                    var start = 40 + 20;
                    var end = 0 + 20;

                    $pjs.pushMatrix();
                        translate(0, -10);
                        beginShape();
                            curveVertex(p_width + extra, 0);
                            curveVertex(-extra, 0);
                            for(var x = 15 - extra; x < p_width + extra; x += 60)
                            {
                                curveVertex(20 + x - 30, start + sin(x % 35) * 23);
                                curveVertex(20 + x, end + cos(x % 70) * 23);
                            }
                            curveVertex(p_width + extra, 0);
                            curveVertex(-extra, 0);
                        endShape();
                    $pjs.popMatrix();

                    return get(-extra, 0, p_width + extra * 2, p_height);
                }

                function Layer_5()
                {
                    background(0, 0, 0, 0);
                    
                    fill(6, 30, 78);

                    var extra = 0;
                    var start = 360 - 20;
                    var end = 310 - 20;

                    beginShape();
                        curveVertex(p_width + extra, 400);
                        curveVertex(-extra, 400);
                        for(var x = -25 - extra; x < p_width + extra; x += 70)
                        {
                            curveVertex(20 + x - 45, start + sin(x % 180) * 26);
                            curveVertex(20 + x, end + cos(x % 70) * 23);
                        }
                        curveVertex(p_width + extra, 400);
                        curveVertex(-extra, 400);
                    endShape();

                    var start = 40 + 20;
                    var end = 0 + 20;

                    beginShape();
                        curveVertex(p_width + extra, 0);
                        curveVertex(-extra, 0);
                        for(var x = 15 - extra; x < p_width + extra; x += 60)
                        {
                            curveVertex(20 + x - 30, start + sin(x % 180) * 23);
                            curveVertex(20 + x, end + cos(x % 70) * 23);
                        }
                        curveVertex(p_width + extra, 0);
                        curveVertex(-extra, 0);
                    endShape();

                    return get(-extra, 0, p_width + extra * 2, p_height);
                }

                function Layer_6()
                {
                    background(0, 0, 0, 0);

                    var k = 0;
                    for(var i = 0; i < p_width; i += 18)
                    {
                        k++;

                        $pjs.pushMatrix();
                            translate(i, p_height - random(7, 19) * 3);
                            fill(34, 165, 80, 100);
                            $pjs.rect(0, 0, 18, 90, 10);
                        $pjs.popMatrix();
                    }

                    var k = 0;
                    for(var i = 0; i < p_width; i += 18)
                    {
                        k++;

                        $pjs.pushMatrix();
                            translate(i, -30);
                            fill(34, 165, 80, 100);
                            $pjs.rect(0, 0, 18, random(7, 19) * 2 + 30, 10);
                        $pjs.popMatrix();
                    }
                    
                    return get(0, 0, p_width, p_height);
                }

                this.layers = [Layer_1(), Layer_2(), Layer_3(), Layer_4(), Layer_5(), Layer_6()];
                for(var i = 0; i < this.layers.length; i++)
                {
                    screenUtils.speedUpImage(this.layers[i]);
                }

                this.speeds = [];
                this.diff = levelInfo.width - cam.focusXPos * 10 || 0;
            },
            drawBackground : function()
            {
                this.diff = (levelInfo.width - cam.focusXPos * 10 || 0);
                this.speeds = [this.diff / 68, this.diff / 56, this.diff / 52, this.diff / 42, this.diff / 30, this.diff / 20];

                var i, layer, index;
                for(i = 0; i < this.layers.length; i++)
                {
                    layer = this.layers[i];
                    index = -floor((this.speeds[i] + width) / layer.width);

                    ctx.drawImage(layer.sourceImg, layer.width * (index + 1) + this.speeds[i], 0, width, height);
                    ctx.drawImage(layer.sourceImg, layer.width * index + this.speeds[i], 0, width, height);
                }
            },
            moves : true
        },
        "winter" : {
            primeLoad : function()
            {
                $pjs.pushMatrix();
                scale(screen.width / 400, screen.height / 400);

                noStroke();
                var backColor = color(147 - 30, 221 - 30, 250 - 30);
                background(backColor);

                //Atmosphere
                fill(red(backColor) - 130, green(backColor) - 130, blue(backColor) - 130);
                ellipse(160, 300, 850, 850);
                fill(red(backColor) - 80, green(backColor) - 80, blue(backColor) - 80);
                ellipse(160, 300, 535, 535);
                fill(red(backColor) - 30, green(backColor) - 30, blue(backColor) - 30);
                ellipse(160, 300, 430, 430);
                fill(red(backColor) - 10, green(backColor) - 10, blue(backColor) - 10);
                ellipse(160, 300, 350, 350);

                var starAmt = Math.round(random(60, 80));

                var stars = 0;

                fill(200, 200, 255);

                var j = 0;
                while(stars < starAmt)
                {
                    var x = Math.round(random(5, 395)),
                        y = Math.round(random(2, 225));

                    if(Math.pow(abs(160 - x), 2) + Math.pow(abs(300 - y), 2) > Math.pow(230, 2))
                    {
                        ellipse(x, y, 2, 2);

                        stars++;
                    }   

                    j++;

                    //protection
                    if(j > 1000)
                    {
                        break;
                    }
                }

                //Moon
                $pjs.pushMatrix();
                beginShape();
                    translate(270, -20);
                    scale(0.34, 0.34);
                    vertex(274, 166);
                    bezierVertex(283, 154, 213, 122, 192, 171);
                    bezierVertex(179, 228, 264, 258, 286, 200);
                    bezierVertex(254, 239, 228, 207, 226, 183);
                    bezierVertex(242, 145, 269, 170, 279, 169);
                endShape();
                $pjs.popMatrix();

                function mountain(x, y, sx, sy, cap)
                {
                    $pjs.pushMatrix();
                        translate(x || 0, y || 0);
                        scale(sx || 1, sy || 1);

                        fill(20, 144, 200);
                        triangle(70, 240, -10, 380, 150, 380);
                        fill(20, 164, 200, 140);
                        triangle(70, 260, 9, 380, 140, 380);

                        if(cap)
                        {
                            fill(255, 255, 255, 200);
                            triangle(70, 240, 55, 264, 84, 264);
                        }
                    $pjs.popMatrix();
                }   

                $pjs.pushMatrix();
                    //Adjustments
                    scale(1, 1.08);
                    translate(0, -30);

                    mountain(50, -20);
                    mountain();
                    mountain(90, 10);

                    fill(20, 134, 190);
                    beginShape();
                        vertex(0, 400);
                        vertex(0, 330);
                        
                        for(var i = 0; i < 400; i += 50)
                        {
                            vertex(i + 25, 300);
                            vertex(i + 50, 330);
                        }  

                        vertex(400, 330);
                        vertex(400, 400);
                    endShape();

                    fill(0, 146, 194);
                    beginShape();
                        vertex(0, 400);
                        vertex(0, 330);
                        
                        for(var i = 0; i < 400; i += 80)
                        {
                            vertex(i + 35, 300);
                            vertex(i + 60, 330);
                        }    
                        
                        vertex(400, 330);
                        vertex(400, 400);
                    endShape();

                    fill(10, 125, 167);
                    beginShape();
                        vertex(0, 400);
                        vertex(0, 330+10);
                        
                        for(var i = 0; i < 400; i += 80)
                        {
                            vertex(i + 35, 320);
                            vertex(i + 60, 350);
                        }    
                        
                        vertex(400, 330+10);
                        vertex(400, 400);
                    endShape();

                    quad(0, 350, 400, 350, 400, 380, 0, 380);

                    //Hills
                    fill(20, 114, 150);
                    ellipse(50, 400, 120, 80);
                    ellipse(170, 400, 160, 80);
                    ellipse(280, 400, 140, 80);
                    ellipse(400, 400, 170, 80);

                    fill(20, 134, 150);
                    ellipse(60, 410, 120, 80);
                    ellipse(180, 410, 160, 80);
                    ellipse(290, 410, 140, 80);
                    ellipse(410, 410, 170, 80);

                    //Shading
                    fill(112, 64, 31, 20);
                    $pjs.rect(0, 387, 400, 14, 100);
                $pjs.popMatrix();

                backgrounds.backgrounds.winter.img = get(0, 0, screen.width, screen.height);
                // screenUtils.speedUpImage(backgrounds.backgrounds.winter.img);
                accelerateImg(backgrounds.backgrounds.winter.img);
                $pjs.popMatrix();
            },
            load : function()
            {
                graphics.inClouds.create(round(random(10, 20)));
            },
            drawBackground : function()
            {
                if(backgrounds.backgrounds.winter.img !== undefined)
                {
                    ctx.drawImage(backgrounds.backgrounds.winter.img.sourceImg, 0, 0, width, height);

                    graphics.inClouds.draw();
                    if(!screenUtils.fade.fading)
                    {
                        graphics.inClouds.update();
                    }
                }
            },
        },
        "spaceFromEarth" : {
            primeLoad : function()
            {
                graphics.stars.create(round(random(54, 80)) + 3);
                background(255, 255, 255);

                $pjs.pushMatrix();
                    scale(screen.width / 400, screen.height / 400);
                    noStroke();
                    var backColor = color(147 - 30, 221 - 30, 250 - 30);
                    fill(red(backColor), green(backColor), blue(backColor));
                    fastRect(0, 0, screen.width, screen.height);

                    backgrounds.backgrounds.spaceFromEarth.drawBackground();
                    var spaceFromEarth = get(0, 0, screen.width, screen.height);//400, 400

                    // screenUtils.speedUpImage(spaceFromEarth);
                    accelerateImg(spaceFromEarth);
                $pjs.popMatrix();
                backgrounds.backgrounds.spaceFromEarth.drawBackground = function()
                {
                    ctx.drawImage(spaceFromEarth.sourceImg, 0, 0, width, height);
                    graphics.inClouds.draw();
                    if(!screenUtils.fade.fading)
                    {
                        graphics.inClouds.update();
                    }
                };
            },
            load : function()
            {
                graphics.inClouds.create(round(random(4, 13)));
            },
            drawBackground : function()
            {
                var backColor = color(147 - 30, 221 - 30, 250 - 30);
                background(red(backColor), green(backColor), blue(backColor));
                noStroke();
                
                //Atmosphere
                fill(red(backColor) - 10, green(backColor) - 10, blue(backColor) - 10);
                fastRect(0, 155, 400, 10);
                fill(red(backColor) - 30, green(backColor) - 30, blue(backColor) - 30);
                fastRect(0, 130, 400, 25);
                fill(red(backColor) - 80, green(backColor) - 80, blue(backColor) - 80);
                fastRect(0, 90, 400, 40);
                fill(red(backColor) - 130, green(backColor) - 130, blue(backColor) - 130);
                $pjs.rect(0, 0, 400, 90, 0);
                graphics.stars.draw();
                
                //Moon
                fill(220, 222, 124);
                $pjs.pushMatrix();
                scale(0.3, 0.3);
                translate(-17, -63);
                beginShape();
                vertex(274, 166);
                bezierVertex(283, 154, 213, 122, 192, 171);
                bezierVertex(179, 228, 264, 258, 286, 200);
                bezierVertex(254, 239, 228, 207, 226, 183);
                bezierVertex(242, 145, 269, 170, 279, 169);
                endShape();
                $pjs.popMatrix();
                
                //Mountains
                fill(13, 93, 204);
                triangle(343, 308, 213, 421, 299, 239);
                fill(13, 133, 130);
                triangle(317, 308, 200, 421, 266, 256);
                triangle(369, 308, 204, 421, 342, 255);
                
                fill(255, 255, 255, 200);
                triangle(266, 256, 262, 267, 273, 263);
                triangle(342, 255, 348, 266, 332, 266);
                triangle(299, 239, 293, 251, 308, 252);
                
                //Hills
                fill(28, 122, 52);
                ellipse(258, 317, 158, 66);
                fill(30, 130, 50);
                ellipse(71, 298, 153, 60);
                ellipse(15, 338, 114, 58);
                ellipse(371, 332, 146, 70);
                
                //observetory
                var ox = 129;
                var oy = 291;
                fill(130, 130, 130);
                $pjs.pushMatrix();
                translate(ox, oy);
                scale(1.2, 1.2);
                rotate(208);
                fill(23, 71, 161);
                fastRect(-2.5, 5, 5, 28);
                fill(24, 92, 161);
                fastRect(-4.5, 16, 10, 10);
                $pjs.popMatrix();
                
                //Hills and grass
                fill(23, 71, 161);
                ellipse(ox, oy, 50, 45);
                fill(24, 92, 161);
                ellipse(ox, oy, 33, 33);
                
                shapes.bush(60, 335, 149, 70);
                shapes.bush(270, 344, 122, 70);
                fill(117, 82, 57);
                ellipse(200, 360, 155, 83);
                
                fill(41, 171, 115);
                ellipse(77, 353, 162, 67);
                ellipse(319, 357, 168, 63);
                
                shapes.grass(35, 320, 20, 31);
                shapes.grass(79, 307, 20, 45);
                shapes.grass(121, 333, 20, 17);
                
                shapes.grass(331, 315, 20, 38);
                shapes.grass(289, 333, 20, 17);
                
                //Ground
                fill(56, 158, 25);
                $pjs.rect(0, 350, 400, 100, 10);
                
                fill(76, 184, 33);
                for(var x = 0; x < width; x += 40)
                {
                    $pjs.rect(x, 350, 20, 100, 15);
                }
                
                fill(0, 0, 0, 60);
                for(var x = 0; x < width; x += 70)
                {
                    $pjs.rect(x, 375, 70, 100, 10);
                }
            },
        },
        "high" : {
            primeLoad : function()
            {
                var p = new Processing(canvas, function(pjs)
                {
                    with(pjs)
                    {
                        function mountain(x, y, sx, sy, cap)
                        {
                            $pjs.pushMatrix();
                                translate(x || 0, y || 0);
                                scale(sx || 1, sy || 1);

                                fill(20, 144, 200);
                                triangle(70, 240, -10, 380, 150, 380);
                                fill(20, 164, 200, 140);
                                triangle(70, 260, 9, 380, 140, 380);

                                if(cap)
                                {
                                    fill(255, 255, 255, 170);
                                    triangle(70, 240, 55, 264, 84, 264);
                                }
                            $pjs.popMatrix();
                        }   

                        var high = backgrounds.backgrounds.high;
                        high.clouds = [];
                        high.clouds.add = function(x, y, width, height, round)
                        {
                            this.push({
                                x : x,
                                y : y,
                                width : width,
                                height : height,
                                round : round,
                                xVel : ((Math.random() > 0.5) ? -1 : 1) * random(0.1, 0.4)
                            });

                            if(Math.random() < 0.3)
                            {
                                this[this.length - 1].xVel = 0;
                            }
                        };

                        high.snow = [];
                        high.snow.add = function(x, y)
                        {
                            this.push({
                                x : x,
                                y : y,
                                yVel : random(0.4, 1),
                                gravity : random(0.02, 0.04),
                                maxYVel : random(1.5, 2.4),
                                xVel : random(-1, 1) / 2,
                            });
                        };

                        size(600, 600);

                        var pixels;
                        draw = function()
                        {
                            background(29, 146, 190);

                            this.loadPixels();

                            pixels = this.imageData.data;

                            for(var y = 0; y < 500; y++)
                            {
                                for(var x = 0; x < 600; x++)
                                {
                                    var i = (x + this.imageData.width * (y - 10)) * 4;

                                    pixels[i] = 24;
                                    pixels[i + 1] = (260 - y * 0.5);
                                    pixels[i + 2] = ((365 + y - ((x + y) % 14 <= 4 ? 80 : -20)) * 260 / 600) + 120 - y * 0.4;
                                }
                            }

                            this.updatePixels();
                            noStroke();
                        
                            $pjs.pushMatrix();
                                translate(0, -5);

                                //Adjustments
                                scale(1, 1.08);
                                translate(0, -70);
                                mountain(0, 0, 1.3, 1.33, true);

                                translate(-70, -65);
                                mountain(200 - 33, 80, 1.2, 1.4, true);
                                mountain(512, 96, 1.24, 1.3, true);
                                mountain(400, -15, 1.5, 1.6, true);
                                
                                $pjs.pushMatrix();
                                    fill(20, 164, 200);
                                    ellipse(190, 600, 300, 100);  

                                    for(var i = 0; i < 7; i++)
                                    {
                                        ellipse(260 + i * 200, 600 + ((i % 2 === 0) ? 6 : 0), 300, 100);
                                    }   

                                    translate(-60, 70);
                                    for(var i = 0; i < 7; i++)
                                    {
                                        ellipse(190 + i * 200, 600 + ((i % 2 === 0) ? 6 : 0), 300, 100);
                                    }   
                                $pjs.popMatrix();

                                translate(0, 20);
                                fill(6, 177, 234);
                                ellipse(190, 600, 300, 100);  

                                for(var i = 0; i < 7; i++)
                                {
                                    ellipse(260 + i * 200, 600 + ((i % 2 === 0) ? 6 : 0), 300, 100);
                                }   

                                translate(-60, 70);
                                for(var i = 0; i < 7; i++)
                                {
                                    ellipse(190 + i * 200, 600 + ((i % 2 === 0) ? 6 : 0), 300, 100);
                                }

                                
                            $pjs.popMatrix();

                            $pjs.pushMatrix()
                                translate(0, 10);
                                scale(6/4, 6/4);
                                fill(10, 187+12, 240);
                                beginShape();
                                    vertex(0, 400);
                                    vertex(0, 330+10);
                                    
                                    for(var i = 0; i < 400; i += 80)
                                    {
                                        vertex(i + 35, 320);
                                        vertex(i + 60, 350);
                                    }    
                                    
                                    vertex(400, 330+10);
                                    vertex(400, 400);
                                endShape();
                            $pjs.popMatrix();

                            $pjs.pushMatrix();
                                scale(1, 1.08);
                                translate(0, 200);
                                fill(0, 146, 194, 160);
                                beginShape();
                                    vertex(0, 600);
                                    vertex(0, 330);
                                    
                                    for(var i = 0; i < 600; i += 50)
                                    {
                                        vertex(i + 25, 300);
                                        vertex(i + 50, 330);
                                    }  

                                    vertex(600, 330);
                                    vertex(600, 400);
                                endShape();
                            $pjs.popMatrix();

                            noStroke();
                            noLoop();
                        };

                        draw();
                        backgrounds.backgrounds.high.img = get(0, 0, 600, 600);
                        screenUtils.speedUpImage(backgrounds.backgrounds.high.img);

                        this.draw = undefined;
                        noLoop();
                    }
                });

                p = undefined;
            },
            load : function()
            {
                this.clouds.length = 0;
                for(var i = 0; i < 16; i++)
                {
                    this.clouds.add(random(0, 400), random(160, 240) - 40, random(30, 70) * (4/6), random(10, 20) * (4/6), 7);
                }

                this.snow.length = 0;

                for(var i = 0; i < 23; i++)
                {
                    this.snow.add(random(-400, width), random(0, height * 0.4), 1.4);
                }
            },
            drawBackground : function()
            {
                if(backgrounds.backgrounds.high.img)
                {
                    ctx.drawImage(backgrounds.backgrounds.high.img.sourceImg, 0, 0, width, height);

                    ctx.fillStyle = "rgb(255, 255, 255)";

                    // Render Update snow
                    for(var i = this.snow.length - 1; i >= 0; i--)
                    {
                        ctx.fillRect(floor(this.snow[i].x), floor(this.snow[i].y), 1, 1);

                        this.snow[i].yVel += this.snow[i].gravity;
                        this.snow[i].yVel = min(this.snow[i].yVel, this.snow[i].maxYVel);
                        this.snow[i].x += this.snow[i].xVel * fpsCatcher.speed;
                        this.snow[i].y += this.snow[i].yVel * fpsCatcher.speed;

                        if(this.snow[i].y > height)
                        {
                            this.snow.splice(i, 1);
                        }
                    }

                    if(this.snow.length < 50)
                    {
                        this.snow.add(random(0, width), -2);
                    }

                    noStroke();
                    fill(255, 255, 255, 100);

                    // Render and update clouds (if they move)
                    var clouds = backgrounds.backgrounds.high.clouds;
                    for(var i = 0; i < clouds.length; i++)
                    {
                        $pjs.rect(clouds[i].x, clouds[i].y, clouds[i].width, clouds[i].height, clouds[i].round);

                        if(clouds[i].xVel)
                        {
                            clouds[i].x += clouds[i].xVel * fpsCatcher.speed;

                            if(clouds[i].x < -clouds[i].width)
                            {
                                clouds[i].x = width;
                                clouds[i].xVel = -abs(clouds[i].xVel);
                            }
                            else if(clouds[i].x > width)
                            {
                                clouds[i].x = -clouds[i].width; 
                                clouds[i].xVel = abs(clouds[i].xVel);
                            }
                        }
                    }
                }
            },
        },
        "deep" : {
            primeLoad : function()
            {
                background(10, 10, 24);

                fill(255, 255, 255, 12);
                for(var x = 0; x < 400 - 32; x += 30)
                {
                    for(var y = 0; y < 400 - 32; y += 30)
                    {
                        fastRect(x, y, 3, 3);
                    }
                }

                var i = 0;
                for(var y = 0; y < height - 32; y += 30)
                {
                    for(var x = (i % 2 === 0) ? 15 : 0; x < width - 32; x += 30)
                    {
                        fastRect(x, y, 10, 10);
                    }

                    i++;
                }

                backgrounds.backgrounds.deep.img = get(0, 0, width, height);
            },
            drawBackground : function()
            {
                var layer = backgrounds.backgrounds.deep.img;

                var speed = 0.5;

                var xSpeed = (levelInfo.width - cam.focusXPos || 0) * speed;
                var x = -floor((xSpeed + width) / layer.width);

                var ySpeed = (levelInfo.height - cam.focusYPos || 0) * speed;
                var y = -floor((ySpeed + height) / layer.height);

                ctx.drawImage(layer.sourceImg, layer.width * x + xSpeed, layer.width * y + ySpeed, width, height);
                ctx.drawImage(layer.sourceImg, layer.width * (x + 1) + xSpeed, layer.width * y + ySpeed, width, height);

                ctx.drawImage(layer.sourceImg, layer.width * x + xSpeed, layer.width * (y + 1) + ySpeed, width, height);
                ctx.drawImage(layer.sourceImg, layer.width * (x + 1) + xSpeed, layer.width * (y + 1) + ySpeed, width, height);
            }
        },
        "sand" : {
            load : function()
            {
                if(backgrounds.backgrounds.sand.img)
                {   
                    return;
                }

                $pjs.pushMatrix();
                function sand(x, y, xs, ys, c)
                {
                    $pjs.pushMatrix();
                        translate(x || 0, y || 0);
                        scale(xs || 1, ys || 1);
                        fill(c || color(237-12, 201, 175-19));
                        triangle(0, 30, 40, 0, 80, 30);
                        fill(0, 0, 0, 12);
                        var amt = 5;
                        triangle(0 + amt * Math.SQRT2, 30, 40, 0 + amt, 80 - amt * Math.SQRT2, 30);
                    $pjs.popMatrix();
                }

                background(117, 191, 220);

                noStroke();
                for(var y = 0; y < 400; y++)
                {
                    for(var x = 0; x < 400; x++)
                    {
                        var r = 24;
                        var g = 340 - (250 - y * 0.3);
                        var b = ((365 + 40 + y - ((x + y) % 14 <= 4 ? 110 : -20)) * 260 / 600) + 120 - y * 0.4;

                        fill(r, g, b);
                        $pjs.rect(x, y, 2, 2);
                    }
                }
                
                this.behindSky = get(0, 0, 400, 400);
                accelerateImg(this.behindSky);

                noStroke();
                fill(255-30, 229, 40);
                ellipse(90-12+234, 60, 38, 38);

                $pjs.pushMatrix();
                    translate(0, -70);
                   
                    sand(90, 280, 2, 2.1);
                    sand(-20, 300, 1.4, 1.4);
                    sand(50, 310);

                    sand(330, 320);

                    fill(246-40+12, 194, 69+40);
                    $pjs.rect(0, 340, 400, 45);

                    fill(246+12, 192, 69+40);
                    $pjs.rect(0, 380, 400, 300);
                $pjs.popMatrix();

                $pjs.popMatrix();

                backgrounds.backgrounds.sand.img = get(0, 0, 400, 400);
                accelerateImg(backgrounds.backgrounds.sand.img);
            },
            drawBackground : function()
            {
                if(!backgrounds.backgrounds.sand.img)
                {   
                    return;
                }

                if(game.dropRate)
                {
                    $pjs.pushMatrix();
                    function sand(x, y, xs, ys, c)
                    {
                        $pjs.pushMatrix();
                            translate(x || 0, y || 0);
                            scale(xs || 1, ys || 1);
                            fill(c || color(237-12, 201, 175-19));
                            triangle(0, 30, 40, 0, 80, 30);
                            fill(0, 0, 0, 12);
                            var amt = 5;
                            triangle(0 + amt * Math.SQRT2, 30, 40, 0 + amt, 80 - amt * Math.SQRT2, 30);
                        $pjs.popMatrix();
                    }

                    ctx.drawImage(this.behindSky.sourceImg, 0, 0, width, height);

                    noStroke();
                    fill(255-30, 229, 40);
                    circle(312, 60 + (game.dropRate || 0) * 0.5, 38);

                    $pjs.pushMatrix();
                        translate(0, -70 + game.dropRate);
                       
                        sand(90, 280, 2, 2.1);
                        sand(-20, 300, 1.4, 1.4);
                        sand(50, 310);

                        sand(330, 320);

                        fill(218, 194, 109);
                        $pjs.rect(0, 340, 400, 45);

                        fill(258, 192, 109);
                        $pjs.rect(0, 380, 400, 300);
                    $pjs.popMatrix();

                    $pjs.popMatrix();
                }else{
                    ctx.drawImage(backgrounds.backgrounds.sand.img.sourceImg, 0, 0, width, height);
                }

                $pjs.pushMatrix();
                    translate(0, game.dropRate || 0);

                    graphics.inClouds.draw();
                    if(!screenUtils.fade.fading)
                    {
                        graphics.inClouds.update();
                    }
                $pjs.popMatrix();
            }
        },
        "ship" : {
            primeLoad : function()
            {
                background(0, 0, 0);
                noStroke();

                backgrounds.backgrounds.ship.img = get(0, 0, width, height);
            },
            drawBackground : function()
            {
                let img = backgrounds.backgrounds.ship.img;
                ctx.drawImage(img.sourceImg, 0, 0, width, height);
            }
        },
        "atmosphere" : {
            factor : 1,
            stars : [],
            starLate : 0, // star translate.
            primeLoad : function()
            {
                for(var i = 0; i < 135; i++)
                {
                    this.stars.push([random(0, 400), random(0, 400), random(0, 1.5)]);
                }
            },
            reset : function()
            {
                this.starLate = 0;
                this.factor = 1.0;
            },
            load : function()
            {
                this.reset();
            },
            drawBackground : function()
            {
                var x, y, r, g, b;

                var f = this.factor;

                for(y = 0; y < 400; y += 2)
                {
                    r = 24;
                    g = 340 - (250 - y * 0.3);
                    b = (405 + y - -20 * 260 / 600) + 120 - y * 0.4;

                    ctx.fillStyle = "rgba(" + r * f + ',' + g * f + ',' + b * f + ",100)";
                    ctx.fillRect(0, y, width, 2);
                }

                if(f < 1.0)
                {
                    var t = (400 + 20) * (1.0 - f);
                    stroke(255, 255, 255);

                    var stars = this.stars;

                    for(var i = 0; i < stars.length; i++)
                    {
                        if(stars[i][1] > t)
                        {
                            continue;
                        }

                        strokeWeight(stars[i][2]);
                        point(stars[i][0], (stars[i][1] + this.starLate) % 400);
                    }
                }

                noStroke();
                fill(225, 229, 40);
                circle(312, 40 + (game.dropRate || 0) * 0.65, 38);

                $pjs.pushMatrix();
                    translate(0, game.dropRate || 0);

                    graphics.inClouds.draw();
                    if(!screenUtils.fade.fading)
                    {
                        graphics.inClouds.update();
                    }
                $pjs.popMatrix();
            }
        },
        "space" : {
            stars : [],
            load : function()
            {
                this.stars.length = 0;

                for(var i = 0; i < 164; i++)
                {
                    this.stars.push([random(0, 400), random(0, 400), random(0, 1.5)]);
                }
            },
            drawBackground : function()
            {
                ctx.fillStyle = "rgba(0, 0, 0, 100)";
                ctx.fillRect(0, 0, 600, 600);
            }
        },
        "space2" : {
            stars : [],
            scroll : 0,
            load : function()
            {
                this.scroll = 0;

                this.stars.length = 0;
                this.stars = backgrounds.backgrounds.atmosphere.stars.concat(this.stars);
            },
            drawBackground : function()
            {
                ctx.fillStyle = "rgba(0, 0, 0, 100)";
                ctx.fillRect(0, 0, 600, 600);

                ctx.fillStyle = ("rgba(255, 255, 255, 100)");

                this.scroll += 1.2;

                var offset = 0;
                for(var i = 0; i < this.stars.length; i++)
                {
                    offset = this.scroll * (0.1 + this.stars[i][2]);

                    ctx.fillRect(this.stars[i][0], (this.stars[i][1] + offset) % 400, Math.max(this.stars[i][2] - 1), Math.max(this.stars[i][2] - 1));
                }
            }
        }
    },
    load : function()
    {
        if(this.backgrounds[this.background].load !== undefined)
        {
            this.backgrounds[this.background].load();
        }
    },
    setBackground : function(backgroundName)
    {
        if(this.backgrounds[backgroundName] !== undefined)
        {
            this.background = backgroundName;
        }
    },
    drawBackground : function()
    {
        if(this.backgrounds[this.background].drawBackground !== undefined)
        {
            this.backgrounds[this.background].drawBackground();
        }

        if(levelInfo.backgroundDarkGrid)
        {
            this.darkGrid.draw();
        }
    },
    drawForeground : function()
    {
        if(this.backgrounds[this.background].drawForeground !== undefined)
        {
            this.backgrounds[this.background].drawForeground();
        }
    },
    primeLoad : function()
    {
        for(var i in this.backgrounds)
        {
            if(this.backgrounds[i].primeLoad !== undefined)
            {
                this.backgrounds[i].primeLoad(); 
            }
        }

        this.darkGrid = new BackBlock(0, 0, WIDTH, HEIGHT);
    },
};

var pixelFuncs = {
    safeRead : function(item, col, row)
    {
        return(((col >= 0 && col < item.length) &&
            (row >= 0 && row < item[col].length)) ? item[col][row]  : undefined);
    },
    replacePixels : function(img, findColor, replaceColor)
    {
        var _pixels = img.pixels.toArray();
        for(var i = 0; i < _pixels.length; i++)
        {
            if(_pixels[i] === findColor || (red(_pixels[i]) >= 240 && green(_pixels[i]) >= 240 && blue(_pixels[i]) >= 240))
            {
                img.pixels.setPixel(i, replaceColor);
            }
        }
    },
    createPixelImage : function(input)
    {
        if(input.pixelSize === undefined)
        {
            input.pixelSize = 1;
        }

        if(input.width === undefined)
        {
            input.width = input.pixelSize * input.pixels[0].length;
        }

        if(input.height === undefined)
        {
            input.height = input.pixelSize * input.pixels.length;
        }

        var img = createGraphics(input.width, input.height, P2D);
        img.beginDraw();
        img.noStroke();
        img.background(0, 0, 0, 0);
        for(var row = 0; row < input.pixels.length; row++)
        {
            for(var col = 0; col < input.pixels[row].length; col++)
            {
                var char = pixelFuncs.safeRead(input.pixels, row, col);
                var toFill = (input.pallete[char] !== undefined) ?
                    input.pallete[char]  : "clear";
                if(toFill !== "clear")
                {
                    img.fill(toFill);
                    img.fastRect(col * input.pixelSize, row * input.pixelSize, input.pixelSize, input.pixelSize);
                }
            }
        }
        img.endDraw();
        img.inputWidth = input.width;
        img.inputHeight = input.height;
        return img;
    },
};

var pallete = {
    'b' : color(31, 54, 122),
    'c' : color(0, 0, 0),
    'd' : color(43, 181, 181),
    'e' : color(200, 150, 60),
    'f' : color(43, 132, 181),
    'g' : color(14, 130, 31),
    'h' : color(40, 95 - 50, 151),
    'i' : color(31 - 20, 54 - 20, 122 - 20),
    'j' : color(200 - 30, 150 - 30, 60 - 30),
    'k' : color(34, 150, 51),
    'l' : color(51, 51, 51),
};
var storedImages = {
    "skyViper" : pixelFuncs.createPixelImage({
        width : 50, 
        height : 50, 
        replace : true,
        pixelSize : 3, 
        pixels : [
            "aaaaaaaabbbbaa",
            "aaaaaaabccccba",
            "bbabbbabcbcbcb",
            "bdbdeebcffcffb",
            "bdeedbcccccbba",
            "abdebfffbbbaaa",
            "aabbbcccfbaaaa",
            "aaaabffcfcbaaa",
            "agaaabbbffcbaa",
            "gaggaaaabcfbaa",
            "aggggbaabcfbaa",
            "aaggbfbbfcfbaa",
            "aaagbfccffbaaa",
            "aaaaabffbbaaaa",
            "aaaaaabbaaaaaa",
        ],
        pallete : {
            'a':"clear",
            'b':-16777215,
            'c':-13778048,
            'd':-11846475,
            'e':-10848091,
            'f':-13785753,
            'g':-1025524,
        },
    }),
    "skyViperLeft" : pixelFuncs.createPixelImage({
        width : 50, 
        height : 50, 
        replace : true,
        pixelSize : 3, 
        pixels : [
            "aabbbbaaaaaaaa",
            "abccccbaaaaaaa",
            "bcbcbcbabbbabb",
            "bffcffcbeedbdb",
            "abbcccccbdeedb",
            "aaabbbfffbedba",
            "aaaabfcccbbbaa",
            "aaabcfcffbaaaa",
            "aabcffbbbaaaga",
            "aabfcbaaaaggag",
            "aabfcbaabgggga",
            "aabfcfbbfbggaa",
            "aaabffccfbgaaa",
            "aaaabbffbaaaaa",
            "aaaaaabbaaaaaa",
        ],
        pallete : {
            'a':"clear",
            'b':-16777215,
            'c':-13778048,
            'd':-11846475,
            'e':-10848091,
            'f':-13785753,
            'g':-1025524,
        },
    }),
    "skyViper2" : pixelFuncs.createPixelImage({
        width : 50, 
        height : 50, 
        replace : true,
        pixelSize : 3, 
        pixels : [
            "aabbaaaaaaaaaaa",
            "abcdbbbabbbbaaa",
            "abdccdcbeeeebaa",
            "bbcbbbdbebebeba", 
            "bfbfddbeggeggba",
            "bfddfbeeeeghbaa", 
            "abfdbgggbgbahaa", 
            "aabbabeegbaaaha", 
            "aaaaabgegebahah",
            "aiaaaabbggebaaa", 
            "iaiiaaaabegbaaa", 
            "aiiiibaabegbaaa", 
            "aaiibgbbgegbaaa", 
            "aaaibgeeggbaaaa", 
            "aaaaabggbbaaaaa", 
            "aaaaaabbaaaaaaa", 
        ],
        pallete : {
            'a':"clear",
            'b':-16777215,
            'c':-14787959,
            'd':-10848091,
            'e':-13778048,
            'f':-11846475,
            'g':-13785753,
            'h':-1048513,
            'i':-1025524,
        },
    }),
    "skyViperLeft2" : pixelFuncs.createPixelImage({
        width : 50, 
        height : 50, 
        replace : true,
        pixelSize : 3, 
        pixels : [
            "aaaaaaaaaaabbaa",
            "aaabbbbabbbdcba",
            "aabeeeebcdccdba",
            "abebebebdbbbcbb",
            "abggeggebddfbfb",
            "aabhgeeeebfddfb",
            "aahabgbgggbdfba",
            "ahaaabgeebabbaa",
            "hahabegegbaaaaa",
            "aaabeggbbaaaaia",
            "aaabgebaaaaiiai",
            "aaabgebaabiiiia",
            "aaabgegbbgbiiaa",
            "aaaabggeegbiaaa",
            "aaaaabbggbaaaaa",
            "aaaaaaabbaaaaaa",
        ],
        pallete : {
            'a':"clear",
            'b':-16777215,
            'c':-14787959,
            'd':-10848091,
            'e':-13778048,
            'f':-11846475,
            'g':-13785753,
            'h':-1048513,
            'i':-1025524,
        },
    }),
    "ninja" : pixelFuncs.createPixelImage({
        width : 30, 
        height : 48, 
        replace : true,
        pixelSize : 4, 
        pixels : [
            "aabbbbaa",
            "aabccdaa",
            "aabbbdaa",
            "effbbffe",
            "abffffba",
            "abgbbgba",
            "acdbgbca",
            "acbbdbca",
            "aabgbbaa",
            "aadbbgaa",
            "aabbbbaa",
            "aacaacaa",
            "aacaacaa",
        ],
        pallete : {
            'a':"clear",
            'b':-16777216,
            'c':-14803328,
            'd':-16777152,
            'e':-8355712,
            'f': 127.5,
            'g':-15794032,
        },
    }),
    "ninjaStar" : pixelFuncs.createPixelImage({
        width : 18, 
        height : 18, 
        replace : true,
        pixelSize : 3, 
        pixels : [
            "abbaaa",
            "aabaab",
            "aaccbb",
            "bbccaa",
            "baabaa",
            "aaabba",
        ],
        pallete : {
            'a':"clear",
            'b':-16777216,
            'c':-12802684,
        },
    }),
    "ninjaBoss" : pixelFuncs.createPixelImage({
        width : Math.round(11 * 3), 
        height : Math.round(28 * 3), 
        replace : true,
        pixelSize : 3, 
        pixels : [
            "aabcdddcbaa",
            "abbdcccdbba",
            "abeeeeeeeba",
            "aceffeffeca",
            "aceeeeeeeca",
            "abbdgggdbba",
            "aabcccccbaa",
            "aahcifichaa",
            "abhfeeefhba",
            "bfcedddecfb",
            "bfcdifidcfb",
            "ddhfififhdd",
            "dfhfeeefhfd",
            "bfcedddecfb",
            "becdifidceb",
            "eehfififhee",
            "eahfeeefhae",
            "aacfeeefcaa",
            "aahhfffhhaa",
            "aabbbbbbbaa",
            "aabfcccfbaa",
            "aabfcacfbaa",
            "abbecacebba",
            "aeeecaceeea",
            "afchhahhcfa",
            "afchaaahcfa",
            "afddaaaddfa",
            "afeeaaaeefa",
        ],
        pallete : {
           'a':"clear",
           'b':-15778670,
           'c':-13808768,
           'd':-9842040,
           'e':-10836532,
           'f':-12814140,
           'g':-14776440,
           'h':-13808768,
           'i':-16738574,
        },
    }),
    "suitLeft" : pixelFuncs.createPixelImage({
        width : 30,
        height : 60,
        replace : true,
        pixelSize : 3,
        pixels : [
            "  iiiiii  ",
            "  ibbbbi  ",
            "  hchcbi  ",
            "  ccccbi  ",
            "  ibbbbi  ",
            "iiibbbbidd",
            "ibbbbbbbdf",
            "ibeebbddbi",
            "ibjebbddbi",
            "ibeeddbbbi",
            "fdejdfbbbi",
            "ffddbbejfd",
            " lddbbeeff",
            " libbbjel ",
            " libbbjel ",
            " lkgbbbill",
            "  gkbbbill",
            "  kg  bi  ",
            "  dd  dd  ",
            "  ff  ff  ",
        ],
        pallete : pallete,
    }),
    "suitLeft2" : pixelFuncs.createPixelImage({
        width : 30,
        height : 60,
        replace : true,
        pixelSize : 3,
        pixels : [
            "  iiiiii  ",
            "  ibbbbi  ",
            "  hchcbi  ",
            "  ccccbi  ",
            "  ibbbbi  ",
            "iiibbbbidd",
            "ibbbbbbbdf",
            "ibeebbddbi",
            "ibjebbddbi",
            "ibeeddbbbi",
            "fdejdfbbbi",
            "ffddbbejfd",
            " lddbbeeff",
            " libbbjel ",
            " libbbjel ",
            " lkgbbbill",
            "  gkbbbill",
            "  kg  dd  ",
            "  dd  ff  ",
            "  ff      ",
        ],
        pallete : pallete,
    }),
    "suitLeft3" : pixelFuncs.createPixelImage({
        width : 30,
        height : 60,
        replace : true,
        pixelSize : 3,
        pixels : [
            "  iiiiii  ",
            "  ibbbbi  ",
            "  hchcbi  ",
            "  ccccbi  ",
            "  ibbbbi  ",
            "iiibbbbidd",
            "ibbbbbbbdf",
            "ibeebbddbi",
            "ibjebbddbi",
            "ibeeddbbbi",
            "fdejdfbbbi",
            "ffddbbejfd",
            " lddbbeeff",
            " libbbjel ",
            " libbbjel ",
            " lkgbbbill",
            "  gkbbbill",
            "  dd  bi  ",
            "  ff  dd  ",
            "      ff  ",
        ],
        pallete : pallete,
    }),
    "suitRight" : pixelFuncs.createPixelImage({
        width : 30,
        height : 60,
        replace : true,
        pixelSize : 3,
        pixels : [
            "  iiiiii  ",
            "  ibbbbi  ",
            "  ibchch  ",
            "  ibcccc  ",
            "  ibbbbi  ",
            "iiibbbbidd",
            "ibbbbbbbdf",
            "ibeebbddbi",
            "ibjebbddbi",
            "ibeeddbbbi",
            "ibejdfbbdf",
            "dfddbbejff",
            "ffddbbeel ",
            " libbbjel ",
            " libbbjel ",
            "llkgbbbil ",
            "llgkbbbi  ",
            "  kg  bi  ",
            "  dd  dd  ",
            "  ff  ff  ",
        ],
        pallete : pallete,
    }),
    "suitRight2" : pixelFuncs.createPixelImage({
        width : 30,
        height : 60,
        replace : true,
        pixelSize : 3,
        pixels : [
            "  iiiiii  ",
            "  ibbbbi  ",
            "  ibchch  ",
            "  ibcccc  ",
            "  ibbbbi  ",
            "iiibbbbidd",
            "ibbbbbbbdf",
            "ibeebbddbi",
            "ibjebbddbi",
            "ibeeddbbbi",
            "ibejdfbbdf",
            "dfddbbejff",
            "ffddbbeel ",
            " libbbjel ",
            " libbbjel ",
            "llkgbbbil ",
            "llgkbbbi  ",
            "  dd  bi  ",
            "  ff  dd  ",
            "      ff  ",
        ],
        pallete : pallete,
    }),
    "suitRight3" : pixelFuncs.createPixelImage({
        width : 30,
        height : 60,
        replace : true,
        pixelSize : 3,
        pixels : [
            "  iiiiii  ",
            "  ibbbbi  ",
            "  ibchch  ",
            "  ibcccc  ",
            "  ibbbbi  ",
            "iiibbbbidd",
            "ibbbbbbbdf",
            "ibeebbddbi",
            "ibjebbddbi",
            "ibeeddbbbi",
            "ibejdfbbdf",
            "dfddbbejff",
            "ffddbbeel ",
            " libbbjel ",
            " libbbjel ",
            "llkgbbbil ",
            "llgkbbbi  ",
            "  kg  dd  ",
            "  dd  ff  ",
            "  ff      ",
        ],
        pallete : pallete,
    }),
    "suit" : pixelFuncs.createPixelImage({
        width : 30,
        height : 60,
        replace : true,
        pixelSize : 3,
        pixels : [
            "  iiiiii  ",
            "  ibbbbi  ",
            "  ichchi  ",
            "  icccci  ",
            "  ibbbbi  ",
            "iiibbbbidd",
            "ibbbbbbbdf",
            "ibeebbddbi",
            "ibjebbddbi",
            "ibeeddbbbi",
            "ibejdfbbbi",
            "fdddbbejdf",
            "ffddbbeeff",
            " libbbjel",
            " libbbjel",
            " lkgbbbil ",
            "llgkbbbill",
            "llkgllbill",
            "  dd  dd  ",
            "  ff  ff  ",
        ],
        pallete : pallete,
    }),
    npcs : {
        "Abby" : pixelFuncs.createPixelImage({
            replace : true,
            pixelSize : 3, 
            pixels : [
                "aabbbbaaa",
                "abbbbbbaa",
                "abbccbbba",
                "abcdcdbba",
                "abccccbba",
                "abceecbba",
                "bbccccbba",
                "bbfffffba",
                "bffgggffa",
                "fhfggifff",
                "fhfgiifhf",
                "fhfggifhf",
                "fhfgggfhf",
                "fhfiggfhf",
                "fffiigfff",
                "ccfiggccf",
                "ccggggcca",
                "aafhhhfaa",
                "aahfffhaa",
                "aahfafhaa",
                "aahfafhaa",
                "aahfafhaa",
                "aahfafhaa",
                "aahfafhaa",
                "aaffaffaa",
                "aagjajgaa",
                "aggjajgga",
            ],
            pallete : {
                'a':"clear",
                'b':-6916009,
                'c':-7781,
                'd':-11831097,
                'e':-1981543,
                'f':-11811943,
                'g':-10832671,
                'h':-8855143,
                'i':-12821791,
                'j':-10821151,
            },
        }),
        "Jason" : pixelFuncs.createPixelImage({
            replace : true,
            pixelSize : 3, 
            pixels : [
                "abbbbbaa",
                "bbbbbbba",
                "bbcccbba",
                "acdcdcaa",
                "acccccaa",
                "aaceecaa",
                "aaccccaa",
                "aafffffa",
                "affgggff",
                "ahhiiihh",
                "afhggghf",
                "afhiiihf",
                "afhggghf",
                "afhiiihf",
                "accjjjcc",
                "acckkkcc",
                "aaakkkaa",
                "aaakakaa",
                "aaakakaa",
                "aaakakaa",
                "aaakakaa",
                "aaajajaa",
                "aajjajja",
            ],
            pallete : {
                'a':"clear",
                'b':-14799616,
                'c':-1977714,
                'd':-13781941,
                'e':-4938385,
                'f':-2991550,
                'g':-9838270,
                'h':-1989310,
                'i':-9853630,
                'j':-13781823,
                'k':-14780223,
            },
        }),
        "Oscar" : pixelFuncs.createPixelImage({
            replace : true,
            pixelSize : 3, 
            pixels : [
                "aaabbaaa",
                "abbbbbaa",
                "abcccbba",
                "abccccba",
                "bbdccdba",
                "aaccccaa",
                "aaccccaa",
                "aaceecaa",
                "aaccccaa",
                "aaaccaaa",
                "aaffffaa",
                "affffffa",
                "fffggfff",
                "ffhhhhff",
                "ffggggff",
                "ffhhhhff",
                "ffggggff",
                "ffhhhhff",
                "cciiiicc",
                "aiiiiiia",
                "aiiaaiia",
                "aiiaaiia",
                "aiiaaiia",
                "aiiaaiia",
                "aiiaaiia",
                "ajjaajja",
            ],
            pallete : {
                'a':-"clear",
                'b':-167,
                'c':-11661,
                'd':-16734887,
                'e':-19393,
                'f':-50087,
                'g':-13785767,
                'h':-9838247,
                'i':-14811047,
                'j':-12795047,
            },
        }),
    },
    "chest" : pixelFuncs.createPixelImage({
        replace : true,
        pixelSize : 4, 
        pixels : [
            "bbbbbbb",
            "bcccccb",
            "bbbdbbb",
            "bcccccb",
            "bcccccb",
            "bbbbbbb",
        ],
        pallete : {
           'a':"clear",
           'b':-2972390,
           'c':-1002412,
           'd':-987031,
        },
    }),
    "chest-open" : pixelFuncs.createPixelImage({
        replace : true,
        pixelSize : 4, 
        pixels : [
            "bbbcbbb",
            "bdddddb",
            "bdddddb",
            "bbbbbbb",
            "beeeeeb",
            "beeeeeb",
            "bbbbbbb",
        ],
        pallete : {
            'a':"clear",
            'b':-2972390,
            'c':-990976,
            'd':-14807296,
            'e':-1002412,
        },
    }),
     "itemChest" : pixelFuncs.createPixelImage({
        replace : true,
        pixelSize : 4, 
        pixels : [
            "bbbbbbbbb",
            "bbcccccbb",
            "bcccccccb",
            "bbbdddbbb",
            "bcccccccb",
            "bcccccccb",
            "bbcccccbb",
            "bbbbbbbbb",
        ],
        pallete : {
           'a':"clear",
           'b':color(2, 2, 2),
           'c':color(52, 38, 138),
           'd':color(75, 175, 75),
        },
    }),
    "itemChest-open" : pixelFuncs.createPixelImage({
        replace : true,
        pixelSize : 4, 
        pixels : [
            "bbbdddbbb",
            "bUUUUUUUb",
            "bUUUUUUUb",
            "bbbbbbbbb",
            "bcccccccb",
            "bcccccccb",
            "bbcccccbb",
            "bbbbbbbbb",
        ],
        pallete : {
           'a':"clear",
           'b':color(2, 2, 2),
           'c':color(52, 38, 138),
           'd':color(75, 175, 75),
           'U':color(22, 13, 90),
        },
    }),
    "dirtyBlock" : pixelFuncs.createPixelImage({
       replace : true,
       pixelSize : 6, 
       pixels : [
           "bbbccbbb",
           "bdbedddc",
           "bebddeeb",
           "cebeeeeb",
           "ceebbbbc",
           "cbeeeebc",
           "bbdddebb",
           "ccbbbbcc",
       ],
       pallete : {
           'a':"clear",
           'b':-12798767,
           'c':-11823450,
           'd':-12818109,
           'e':-13797210,
       },
    }),
    "dirtyCat" : pixelFuncs.createPixelImage({
        replace : true,
        pixelSize : 3, 
        pixels : [
            "aaaaaaabaaaaaaaaaaaaaaaaaaa",
            "abaaaaabaaaaaaaaaaaaaaaaaaa",
            "abaaaabcbaaaaaaaaaaaaaaaaaa",
            "bcbbbbbcbaaaaaaaaaaaaaaaaaa",
            "bcbccddbbaaaaaaaaaaaaaaaaaa",
            "bbbccccbbaaaaaaaaaaaaaaaaaa",
            "bddcccddbaaaaaaaaaaaaaaaaaa",
            "bccccddebaaaaaaaaaaaaaaaaaa",
            "bcdddccebaaaaaaaaaaaaaaaaaa",
            "bccccccebaaabbbabbbbaaaaaaa",
            "abbbceecbbbabccbccccbbbbbbb",
            "aabcececceebcceeccececececb",
            "aabbcceeccccceccceecebbbbba",
            "aaabbceecccceecccccbbaaaaaa",
            "aaaabbbceecbbbbbbcbaaaaaaaa",
            "aaaaaaabcbbaaaaabcbaaaaaaaa",
            "aaaaaaaabaaaaaaaabaaaaaaaaa",
        ],
        pallete : {
            'a':"clear",
            'b':-14788024,
            'c':-16769498,
            'd':-10832824,
            'e':-15774938,
        },
    }),
    "dirtyCat2" : pixelFuncs.createPixelImage({
        replace : true,
        pixelSize : 3, 
        pixels : [
            "aaaaaaabaaaaaaaaaaaaaaaaaaa",
            "abaaaaabaaaaaaaaaaaaaaaaaaa",
            "abaaaabcbaaaaaaaaaaaaaaaaaa",
            "bcbbbbbcbaaaaaaaaaaaaaaaaaa",
            "bcbccddbbaaaaaaaaaaaaaaaaaa",
            "bbbccccbbaaaaaaaaaaaaaaaaaa",
            "bddcccddbaaaaaaaaaaaaaaaaaa",
            "bccccddebaaaaaaaaaaaaaaaaaa",
            "bcdddccebaaaaaaaaaaaaaaaaaa",
            "bccccccebaaabbbabbbbaaaaaaa",
            "abbbceecbbbabccbccccbbbbbbb",
            "aabcececceebcceeccececececb",
            "aabbcceeccccceccceecebbbbba",
            "aaabbceecccceecccccbbaaaaaa",
            "aaaabbbccebbbbbbbcbaaaaaaaa",
            "aaaaaabcbbaaaaaaabcbaaaaaaa",
            "aaaaaaabaaaaaaaaaabaaaaaaaa",
        ],
        pallete : {
            'a':"clear",
            'b':-14788024,
            'c':-16769498,
            'd':-10832824,
            'e':-15774938,
        },
    }),
};

graphics.infoBarProps = {
    font : createFont("sans serif"),
    height : 17,
};

var usableItems = {
    "bubbleShield" : {
        description : "Shields you from projectiles.",
        displayName : "Bubble shield",
        use : function(data, useObject)
        {
            cameraGrid.addReference(gameObjects.getObject("bubbleShield").add(
                physics.getMiddleXPos(useObject), 
                physics.getMiddleYPos(useObject), 40));
        },
    },
    "candy" : {
        displayName : "Candy",
        description : "A piece of candy, recovers little to none hp.",
        use : function(data, useObject)
        {
            useObject.hp = Math.min(useObject.hp + Math.floor(random(0, 3)), useObject.maxHp);
        },
        image : pixelFuncs.createPixelImage({
            replace : true,
            pixelSize : 5, 
            pixels : [
                "               ",
                "     eeeee     ",
                "     ecccc     ",
                "     ecbbc     ",
                "     ecbce     ",
                "     eccce     ",
                "     eeeee     ",
                "       _       ",
                "       _       ",
                "       _       ",
                "       _       ",
                "       _       ",
                "       _       ",
                "       _       ",
            ],
            pallete : {
                'a':"clear",
                'b': color(20, 130, 76),
                'c': color(20, 30, 76),
                'd': color(180, 20, 16),
                'e': color(200, 30, 20),
                '_': color(230, 230, 230, 234)
            },
        }),
    },
    "meal" : {
        displayName : "Meal",
        description : "A tasty meal, recovers 10 hp.",
        use : function(data, useObject)
        {
            useObject.hp = Math.min(useObject.hp + 10, useObject.maxHp);
        },
    },
    "goldbar" : {
        description : "Each worth 100 coins",
        displayName : "Gold bar",
        use : function(data, useObject)
        {
            console.log(data);
            useObject.coins += 100;
        },
    },
    "energy" : {
        nonDrop : true,
        description : "Can be used to power up chests.",
        appropriate : function()
        {
            return false;
        }
    },
    "fairy" : {
        description : "Automatically heals you when you die",
        appropriate : function()
        {
            return false;
        }
    }
};

var itemsHandler = {
    canUse : function(data, useObject)
    {
        return (usableItems[data.contains] !== undefined && 
               (usableItems[data.contains].appropriate === undefined || 
                usableItems[data.contains].appropriate(data, useObject)));
    },
    use : function(data, useObject)
    {
        if(!this.canUse(data))
        {
            return false;
        }
        
        try{
            usableItems[data.contains].use(data, useObject);
        }
        catch(e)
        {
            console.log(e);
            return false;
        }

        return true;
    },
};

var Crystal;
var inventoryMenu = {
    opened : false,
    state : "closed",
    tryToOpen : function(func, a, b)
    {
        if(func && func() || keys.e)
        {
            this.open("home", a, b);
            return true;
        }
        return false;
    },
    tryToClose : function(func, a, b)
    {
        if(func && func() || keys.e)
        {
            this.close("home", a, b);
            return true;
        }
        return false;
    },
    open : function(scene, oFuncs, skipV)
    {
        this.scene = scene;

        this.init = false;
        this.opened = true;
        this.state = "opening";

        this.slideVel = 4.5;

        if(!skipV)
        {
            this.slideY = this.maxY;
        }

        this.oFuncs = oFuncs || {};
    },
    close : function(scene, onClose)
    {
        this.scene = scene;

        var lastState = this.state;

        this.opened = false;
        this.state = "closing";

        this.slideVel = 4.5;

        this.oFuncs = {};

        (onClose || function() {})();
    },
    oFuncs : {},

    slideY : height,
    slideX : 0,
    slideVel : 0,
    slideAcl : 2.4,
    maxY : height, 
    minY : 60,

    font : createFont("arial"),

    scene : "home",
    scenes : {
        slideX : 4,
        slideY : 40,
        slideVel : 0,
        maxX : width + 10, 
        minX : 10,
        width : 280,
        height : 200,
        "home" : {
            width : 330,
            height : 230,
            open : true,
            buttons : {
                name  : new Button(10, 132 + 18 * 0, 140, 18, color(12, 60, 160, 100), ""),
                hp    : new Button(10, 132 + 18 * 1, 140, 18, color(12, 60, 160, 100), ""),
                coins : new Button(10, 132 + 18 * 2, 140, 18, color(12, 60, 160, 100), ""),
                score : new Button(10, 132 + 18 * 3, 140, 18, color(12, 60, 160, 100), ""),
                gems : new Button(10, 132 + 18 * 4, 140, 18, color(12, 60, 160, 100), ""),
                k1 : new Button(186, 132 + 18 * 0, 141, 18, color(12, 60, 160, 100), ""),
            }
        },
        "chest" : {
            width : 330,
            height : 230,
            buttons : {},
        },
        "items" : {
            width : 330,
            height : 230,
            buttons : {
                "options_use" : new Button(190, 132, 138, 22, color(28, 180, 48, 100), "Use", undefined, 10),
                "options_drop" : new Button(190, 154, 138, 22, color(28, 180, 48, 100), "Drop", undefined, 10),
            },
        },
        "crystals" : {
            width : 330,
            height : 230,
            buttons : {

            }
        }
    },
    "warpToShip" : new Button(188, 104, 142, 18, color(28, 180, 48, 100), "Warp To Ship Instead", undefined, 12),
    menuButtons : {
        home : new Button(334, 100, 64, 26, color(12, 60, 160, 130), "Home"),
        items : new Button(334, 126, 64, 26, color(12, 60, 160, 130), "Items"),
        crystals : new Button(334, 152, 64, 26, color(12, 60, 160, 130), "Crystals"),
    },
    lastTryTime : 0,
    update : function()
    {
        if(this.state === "opening")
        {
            this.slideY -= this.slideVel;
            this.slideVel += this.slideAcl;

            if(game.fps <= 36)
            {
                this.slideY -= this.slideVel;
                this.slideVel += this.slideAcl / 2;
            }

            if(this.slideY < this.minY)
            {
                this.slideY = this.minY;
                this.state = "opened";
            }
        }
        else if(this.state === "closing")
        {
            this.slideY += this.slideVel;
            this.slideVel += this.slideAcl;

            if(game.fps <= 36)
            {
                this.slideY += this.slideVel;
                this.slideVel += this.slideAcl / 2;
            }

            if(this.slideY > this.maxY)
            { 
                this.slideY = this.maxY;
                this.state = "closed";
            }
        }

        
        var scene = this.scenes[this.scene];
        var self = this;

        if(!this.init)
        {
            switch(this.scene)
            {
                case "home" :
                    scene.buttons.name.message = "Name  " + player.name;
                    scene.buttons.hp.message = "Hp  " + player.hp.toFixed(1) + " / " + player.maxHp.toFixed(1);
                    scene.buttons.coins.message = "Coins  " + player.coins + " / " + player.maxCoins;
                    scene.buttons.score.message = "Score  " + player.score;
                    scene.buttons.gems.message = "Gems " + (player.gems || 0);

                    scene.buttons.name.hover = "Your character's avatar name or alias.";
                    scene.buttons.hp.hover = "Heart points, this is your health, try to keep it full.";
                    scene.buttons.coins.hover = "The amount of coins you've collected so far.";
                    scene.buttons.score.hover = "Your total score.";
                    scene.buttons.gems.hover = "???";

                    if(levels["helixShip"].save.shown)
                    {
                        scene.buttons.gems.hover = "Gems Increase max coin amount and can be used as a\nprolonged fuel for Space Ships.";
                    }

                    var j = 0;
                    for(var i in player.discoveredPowers)
                    {
                        j++;

                        if(typeof scene.buttons["k" + j] === "undefined")
                        {
                            scene.buttons["k" + j] = new Button(186, 132 + 18 * (j - 1), 141, 18, color(12, 60, 160, 100), "");
                        }

                        try{
                            scene.buttons["k" + j].message = player.discoveredPowers[i].name || i;
                            scene.buttons["k" + j].hover = player.discoveredPowers[i].description;
                            scene.buttons["k" + j].type = "Ability";
                        }
                        catch(e)
                        {
                            console.log(e);
                        }
                    }

                    for(var i in scene.buttons)
                    {
                        var btn = scene.buttons[i];
                        btn.textSize = 10;

                        if(btn.message === "")
                        {
                            delete scene.buttons[i];
                        }
                    }
                    break;

                case "items" :
                    scene.buttons["options_drop"].lastClickTime = millis();
                    scene.buttons["options_drop"].hover = "(hold) Drop the item, you can't get it back.";
                    scene.buttons["options_drop"].onClick = function()
                    {
                        if(!mouseIsPressed)
                        {
                            this.lastClickTime = 0;
                            return;
                        }

                        if(scene.highlightedButtonIndex === undefined || millis() - this.lastClickTime < 1000)
                        {
                            return;
                        }

                        var i = scene.highlightedButtonIndex;

                        var btn = scene.buttons["player_" + i];
                        var item = player.inventory.items[btn.index];

                        if(usableItems[item.contains] && usableItems[item.contains].nonDrop)
                        {
                            return;
                        }

                        // if(typeof item.amount === "number")
                        // {
                            // item.amount--;
                        // }

                        // if(!item.amount)
                        // {
                            item = player.inventory.items[btn.index] = {};
                            btn = scene.buttons["player_" + i] = new Button(10, 132 + i * 18, 140, 18, color(28, 28, 28, 100), " - ", undefined, 10);
                        // }

                        // btn.amount = item.amount;
                        // btn.extra = (item.amount ? " x " + item.amount : "");

                        delete scene.highlightedButtonIndex;

                        this.lastClickTime = millis();
                    };

                    var _lastDraw = scene.buttons["options_drop"].draw;
                    scene.buttons["options_drop"].draw = function()
                    {
                        if(!mouseIsPressed)
                        {
                            this.lastClickTime = millis();
                        }

                        return _lastDraw.apply(this, arguments);
                    };

                    scene.buttons["options_use"].lastClickTime = 0;
                    scene.buttons["options_use"].hover = "Use the item, you can't get it back.";
                    scene.buttons["options_use"].onClick = function()
                    {
                        if(!mouseIsPressed)
                        {
                            this.lastClickTime = 0;
                            return;
                        }

                        if(scene.highlightedButtonIndex === undefined || millis() - this.lastClickTime < 500)
                        {
                            return;
                        }

                        var i = scene.highlightedButtonIndex;

                        var btn = scene.buttons["player_" + i];
                        var item = player.inventory.items[btn.index];

                        // This should never happen, but just in case if it set to zero but it still exists.
                        if(item.amount === 0)
                        {
                            item.amount = 1;
                        }

                        if((typeof item.amount === "undefined" || item.amount > 0) && itemsHandler.use(item, player))
                        {
                            if(typeof item.amount === "number")
                            {
                                item.amount--;
                            }

                            if(typeof item.amount === "undefined" || item.amount <= 0)
                            {
                                item = player.inventory.items[btn.index] = {};
                                btn = scene.buttons["player_" + i] = new Button(10, 132 + i * 18, 140, 18, color(28, 28, 28, 100), " - ", undefined, 10);
                                delete scene.highlightedButtonIndex;
                            }

                            btn.amount = item.amount;
                            btn.extra = (item.amount ? " x " + item.amount : "");
                        }

                        if(item.amount <= 0)
                        {
                            item = player.inventory.items[btn.index] = {};
                            btn = scene.buttons["player_" + i] = new Button(10, 132 + i * 18, 140, 18, color(28, 28, 28, 100), " - ", undefined, 10);
                            delete scene.highlightedButtonIndex;
                        }

                        this.lastClickTime = millis();
                    };
                    break;
            }
            
            (this.oFuncs.init || function() {})(scene);

            for(var i in this.menuButtons)
            {
                this.menuButtons[i].textSize = 10;
            }

            this.init = true;
        }

        switch(this.scene)
        {
            case "items" :
                if(scene.highlightItems)
                {
                    var j = 0;
                    while(inventoryMenu.scenes[inventoryMenu.scene].buttons["player_" + j])
                    {
                        var btn = inventoryMenu.scenes[inventoryMenu.scene].buttons["player_" + j];

                        if(scene.highlightedButtonIndex === j)
                        {
                            j++;
                            continue;
                        }

                        btn.highlighted = undefined;
                        btn.highlightStroke = undefined;

                        j++;
                    }
                }

                var chng = (scene.highlightedButtonIndex === undefined || !itemsHandler.canUse(
                    player.inventory.items[scene.buttons["player_" + scene.highlightedButtonIndex].index], player));

                var item = {};
                if(scene.highlightedButtonIndex !== undefined)
                {
                    item = player.inventory.items[scene.buttons["player_" + scene.highlightedButtonIndex].index];
                }

                scene.buttons["options_use"].overrideColor = chng ? color(28, 28, 28, 100) : scene.buttons["options_use"].firstColor;
                if((usableItems[item.contains] && usableItems[item.contains].nonDrop) || scene.highlightedButtonIndex === undefined)
                {
                    scene.buttons["options_drop"].overrideColor = color(28, 28, 28, 100);
                }else{
                    scene.buttons["options_drop"].overrideColor = scene.buttons["options_drop"].firstColor;
                }
                break;

            case "crystals" :
                if(!mouseIsPressed || this.countedCrystals < 3)
                {
                    this.counterTimer = 0;
                    break;
                }

                var dx = -mouseX + 260 * (2 / 3);
                var dy = -mouseY + 300 * (2 / 3);
                var inside = (dx * dx + dy * dy < 25 * 25);

                this.warpClicked = inside;

                if(inside !== this.lastWarpClicked)
                {
                    if(inside)
                    {
                        this.counting = true;
                    }else{
                        this.counting = false;
                    }

                    this.counterTimer = 0;
                    this.maxCounterTimer = 200;
                }

                this.lastWarpClicked = inside;

                if(this.counting)
                {
                    this.counterTimer++;

                    if(this.counterTimer > this.maxCounterTimer)
                    {
                        switch(this.currentCrystal)
                        {
                            case "ninja" :
                                game.gameState = "play";
                                player.goto.doorSymbol = 'c';
                                player.goto.travelType = "door";
                                loader.startLoadLevel("ninjaTempleEntrance", "door");
                                return;

                            case "winter" :
                                game.gameState = "play";
                                player.goto.doorSymbol = 'a';
                                player.goto.travelType = "door";
                                loader.startLoadLevel("outerMountain", "door");
                                return;

                            case "underground" :
                                game.gameState = "play";
                                player.goto.doorSymbol = 'b';
                                player.goto.travelType = "door";
                                loader.startLoadLevel("DEEPBossRoom", "door");
                                return;
                        }

                        this.counting = false;
                    }
                }

                if(this.scenes["crystals"].buttons.warpToShip && this.scenes["crystals"].buttons.warpToShip.clicked(mouseX, mouseY) && 
                    (millis() - this.lastTryTime > 1000))
                {
                    game.gameState = "play";
                    player.goto.doorSymbol = 'a';
                    player.goto.travelType = "door";
                    loader.startLoadLevel("helixShip", "door");
                    this.lastTryTime = millis();
                }

                // Only have this button appear when the player has discovered their ship.
                if(typeof levels["desert oasis"].save === "object" && levels["desert oasis"].save.discoveredShip && 
                    typeof this.scenes["crystals"].buttons.warpToShip === "undefined")
                {
                    this.scenes["crystals"].buttons.warpToShip = this.warpToShip;
                }

                break;
        }

        for(var i in scene.buttons)
        {
            var btn = scene.buttons[i];
            if(btn.clicked(mouseX, mouseY))
            {
                btn.color = color(0, 30, 130, 100);
                btn.textColor = color(240, 240, 240, 100);
            }else{
                btn.color = btn.overrideColor || btn.firstColor;
                btn.textColor = color(240, 240, 240, 150);
            }
        }

        for(var i in this.menuButtons)
        {
            var btn = this.menuButtons[i];
            if(btn.clicked(mouseX, mouseY))
            {
                btn.color = color(0, 30, 130, 100);
                btn.textColor = color(240, 240, 240, 100);
            }else{
                btn.color = btn.firstColor;
                btn.textColor = color(240, 240, 240, 150);
            }
        }

        (this.oFuncs.update || function() {})(this.scenes[this.scene]);

        if(!mouseIsPressed || this.scenes[this.scene].remoteMode)
        {
            return;
        }

        if(this.menuButtons.items.clicked() && this.scene !== "items")
        {            
            this.close(this.scene);
            this.open("items", {
                init : function(scene)
                {
                    player.onOpenItems(scene, true);
                }, 
                close : function(scene)
                {
                    if(keys.e)
                    {
                        scene.highlightedButtonIndex = undefined;
                        return ["items", function()
                        {
                            game.switchGameState(true, "play", true); 
                        }];
                    }
                },
            }, true);
        }
        else if(this.menuButtons.home.clicked() && this.scene !== "home")
        {            
            this.close(this.scene);
            this.open("home", undefined, true);
        }
        else if(this.menuButtons.crystals.clicked() && this.scene !== "crystals")
        {
            this.close(this.scene);
            this.open("crystals", undefined, true);
            this.arrowKeysFadeTime = 100;
        }
    },
    draw : function()
    {
        
        var returned = (this.oFuncs.close || function() {})(this.scenes[this.scene]);

        if(returned && returned.length)
        {
            return this.close.apply(this, returned);
        }

        var scene = this.scenes[this.scene];

        $pjs.pushMatrix();
            translate(this.slideX, this.slideY);
            fill(0, 0, 0, 120);
            $pjs.rect(0, 0, width, height - 120, 10);

            textFont(this.font);
            textSize(14);
            textAlign(LEFT, TOP);
            fill(240, 240, 240, 200);
            text("Inventory", 12, 10);

            $pjs.pushMatrix();
                translate(this.scenes.slideX, this.scenes.slideY);
                switch(this.scene)
                {
                    case "home" :
                        fill(0, 0, 0, 90);
                        fastRect(0, 0, scene.width || this.scenes.width, scene.height || this.scenes.height + 30);

                        fill(12, 60, 160, 100);
                        fastRect(0, 0, scene.width || this.scenes.width, 26);

                        fill(240, 240, 240, 180);
                        text("Player                                  " + "Ability", 10, 5);
                        break;

                    case "chest" : case "items" : 
                        fill(0, 0, 0, 90);
                        fastRect(0, 0, scene.width || this.scenes.width, scene.height || this.scenes.height + 30);

                        fill(12, 60, 160, 100);
                        fastRect(0, 0, scene.width || this.scenes.width, 26);

                        fill(240, 240, 240, 180);
                        text("Items                                   " + ((this.scene === "chest") ? "Chest Items" : "Options"), 10, 5);
                        break;

                    case "crystals" :
                        fill(0, 0, 0, 90);
                        fastRect(0, 0, scene.width || this.scenes.width, scene.height || this.scenes.height + 30);

                        fill(12, 60, 160, 100);
                        fastRect(0, 0, scene.width || this.scenes.width, 26);

                        fill(240, 240, 240, 180);
                        text("Collected Crystals", 10, 5);

                        var crystals = player.crystals;

                        if(isEmpty(crystals))
                        {
                            fill(240, 240, 240, 100);
                            textSize(10);
                            text("You have not collected any crystals yet...", 10, 30);
                            break;
                        }

                        fill(240, 240, 240, this.arrowKeysFadeTime -= 0.8);
                        textSize(10);
                        text("[Arrow keys]", 10, 30);

                        $pjs.pushMatrix();
                            translate(170, 100);

                            if(this.autoAngle === undefined)
                            {
                                this.autoAngle = 0;
                            }

                            var toText = "";
                            var toFill = color(255, 255, 255, 140);

                            if(this.rDir === undefined)
                            {
                                this.rDir = random(-3, 3);
                            }

                            this.countedCrystals = 0;

                            for(var i in crystals)
                            {
                                if(typeof crystals[i].object === "object")
                                {
                                    this.countedCrystals++;
                                }
                            }

                            var a = 0;
                            for(var i in crystals)
                            {
                                a += 60;

                                if(this.countedCrystals >= 3)
                                {
                                    a += 60;
                                }

                                if(!crystals[i].object)
                                {
                                    crystals[i].object = new Crystal(0, 0, 30, { 
                                        kind : i.toString() 
                                    });
                                }

                                var oAngle = physics.formulas.resolveAngle(this.autoAngle + a);
                                crystals[i].object.xPos = sin(radians(oAngle)) * 50;
                                crystals[i].object.yPos = cos(radians(oAngle)) * 50;
                                crystals[i].object.draw();

                                if(this.countedCrystals >= 3)
                                {
                                    stroke(crystals[i].object.color);
                                    strokeWeight(2);
                                    line(0, 0, crystals[i].object.xPos, crystals[i].object.yPos);
                                    noStroke();
                                }

                                if(oAngle > 320 || oAngle < 40)
                                {
                                    toText = i.toString().upper();
                                    toFill = crystals[i].object.color;
                                    this.currentCrystal = i;
                                }
                            }

                            if(this.countedCrystals >= 3)
                            {
                                fill(0, 0, 0, 100);
                                if(this.warpClicked)
                                {
                                    fill(255, 255, 255, 100);
                                }
                                ellipse(0, 0, 50, 50);

                                fill(0, 0, 0, 150);
                                if(this.warpClicked)
                                {
                                    fill(255, 255, 255, 150);
                                }
                                arc(0, 0, 50, 50, (45) * DEG_TO_RAD, (45 + 180) * DEG_TO_RAD);

                                textAlign(CENTER, CENTER);
                                fill(255, 255, 255, 120);
                                if(this.warpClicked)
                                {
                                    fill(0, 0, 0, 120);
                                }
                                textSize(14);
                                text("warp", 0, 0);

                                if(this.countedCrystals >= 3 && this.warpClicked && this.counterTimer !== undefined)
                                {
                                    stroke(0, 0, 0, 200);
                                    strokeWeight(6);

                                    arc(0, 0, 44, 44, this.counterTimer * TWO_PI / this.maxCounterTimer, TWO_PI);

                                    noStroke();
                                }
                            }

                            this.goPressed = false;

                            if(keys[LEFT])
                            {
                                this.autoAngle -= 3;
                                this.rDir = 0;
                            }
                            else if(keys[RIGHT])
                            {
                                this.autoAngle += 3;
                                this.rDir = 0;
                            }else{
                                this.autoAngle += this.rDir;
                            }

                        $pjs.popMatrix();

                        fill(red(toFill), green(toFill), blue(toFill), 120);
                        textSize(14);
                        textAlign(CENTER, TOP);
                        text(toText, 170, 200);
                        textAlign(LEFT, TOP);

                        switch(toText.toLowerCase())
                        {
                            case "ninja" : 
                                scene.onHover = "A Ninja crystal! From your adventure in the Ninja Temple, after\ndefeating many Ninjas!";
                                break;

                            case "winter" : 
                                scene.onHover = "A Winter crystal! From your adventure in Icy Slopes, after\ndefeating an Ice Dragon!";
                                break;

                            case "underground" :
                                scene.onHover = "An Underground crystal! From your adventure in the Underground,\nafter defeating Captain Fleep --one of Talon's minions";
                                break;
                        }
                      
                        break;
                }

                if(this.scene === "items")
                {
                    noFill();
                    strokeWeight(0.5);
                    stroke(240, 240, 240, 170);

                    var imageFrame = {
                        xPos : (scene.width || this.scenes.width) - 75,
                        yPos : (scene.height || this.scenes.height) - 75,
                        width : 65,
                        height : 65,
                    };

                    fastRect(imageFrame.xPos, imageFrame.yPos, imageFrame.width, imageFrame.height);
                    noStroke();

                    var itemImg;

                    try{
                        itemImg = usableItems[player.inventory.items[scene.buttons["player_" + scene.highlightedButtonIndex].index].contains].image;
                    }
                    catch(e) { }

                    if(itemImg)
                    {
                        var wratio = imageFrame.width / imageFrame.height, ratio = itemImg.width / itemImg.height;
                         
                        if(wratio < ratio) 
                        {
                            image(itemImg, imageFrame.xPos, imageFrame.yPos, imageFrame.width, (imageFrame.width / ratio));
                        }else{
                            image(itemImg, imageFrame.xPos, imageFrame.yPos, (imageFrame.height * ratio), imageFrame.height);
                        }
                    }
                }

                (this.oFuncs.draw || function() {})(this.scenes[this.scene]);

                var drawnText = false;
                if(scene.buttons && !scene.noBar)
                {
                    fill(0, 0, 0, 100);
                    $pjs.rect(78, -35, (scene.width || this.scenes.width) - 18, 30, 6);

                    textSize(10);
                    fill(240, 240, 240, 180);

                    for(var i in scene.buttons)
                    {
                        var btn = scene.buttons[i];
                        if(btn.clicked(mouseX, mouseY))
                        {
                            text((btn.type || "") +  " - " + (btn.hover || ""), 84, /*(scene.height || this.scenes.height) +*/ -31.5, (scene.width || this.scenes.width) - 5, 30);
                            drawnText = true;
                        }
                    }

                    if(!drawnText && scene.onHover)
                    {
                        text(scene.onHover, 84, -31.5, (scene.width || this.scenes.width) - 5, 30);
                    }
                }
            $pjs.popMatrix();
        $pjs.popMatrix();

        if(this.state === "opened")
        {
            var scene = this.scenes[this.scene];

            if(scene.buttons)
            {
                textSize(10);
                
                for(var i in scene.buttons)
                {
                    scene.buttons[i].draw();
                }
            }

            if(!this.scenes[this.scene].remoteMode)
            {
                for(var i in this.menuButtons)
                {
                    this.menuButtons[i].draw();
                }
            }
        }
    },
};

// The ship's control panel
var controlPanel = {    

    gems : {
        required : 10,
        max : 20, // This value is how many gems are in the game.
    },

    state : "closed",
    open : function()
    {
        this.state = "opened";
    },
    close : function()
    {
        this.state = "closed";
    },
    update : function()
    {

    },
    font : createFont("arial"),
    slideX : 0,
    slideY : 60,
    buttons : {
        launch : new Button(80, 120, 240, 26, color(12, 60, 160, 130), "Launch"),
        pilot : new Button(160, 170, 80, 26, color(12, 60, 160, 130), "Pilot"),  
    },
    draw : function()
    {
        $pjs.pushMatrix();
            translate(this.slideX, this.slideY);
            fill(0, 0, 60, 120);
            $pjs.rect(0, 0, width, height - 120, 10);

            fill(0, 0, 0, 120);
            $pjs.rect(20, 20, width - 40, height - 160, 10);

            textFont(this.font);
            textSize(14);
            textAlign(LEFT, TOP);
            fill(240, 240, 240, 200);
            text("Ship Control Panel", 12, 10);
        $pjs.popMatrix(); 

        if(!this.drawInit)
        {
            this.buttons.launch.textColor = color(255, 255, 255, 200);
            this.buttons.pilot.textColor = color(255, 255, 255, 200);

            this.drawInit = true;
        }

        this.buttons.launch.disabled = (player.gems < this.gems.required || shipGoto.inSpace);

        for(var i in this.buttons)
        {
            if(typeof this.buttons[i] === "object")
            {
                if(!shipGoto.inSpace && i === "pilot")
                {
                    continue;
                }

                this.buttons[i].draw();

                if(this.buttons[i].disabled)
                {
                    fill(0, 0, 0, 100);
                    $pjs.rect(this.buttons[i].xPos, this.buttons[i].yPos, this.buttons[i].width, this.buttons[i].height, this.buttons[i].round);
                }
            }
        }

        this.buttons.launch.message = "Launch Gems " + (player.gems || 0) + " of " + this.gems.required + " required of " + this.gems.max + " total";
    },
    mousePressed : function()
    {
        for(var i in this.buttons)
        {
            if(typeof this.buttons[i] === "object" && this.buttons[i].clicked())
            {
                if(this.buttons[i].disabled || !shipGoto.inSpace && i === "pilot")
                {
                    continue;
                }

                switch(i)
                {
                    case "pilot" :
                        this.close();

                        game.switchGameState(true, "play", true);

                        game.disablePause = true;
                        setTimeout(function()
                        {
                            loader.startLoadLevel("space", "ship", 0, function()
                            {
                                cameraGrid.removeReference(player);

                                var helixShip = gameObjects.getObject("helixShip")[0];

                                cam.attach(function()
                                {
                                    return helixShip;             
                                }, true);

                                game.disablePause = false;
                            });
                        }, 1000);
                        break;

                    case "launch" :
                        if(!shipGoto.launched)
                        {
                            this.close();

                            game.disablePause = true;
                            game.switchGameState(true, "play", true);

                            setTimeout(function()
                            {
                                shipGoto.launch();

                                game.disablePause = false;
                            }, 1000);
                        }
                        break;
                }
            }
        }
    }
};

var _this = this;

var debugTool = {
    textBox : new TextBox(0, height - 20, width, 20, color(0, 0, 0, 170), color(56, 56, 56), color(255, 255, 255, 150)),
    apply : function()
    {
        this.textBox.selected = this.active;

        if(!this.active)
        {
            return;
        }

        this.update();
        this.draw();
    },
    activate : function(input)
    {
        try{
            var s = "gameObjects, game, keys, screenUtils, loader, inventoryMenu, debugTool, physics, observer, buttons, cam";
            var a = [window.processing, gameObjects, game, keys, screenUtils, loader, inventoryMenu, physics, observer, buttons, window.cam];
            var func = ("return function any(p," + s +")\n{\n" + input.toString() + "\n};");
            return new Function(func)().apply(_this, a);
        }
        catch(e)
        {
            console.log("Error: " + e);
        }
    },
    update : function()
    {
        if(ENTER_KEY)
        {
            this.activate(this.textBox.input.join(""));
            ENTER_KEY = false;
        }
    },
    draw : function()
    {
        this.textBox.draw();
    }, 
    keyPressed : function()
    {
        if(!this.active || ENTER_KEY)
        {
            return;
        }

        this.textBox.edit();
    },
    setup : function()
    {
        this.textBox.maxLength = Infinity;
    }
};

var screenUtils = {
    fade : new graphics.Fade(color(0, 0, 0)),

    getSourceImg: function(img)
    {
        var canv = document.createElement("canvas");
        var cont = canv.getContext('2d');

        // Set width, height and operation
        canv.width = img.width;
        canv.height = img.height;
        cont.globalCompositeOperation = 'source-over';

        // cd_ctx.clearRect(0, 0, img.width, img.height);
        cont.putImageData(img.toImageData(), 0, 0);

        return canv;
    },
    speedUpImage: function(img)
    {
        img.sourceImg = this.getSourceImg(img);
        // img.__isDirty = false;

        return img;
    },

    load : function() {},
    shakeScreen : function(intensity, time)
    {
        if(screenUtils.shakeScreen.noShake === undefined)
        {
            screenUtils.shakeScreen.noShake = false;
        }

        if(this.timer === undefined)
        {
            this.timer = 0;
        }

        if(screenUtils.shakeScreen.noShake)
        {
            return;
        }

        this.timer++;

        if(this.timer >= time)
        {
            // Shake
            translate(random(-intensity, intensity), random(-intensity, intensity));
            this.timer = 0;
        }
    },
    shakeOffX : 0,
    shakeOffY : 0,
    lastShakeTime : millis(),
    shakeTime : 0,
    lastShakeChangeTime : 0,
    newShakeScreen : function(time, intensityX, intensityY, shakeInterval)
    {
        this.shakeTime = time;
        this.intensityX = intensityX;
        this.intensityY = intensityY;

        this.lastShakeTime = millis();
        this.shakeInterval = shakeInterval || 0;
    },
    manageShake : function()
    {
        if(millis() - this.lastShakeTime > this.shakeTime)
        {
            this.shaking = false;
            this.shakeOffX = 0;
            this.shakeOffY = 0;
            this.shakeTime = 0;
            return;
        }

        this.shaking = true;

        if(!this.shakeInterval || millis() - this.lastShakeChangeTime > this.shakeInterval)
        {
            this.shakeOffX = random(-this.intensityX, this.intensityX);
            this.shakeOffY = random(-this.intensityY, this.intensityY);

            sounds.playSound("rumble.mp3");

            this.lastShakeChangeTime = millis();
        }

        if(this.shakeOffX && this.shakeOffY)
        {
            translate(this.shakeOffX, this.shakeOffY);
        }
    },
    rumble : function()
    {
        if(!sounds.getSound("rumble.mp3").paused)
        {
            screenUtils.shakeScreen(5, 4);
        }
    },
    debugCameraGrid : {
        draw : function()
        {
            if(game.debugMode && mouseIsPressed && game.gameState === "play" && mouseButton === RIGHT && 
                player.discoveredPowersHandler.currentPower !== "hookShot")
            {
                cameraGrid.draw();
                cursor(CROSS);
                game.cursor = CROSS;
            }
        },
        update : function()
        {
            if(game.debugMode && mouseIsPressed && game.gameState === "play" && mouseButton === RIGHT && 
                player.discoveredPowersHandler.currentPower !== "hookShot")
            {
                try{
                    var place = cameraGrid.getPlace((cam.focusXPos - cam.halfWidth) + mouseX, (cam.focusYPos - cam.halfHeight) + mouseY);
                    var cell = cameraGrid[place.col][place.row];
                    
                    textAlign(NORMAL, NORMAL);
                    fill(0, 0, 0, 150);
                    if(screenUtils.debugMenuWhite)
                    {
                        fill(255, 255, 255, 100);
                    }
                    text(place.col + ", " + place.row, 10, 85);

                    var txt = "";
                    for(var i in cell)
                    {
                        txt += i.toString() + "\n";
                    }

                    text(txt, 10, 96);
                }
                catch(e)
                {
                    console.warn(e);
                }
            }
        },
    },
    withCamera : function()
    {
        this.debugCameraGrid.draw();
        this.inverseCircle();
    },
    filterLevel : function(level)
    {
        var lvl = level;

        if(lvl !== levelInfo.theme && levelInfo.theme !== undefined)
        {
            lvl = lvl.replace(levelInfo.theme, "...");
        }

        return lvl;
    },
    infoBar : {
        keysYPos : 0,
        keysYVel : 0,
        keysMaxYVel : 5,
        showKeys : true,
        height : graphics.infoBarProps.height,
        healthMeter : new Bar(0, 0, 100, graphics.infoBarProps.height - 1, color(34, 190, 51, 80), 10),
        defenseMeter : new Bar(-2, height - 14, 100, graphics.infoBarProps.height - 1, color(0, 95, 150, 220), 10, undefined, color(250, 250, 250, 50)),
        pads : true,
        padY : 0,
        bossBar : new Bar(0, height - 6, width, 6, color(17, 183, 40, 200), 10),
        airMeter : new Bar(150, 80, 100, graphics.infoBarProps.height - 1, color(4, 84, 172, 200), 10),
        helixShipBar : new Bar(0, 16, width, 2, color(0, 178, 254, 100), 0),
        showBottomHud : true,
        lastShowTime : 0,
        draw : function(noLives)
        {
            fill(0, 0, 0, 80);
            noStroke();
            fastRect(0, 0, width, screenUtils.infoBar.height);
            screenUtils.infoBar.healthMeter.draw();
            
            screenUtils.infoBar.healthMeter.set(player.hp, player.maxHp);
            screenUtils.infoBar.defenseMeter.set(player.defense, player.maxDefense);
            
            var airMeter = screenUtils.infoBar.airMeter;

            airMeter.using = (!player.breathing || player.air < player.maxAir);

            if(!airMeter.first)
            {
                airMeter.width = 0;
                airMeter.halfWidth = 0;
                airMeter.first = true;
            }

            if(airMeter.using)
            {
                if(airMeter.width < airMeter.defaultWidth)
                {
                    airMeter.width += 4;
                }
            }
            else if(airMeter.width > 0)
            {
                airMeter.width -= 4;
            }

            airMeter.width = constrain(airMeter.width, 0, airMeter.defaultWidth);
            airMeter.halfWidth = airMeter.width / 2;

            airMeter.xPos = HALF_WIDTH - airMeter.halfWidth;
            var between = airMeter.width > 0 && airMeter.width < airMeter.defaultWidth;

            if((between || airMeter.using) && !player.bubbleShield && !messageHandler.active && game.gameState !== "inventoryMenu")
            {
                if(player.air > 0 || millis() % 750 >= 375)
                {
                    if((millis() + 400) % 40 > 22 || between || !airMeter.msg)
                    {
                        airMeter.set(round(player.air), player.maxAir);
                        airMeter.msg = ("Oxygen " + Math.round(player.air) + "/" + player.maxAir);
                    }

                    airMeter.draw();

                    var messageArray = airMeter.msg.split("");
                    var firstLength = messageArray.length;
                    messageArray.length = floor(airMeter.width * (firstLength + 1) / airMeter.defaultWidth);
                    var msg = messageArray.join("");

                    fill(250, 250, 250, airMeter.width * 100 / airMeter.defaultWidth);
                    textAlign(LEFT, CENTER);
                    textSize(10);
                    text(msg, airMeter.xPos + 3, airMeter.yPos + airMeter.halfHeight);
                }
            }

            textAlign(CENTER, CENTER);
            fill(0, 0, 0, 100);
            textFont(graphics.infoBarProps.font);
            textSize(11);
            
            fill(0, 12, 12, 50);
            $pjs.rect(1, 0, 70, screenUtils.infoBar.height, 10);

            /* Inject font */
            textFont(inventoryMenu.font);
            
            fill(230, 230, 230, 100);
            text("Hp " + (floor(max((player.hp || 0), 0))) + "/" + player.maxHp, 34, screenUtils.infoBar.height - 8);
            
            textAlign(NORMAL, CENTER);
            fill(0, 12, 12, 150);
           
            var sp = "    ";

            if(player.coins)
            {
                if(player.coins > 999)
                {
                    sp = sp.slice(0, -1);
                }
                else if(player.coins > 9999)
                {
                    sp = sp.slice(0, -2);
                }
            }

            var csText = "Coins " + (player.coins || 0) + sp + "Score " + (player.score || 0);

            $pjs.rect(125, 0, textWidth(csText) + 12, screenUtils.infoBar.height, 10);
            fill(230, 230, 230, 100);

            text(csText, 130, screenUtils.infoBar.height - 8);
            
            var lvl = screenUtils.filterLevel(levelInfo.level);

            fill(0, 12, 12, 150);
            $pjs.rect(281, 0, max(/*85*/ 55, textWidth("Level " + (lvl || 0) + 10)), screenUtils.infoBar.height, 10);
            fill(230, 230, 230, 100);
            textAlign(LEFT, CENTER);
            text("Level " + (lvl || 0), 286, screenUtils.infoBar.height - 8);

            var flashLightUpgrade = player.discoveredPowers.flashLightUpgrade;

            if(typeof flashLightUpgrade === "object" && flashLightUpgrade.timer !== 0)
            {
                noStroke();

                if(flashLightUpgrade.dir === "up")
                {
                    fill(255, 255, 255, 230);
                }
                else if(flashLightUpgrade.dir === "down")
                {
                    fill(214, 34, 45, 230);
                }else{
                    fill(0, 0, 0, 50);
                }

                screenUtils.doFlash = flashLightUpgrade.flashing;
                
                if(flashLightUpgrade.timer === flashLightUpgrade.maxTime)
                {
                    if(millis() - this.lastShowTime > 250)
                    {
                        this.showThis = !this.showThis;

                        this.lastShowTime = millis();
                    }
                }else{
                    this.showThis = true;
                }

                if(this.showThis)
                {
                    $pjs.rect(316, 340, flashLightUpgrade.timer * 70 / flashLightUpgrade.maxTime, 14);
                }
                noFill();
                stroke(0, 0, 0, 150);
                strokeWeight(2);
                $pjs.rect(316, 340, 70, 14);

                noStroke();
            }

            if(player.defense > 0)
            {
                $pjs.pushMatrix();
                    translate(0, this.padY);
                    this.defenseMeter.draw();

                    fill(255, 255, 255, 105);
                    textAlign(LEFT, TOP);
                    text(player.defense + "/" + player.maxDefense + "% defense", 5, height - 12);
                $pjs.popMatrix();

                if(this.padding)
                {
                    this.padY += ((this.pads) ? -3 : 3);
                }

                this.padY = constrain(this.padY, 0, 60);
            }

            if((levelScripts[levelInfo.level] || {}).battling)
            {
                var helixShip = gameObjects.getObject("helixShip").input(0);

                if(!helixShip.fake)
                {
                    this.helixShipBar.set(helixShip.hp, helixShip.maxHp);
                    this.helixShipBar.color = color(0, 178, 254, 100);
                    this.helixShipBar.draw();
                    this.helixShipBar.noStroke = true;
                }
            }

            if(typeof this.bossArrayName !== "undefined")
            {
                var boss = gameObjects.getObject(this.bossArrayName).input(0);
                if(!boss.fake)
                {
                    this.bossBar.set(boss.hp, boss.maxHp);
                    this.bossBar.color = (boss.hp <= (boss.redHp || 5)) ? color(200, 25, 25, 190) : color(17, 183, 40, 200);
                    this.bossBar.draw();
                    this.bossBar.noStroke = true;

                    if(!boss.outArrayName)
                    {
                        var words = this.bossArrayName.split(/(?=[A-Z])/); 
                        boss.outArrayName = words[0].charAt(0).toUpperCase() + words[0].slice(1) + " " + words.slice(1, words.length).join(" ");
                    }

                    var txt = boss.hp + "/" + boss.maxHp + " hp " + boss.outArrayName;

                    fill(0, 0, 0, 100);
                    $pjs.rect(0, 385, 5 + textWidth(txt) + 12, 400, 7);
                    fill(255, 255, 255, 200);
                    textAlign(LEFT, DOWN);
                    /* Inject font */
                    textFont(inventoryMenu.font);
                    text(txt, 5, 397);
                }
            }
            else if(this.showBottomHud)
            {
                textSize(11);
                
                if(configs[levelInfo.theme] && configs[levelInfo.theme].name !== undefined)
                {
                    textAlign(LEFT, DOWN);
                    /* Inject font */
                    textFont(inventoryMenu.font);

                    fill(0, 0, 0, 130);
                    $pjs.rect(-6, height - 15, 25 + textWidth(configs[levelInfo.theme].name), 30, 5);
                    fill(240, 240, 240, 145);
                    text(configs[levelInfo.theme].name, 8, height - 3);
                }

                 /* Inject font */
                textFont(inventoryMenu.font);

                $pjs.pushMatrix();
                    translate(20, 0);

                    var powerKeys = [];
                    var txt = "";
                    for(var i in player.discoveredPowers)
                    {
                        if(!player.discoveredPowers[i].key)
                        {
                            continue;
                        }

                        txt += "   ";

                        powerKeys.push(player.discoveredPowers[i].key);
                    }
                    powerKeys.reverse();

                    fill(0, 0, 0, 130);
                    $pjs.rect(width + 2 - textWidth(txt + "   E") - 40, height - 15, 100, 30, 5);

                    var powerString = player.discoveredPowersHandler.currentPower;

                    var c = 0;

                    var str = player.discoveredPowersHandler.currentPower;
                    var isKey = false;
                    for(var i = 0; i < powerKeys.length; i++)
                    {
                        c++;
                        isKey = (powerKeys[i] === (player.discoveredPowers[str] || {}).key);

                        fill(isKey ? color(240, 240, 240, 180) : color(240, 240, 240, 145));

                        textAlign(LEFT, DOWN);
                        text(powerKeys[i], width - 38 - c * textWidth(powerKeys[i] + "  "), height - 3);

                        if(isKey)
                        {
                            text("_", width - 38 - c * textWidth(powerKeys[i] + "  "), height - 2);
                        }
                    }

                    fill(240, 240, 240, 145);
                    textAlign(RIGHT, DOWN);
                    text(txt + "   E", width - 27, height - 3);

                    var saved = false;
                    var checkpoints = gameObjects.getObject("checkPoint");

                    for(var i = 0; i < checkpoints.length; i++)
                    {
                        if(checkpoints[i].checked)
                        {
                            saved = true;
                            break;
                        }
                    }
                $pjs.popMatrix();
            }

            textAlign(LEFT, CENTER);

            if(!game.hideKeys && player.goto !== undefined && player.goto.keysHolding !== undefined)
            {
                this.keysYPos += this.keysYVel;

                var j = 0;
                var xOff = 5;
                var yOff = 60 - (this.lastJ - 1) * 30 + this.keysYPos;

                for(var i in player.goto.keysHolding)
                {
                    if(player.goto.keysHolding[i] === undefined)
                    {
                        continue;
                    }

                    var x = j * 34;
                    var inputText = player.goto.keysHolding[i].level + ",\nDoor " + player.goto.keysHolding[i].symbol;
                    fill(0, 12, 12, 150);
                    var xOff2 = -(textWidth(inputText) - 35);


                     $pjs.rect(330 + xOff + xOff2, 290 + yOff + x, textWidth(inputText) + 27, 31, 10);
                    if(player.goto.keysHolding[i].style === "boss")
                    {   
                        (function(x, y, w, h)
                        {
                            var unitW = w / 3;
                            var unitH = h / 6;
                            var unitW2 = unitW * 2;
                            var unitH2 = unitH * 2;

                            noStroke();
                            fill(35, 210 - 60, 160);
                            fastRect(x + unitW * 2, y + 4 * unitH, 0.6 * unitW, unitH * 0.7);
                            fastRect(x + unitW * 2, y + 5.3 * unitH, unitW, unitH * 0.7);
                            fill(35, 210, 70);
                            fastRect(x + unitW, y + unitH * 3, unitW, unitH * 3);
                            fill(35, 210 - 80, 160);
                            fastRect(x, y, unitW2, unitH);
                            fill(35, 210 - 60, 160);
                            fastRect(x + unitW2, y, unitW, unitH2);
                            fill(35, 210 - 40, 160);
                            fastRect(x + unitW, y + unitH2, unitW2, unitH);
                            fill(35, 210 - 20, 160);
                            fastRect(x, y + unitH, unitW, unitH2);
                        })(336 + xOff + xOff2, 297 + yOff + x, 9, 18);
                    }else{
                        shapes.key(336 + xOff + xOff2, 297 + yOff + x, 9, 18);
                    }

                    fill(230, 230, 230, 100);
                    text(inputText, 350 + xOff + xOff2, 305 + yOff + x);
                    j++;
                }
                this.lastJ = j;
                this.xOff = xOff;
                this.yOff = yOff;

                if(this.showKeys)
                {
                    this.keysYVel -= 0.3;
                    if(this.keysYVel < -this.keysMaxYVel)
                    {
                        this.keysYVel = -this.keysMaxYVel;
                    }
                }else{
                    this.keysYVel += 0.3;
                    if(this.keysYVel > this.keysMaxYVel)
                    {
                        this.keysYVel = this.keysMaxYVel;
                    }
                }

                if(this.keysYPos < 20)
                {
                    this.keysYPos = 20;
                }
                if(this.keysYPos > 40 + (this.lastJ - 1) * 30)
                {
                    this.keysYPos = 40 + (this.lastJ - 1) * 30;
                }
            }
        },
        mouseReleased : function()
        {
            if(mouseX > 330 + this.xOff && mouseX < 330 + this.xOff + 80 && mouseY > ((this.showKeys) ? 305 + this.yOff - 20 : 380))
            {
                this.showKeys = !this.showKeys;
                this.keysYVel = 0;
            }

            if(mouseX < Math.max(this.defenseMeter.halfWidth, this.defenseMeter.input) && mouseY > height - 18)
            {
                this.pads = !this.pads;
                this.padding = true;
            }
        },
    },
    needsScreenShot : false,
    takeScreenShot : function(w, h)
    {
        if(this.needsScreenShot)
        {
            this.screenShot = get(0, 0, w || width, h || height);
            this.needsScreenShot = false;
        }
    },
    // Use this after defining the draw method in a gameObject
    letImage : function(object, name, pro)
    {
        object.imageName = name;
        object.draw = (pro) ? function()
        {
            image(storedImages[this.imageName], this.xPos, this.yPos, this.width, this.height);
        } :
        function()
        {
            image(storedImages[this.imageName], this.xPos, this.yPos);
        };
    },
    speedLetImage : function(object, name, pro)
    {
        // screenUtils.speedUpImage(storedImages[name]);

        accelerateImg(storedImages[name]);

        object.imageName = name;
        object.draw = (pro) ? function()
        {
            var img = storedImages[this.imageName];

            if (img.__isDirty) {
              img.updatePixels();
            }

            ctx.drawImage(img.sourceImg, 0, 0, img.sourceImg.width, img.sourceImg.height,
                                 Math.round(this.xPos), Math.round(this.yPos), this.width, this.height);
        } :
        function()
        {
            var img = storedImages[this.imageName];

            if (img.__isDirty) {
              img.updatePixels();
            }

            ctx.drawImage(img.sourceImg, 0, 0, img.sourceImg.width, img.sourceImg.height,
                                 Math.round(this.xPos), Math.round(this.yPos), img.width, img.height);
        };
    },
    loadImage : function(object, constImage, name, notRect, customBackColor, ref, tone, pro)
    {
        //Constant Image is for images that do not change, we store them
        if(constImage && storedImages[name || object.arrayName] !== undefined)
        {
            screenUtils.speedLetImage(object, name || object.arrayName);
            return storedImages[name || object.arrayName];
        }

        /*We cannot replace pixels in ka mode due to the 
        way the framework works differently*/
        if(notRect && MODE === "ka")
        {
            return;
        }

        /*It doesn't matter what the color is as long as we 
        don't use it in images we load*/
        var backColor = customBackColor || color(255, 255, 255);

        //Get image process
        noStroke();
        fill(backColor);
        fastRect(0, 0, object.width, object.height);
        var lastXPos = object.xPos;
        var lastYPos = object.yPos;
        object.xPos = 0;
        object.yPos = 0;
        if(object.setDraw !== undefined)
        {
            object.setDraw();
        }
        object[ref || "draw"]();
        var img = get(0, 0, object.width, object.height);
        object.xPos = lastXPos;
        object.yPos = lastYPos;

        if(tone !== undefined)
        {
            var _pixels = img.pixels.toArray();
            for(var i = 0; i < _pixels.length; i++)
            {
                img.pixels.setPixel(i, color(red(_pixels[i]), green(_pixels[i]), blue(_pixels[i]), tone));
            }
        }

        if(notRect)
        {
            //Only works for images without curves or angles, if you do have these use createGraphics instead
            pixelFuncs.replacePixels(img, backColor, color(255, 255, 255, 0));
        }

        //Store image
        if(constImage)
        {
            storedImages[name || object.arrayName] = img;
        }

        // screenUtils.letImage(object, name || object.arrayName, pro);

        screenUtils.speedLetImage(object, name || object.arrayName, pro);

        return storedImages[name || object.arrayName];
    },
    debugMode : function()
    {
        if(!game.debugMode)
        {
            return;
        }
        
        textSize(11);
        
        //Debug menu

        /* Inject font */
        textFont(inventoryMenu.font);
        
        fill(!lighting.working ? color(0, 0, 0, 200) : color(255, 255, 255, 100));
        if(screenUtils.debugMenuWhite)
        {
            fill(255, 255, 255, 100);
        }
        textAlign(NORMAL, NORMAL);
        text("xPos " + player.xPos.toFixed(2), 10, 30);
        text("yPos " + player.yPos.toFixed(2), 10, 44);
        if(game.showDebugPhysics)
        {
            text("xVel " + player.xVel.toFixed(2), 10, 58);
            text("yVel " + player.yVel.toFixed(2), 10, 72);
            text("inAir " + player.inAir, 10, 72 + 14);
            text("hp " + player.hp.toFixed(2), 10, 72 + 14 * 2);
            text("Friction " + player.friction.toFixed(2), 10, 72 + 14 * 3);
            text("xAcl " + player.xAcl.toFixed(2), 10, 72 + 14 * 4);
            text("maxXVel " + player.maxXVel.toFixed(2), 10, 72 + 14 * 5);
        }
        text(game.version, 330, 30);
        textAlign(CENTER, NORMAL);
        text("sfps " + game.fps + " fps " + fpsCatcher.actualFps + " s " +  second() + " " + game.fpsType.split("")[0], 200, 30);
    },
    loadingScreenBar : new Bar(0, height - 6, width, 6, color(34, 190, 51, 100), 10),
    noB : 0,
    loadingScreen : function()
    {
        if(game.cutScening)
        {
            return;
        }

        if(game.gameState === "load")
        {
            keys[32] = false; // Stop from double spacing the story screen

            if(this.noB < 20)
            {
                this.loadingScreenBar.set(loader.loops, loader.estLoops);
                $pjs.pushMatrix();
                    translate(this.noB * 20, this.noB / 3);
                    this.loadingScreenBar.draw();
                $pjs.popMatrix();
                this.loadingScreenBar.noStroke = true;

                if(loader.loops >= loader.estLoops)
                {
                    this.noB++;
                }
            }

            if(screenUtils.fade.full() && game.debugMode)
            {  
                fill(250, 250, 250, 100);
                textSize(13);
                textAlign(NORMAL, CENTER);
                if(loader.point !== undefined)
                {
                    loader.point += 0.075;  
                    text(min(floor(loader.loops * 100 / loader.estLoops), 100) + "%" + 
                        ([".", "..", "...", ""][min(floor(loader.point), 3)]), 340, 370);  
                    if((loader.point) >= 4)
                    {
                        loader.point = 0;  
                    }
                }
            }
        }else{
            this.noB = 0;
        }
    },
    inverseCircle : function()
    {
        if(!this.useInverseCircle)
        {
            return;
        }

        
        noFill();
        stroke(0, 0, 0);
        strokeWeight(460);
        circle(physics.getMiddleXPos(player), physics.getMiddleYPos(player), 650);
    },
    mouseReleased : function()
    {
        if(game.gameState === "play")
        { 
            if(messageHandler.active)
            {
                talkHandler.mouseReleased();
            }
            this.infoBar.mouseReleased();
        }
    },
    fixDisappearences : function()
    {
        if(firstGameState !== "start")
        {
            return;
        }

        if(!this.doStop && (game.gameState !== "start" || game.tempState === "start") && !this.fade.full())
        {
            game.start();
            if(game.gameState === "start")
            {
                this.doStop = true;
            }
        }
        else if(!this.doStop2 && (game.gameState === "load" || game.tempState === "menu") && 
        (!screenUtils.fade.fading || screenUtils.fade.timerVel < 0))
        {
            backgrounds.drawBackground(); //Make sure we're rendering the correct background
            game.menu();
            if(game.gameState === "menu")
            {
                this.doStop2 = true;
            }
        }
        if(!this.doStop3)
        {
            if(game.gameState === "selectSaveFile")
            {
                game.pegState = game.gameState;
            }
            if((game.gameState === "load" && game.pegState === "selectSaveFile") && screenUtils.fade.fading)
            {
                game.selectSaveFile();
                if(screenUtils.fade.timerVel < 0)
                {
                    this.doStop3 = true;
                }
            }
        }
    },  
    showErrors : function()
    {
        if(game.errorTripped || this.errorBlinkTime === undefined)
        {
            this.errorBlinkTime = performance.now();
        }

        var lastErrorTime = performance.now() - this.errorBlinkTime;

        if(game.errors > 0 && lastErrorTime >= 100 && lastErrorTime <= 3000)
        {
            fill(255, 25, 25, 125);
            textSize(14);
            text(game.errors + "!", 380, 360);
        }
    },
    messages : [],
    createMessage : function(message, xPos, yPos, width, height, config)
    {
        config = config || {};
        textSize(config.textSize);
        textFont(config.font || createFont("arial"));
        width = width || textWidth(message) * 1.25;

        this.messages.push({
            message : message,

            xPos : xPos - width / 2, 
            yPos : yPos - height / 2,

            width : width,
            height : height,

            halfWidth : width / 2,
            halfHeight : height / 2,

            leftXPos : xPos,
            defaultWidth : width,

            color : config.colorValue || color(0, 0, 0, 120),
            defaultColor : config.colorValue || color(0, 0, 0, 120),

            textColor : config.textColor || color(250, 250, 250, 200),
            defaultTextColor : config.textColor || color(250, 250, 250, 200),

            time : config.time || 1500,
            openCloseTime : 500,
            startTime : millis(),

            state : "opening",
            font : config.font || createFont("arial"),
            textSize : config.textSize || 14,
        });
    },
    updateMessages : function()
    {
        for(var i = 0; i < this.messages.length; i++)
        {
            var msg = this.messages[i];

            var textColor = msg.textColor;
            var rectColor = msg.color;

            switch(msg.state)
            {
                case "opening" : 
                    var diff = millis() - msg.startTime;

                    if(diff > msg.openCloseTime)
                    {
                        msg.startTime = millis();
                        msg.state = "waiting";
                    }else{
                        rectColor = color(red(rectColor), 
                                          blue(rectColor), 
                                          green(rectColor), 
                                          alpha(rectColor) * diff / msg.openCloseTime);

                        textColor = color(red(textColor), 
                                          blue(textColor), 
                                          green(textColor), 
                                          alpha(textColor) * diff / msg.openCloseTime);

                        msg.width = msg.defaultWidth * diff / msg.openCloseTime;
                        msg.halfWidth = msg.width / 2;
                        msg.xPos = msg.leftXPos - msg.halfWidth;
                    }
                    break;

                case "waiting" :
                    if(millis() - msg.startTime > msg.time)
                    {
                        msg.startTime = millis();
                        msg.state = "closing";
                    }
                    break;

                case "closing" :
                    var diff = millis() - msg.startTime;

                    if(diff > msg.openCloseTime)
                    {
                        this.messages.splice(i, 1);
                    }else{
                        var between = (msg.openCloseTime - diff);

                        rectColor = color(red(rectColor), 
                                          blue(rectColor), 
                                          green(rectColor), 
                                          alpha(rectColor) * between / msg.openCloseTime);

                        textColor = color(red(textColor), 
                                          blue(textColor), 
                                          green(textColor), 
                                          alpha(textColor) * between / msg.openCloseTime);

                        msg.width = msg.defaultWidth * between / msg.openCloseTime;
                        msg.halfWidth = msg.width / 2;
                        msg.xPos = msg.leftXPos - msg.halfWidth;
                    }
                    break;
            }

            if(millis() - msg.startTime < 50 && msg.state === "opening" || 
                millis() - msg.startTime > msg.openCloseTime - 50 && msg.state === "closing")
            {
                return;
            }

            if(typeof msg.message === "undefined")
            {
                return;
            }

            var messageArray = msg.message.split("");
            var firstLength = messageArray.length;
            messageArray.length = min(firstLength, floor(msg.width * (firstLength + 1) / msg.defaultWidth));
            var msgText = messageArray.join("");

            fill(rectColor);
            $pjs.rect(msg.xPos, msg.yPos, msg.width, msg.height, 10);

            fill(red(textColor), green(textColor), blue(textColor), min(180, alpha(textColor)));
            textSize(msg.textSize);
            textAlign(CENTER, CENTER);
            text(msgText, msg.xPos + msg.halfWidth, msg.yPos + msg.halfHeight);
        }
    },
    update : function()
    {
        if(!processing.scaled)
        {
            this.takeScreenShot();
        }else{
            this.takeScreenShot(screen.width, screen.height);
        }
        this.fixDisappearences();

        if(game.gameState === "inventoryMenu" || game.gameState === "play" || game.gameState === "credits" || game.gameState === "pauseMenu" || 
          ((game.tempState === "play" || game.tempState === "load") && game.gameState === "load" && !screenUtils.fade.full()))
        {
            messageHandler.draw();

            if(game.gameState !== "credits")
            {
                this.infoBar.draw();

                if(game.gameState !== "inventoryMenu")
                {
                    this.debugMode();
                }
            }
        }

        if(game.gameState === "inventoryMenu" || game.gameState === "play" || 
          (game.tempState === "play" && game.gameState === "load") || (screenUtils.fade.vel > 0 && screenUtils.fade.fading && !screenUtils.fade.full()))
        {
            noStroke();
            fill(levelInfo.levelShade);
            fastRect(0, 0, width, height);
        }

        this.showErrors();

        if(game.gameState === "play" || game.gameState === "credits")
        {
            this.updateMessages();
        }

        this.fade.draw();

        if(game.fps === 30)
        {
            this.fade.draw();
        }

        if(game.switchedState && this.fade.full())
        {
            game.gameState = game.switchState; 
            game.switchedState = false;
        }

        this.debugCameraGrid.update();
        this.loadingScreen();
        fpsCatcher.update();

        if(levelInfo.rumble !== undefined && millis() - this.lastRumbleTime > this.intervalRumbleTime)
        {
            screenUtils.newShakeScreen(500, levelInfo.rumble, levelInfo.rumble, 26);
            
            this.lastRumbleTime = millis();
            this.intervalRumbleTime = 1200;
        }

        if(screenUtils.doFlash)
        {
            if(!this.thisFade)
            {
                this.thisFade = new graphics.Fade(color(255, 255, 255));
            }

            if(!this.thisFade.fading)
            {
                this.thisFade.start(14);
            }

            this.thisFade.draw();
        }
        else if(this.thisFade && this.thisFade.fading)
        {
            this.thisFade.draw();
        }

        if(game.noCursor)
        {
            noCursor();
            return;
        }

        if(game.cursor)
        {
            cursor(game.cursor);
        }else{
            cursor(ARROW);
        }   
    },
    lastRumbleTime : millis(),
    intervalRumbleTime : 1200
};

////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
/************************************************************Physics-Engine****************************************************************/
////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

var physics = {
    formulas : {

        // Of the source angle to the target angle
        // this function tells us whether it is faster to increment (true)
        // or decrement (false) to get to the target angle.
        findDirection : function(sourceA, targetA)
        {
            console.log.apply(arguments);

            if(targetA > sourceA)
            {
                if(targetA - sourceA < sourceA + 360 - targetA)
                {
                    return true;
                }

                return false;
            }

            if(targetA + 360 - sourceA < sourceA - targetA)
            {
                return true;
            }

            return false;
        },

        // Keeps an angle within the range between 0 and 360
        resolveAngle : function(a)
        {
            a = a % 360;
            if(a < 0)
            {
                a = 360 - abs(a);  
            }
            return a;
        },
        sign : function(n) 
        {
            if(n !== 0) 
            { 
                return (n > 0) ? 1 : -1;
            }
            return 0;
        },
        crossProduct : function(point1, point2, point3)
        {
            return (point1.xPos - point3.xPos) * (point2.yPos - point3.yPos) -
                   (point2.xPos - point3.xPos) * (point1.yPos - point3.yPos);
        },
        createBoundingBoxForLine : function(linePoint0, linePoint1)
        {
            return {
                xPos : (linePoint0.xPos < linePoint1.xPos) ? linePoint0.xPos : linePoint1.xPos,
                yPos : (linePoint0.yPos < linePoint1.yPos) ? linePoint0.yPos : linePoint1.yPos,
                width : Math.abs(linePoint0.xPos - linePoint1.xPos) || 1,
                height : Math.abs(linePoint0.yPos - linePoint1.yPos) || 1,
            };
        },
        closestPointOnLine : function(point1, linePoint0, linePoint1)
        { 
            var A1 = linePoint1.yPos - linePoint0.yPos;
            var B1 = linePoint0.xPos - linePoint1.xPos;
            
            var C1 =  A1 * linePoint0.xPos + B1 * linePoint0.yPos;
            var C2 = -B1 * point1.xPos + A1 * point1.yPos;
            
            var det = A1 * A1 + B1 * B1;
            
            var cx = 0;
            var cy = 0;
            
            if(det !== 0)
            { 
                cx = ((A1 * C1 - B1 * C2) / det);
                cy = ((A1 * C2 + B1 * C1) / det);
            }else{
                cx = point1.xPos;
                cy = point1.yPos;
            }
            
            return {
                xPos : constrain(cx, Math.min(linePoint0.xPos, linePoint1.xPos), Math.max(linePoint0.xPos, linePoint1.xPos)),
                yPos : constrain(cy, Math.min(linePoint0.yPos, linePoint1.yPos), Math.max(linePoint0.yPos, linePoint1.yPos)),
            }; 
        },
    },
    //Gives a place for grouped physics hueristic specific-like code
    getMiddleXPos : function(object)
    {
        object.middleXPos = (object.xPos + object.halfWidth);
        return object.middleXPos;
    },
    getMiddleYPos : function(object)
    {
        object.middleYPos = (object.yPos + object.halfHeight);
        return object.middleYPos;
    },
    teleport : function(object, xPos, yPos)
    {
        object.yVel = 0;
        object.xVel = 0;
        object.xPos = xPos;
        object.yPos = yPos;

        //Don't forget to update the boundingBox
        if(object.updateBoundingBox !== undefined)
        {
            object.updateBoundingBox();
        }

        //Also add the reference to the cell!
        cameraGrid.addReference(object);
    },
    push : {
        rectcircle : function(host, object)
        {
            if(host.yPos + host.height < object.yPos && object.inAir)
            {
                object.yPos = object.lastYPos;
            }
            if(abs(object.yVel) < abs(host.yVel))
            {
                if(host.xVel > 0)
                {
                    object.xVel += max(abs(host.xVel), 0.1) * 4 || 0;
                    object.rotateVel = 5;
                }
                else if(host.xVel < 0)
                {
                    object.xVel -= max(abs(host.xVel), 0.1) * 4 || 0;
                    object.rotateVel = -5;
                }
            }
        },
    },
    getSlopePoints : function(slope1)
    {
       var v1 = {
            xPos : 0,
            yPos : 0,
        };
        var v2 = {
            xPos : 0,
            yPos : 0,
        };
        var v3 = {
            xPos : 0,
            yPos : 0,
        };
    
        var slopeRight = slope1.xPos + slope1.width;
        var slopeBottom = slope1.yPos + slope1.height;
        switch(slope1.direction)
        {
            case "leftup" :
                v1.xPos = slope1.xPos;
                v1.yPos = slope1.yPos;
                v2.xPos = slope1.xPos - slope1.width;
                v2.yPos = slopeBottom;
                v3.xPos = slopeRight;
                v3.yPos = slopeBottom;
                break;
    
            case "rightup" :
                v1.xPos = slopeRight;
                v1.yPos = slope1.yPos;
                v2.xPos = slope1.xPos;
                v2.yPos = slopeBottom;
                v3.xPos = slopeRight + slope1.width;
                v3.yPos = slopeBottom;
                break;
    
            case "leftdown" :
                v1.xPos = slope1.xPos;
                v1.yPos = slope1.yPos;
                v2.xPos = slope1.xPos;
                v2.yPos = slopeBottom;
                v3.xPos = slopeRight;
                v3.yPos = slope1.yPos;
                break;
    
            case "rightdown" :
                v1.xPos = slope1.xPos;
                v1.yPos = slope1.yPos;
                v2.xPos = slopeRight;
                v2.yPos = slope1.yPos;
                v3.xPos = slopeRight;
                v3.yPos = slopeBottom;
                break;
        }
        
        //Return our points
        return [v1, v2, v3];
    },
};

//Observer (off limits)
var observer = {
    collisionTypes : {
        "blank" : {
            colliding : function() {},
            solveCollision : function() {},
        },
        "pointrect" : {
            colliding : function(point1, rect1, xDiv, yDiv)
            {
                return ((point1.xPos > rect1.xPos - (xDiv ? xDiv : 0) && 
                         point1.xPos < rect1.xPos + rect1.width + (xDiv ? xDiv : 0)) &&
                        (point1.yPos > rect1.yPos - (yDiv ? yDiv : 0) && 
                         point1.yPos < rect1.yPos + rect1.height + (yDiv ? yDiv : 0)));
            },
            solveCollision : function() {},
        },
        "pointcircle" : {
            colliding : function(point1, circle1)
            {
               return (Math.pow(Math.abs(circle1.xPos - point1.xPos), 2) + Math.pow(Math.abs(circle1.yPos - point1.yPos), 2) < circle1.radius * circle1.radius);
            },
            solveCollision : function() {},
        },
        "pointpolygon" : {
            colliding : function(point1, polygon1)
            {
                // http ://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
                var inside = false;
                for(var i = 0, j = polygon1.points.length - 1; i < polygon1.points.length; j = i++)
                {
                    if((polygon1.points[i].yPos > point1.yPos) !== (polygon1.points[j].yPos > point1.yPos) &&
                        point1.xPos < (polygon1.points[j].xPos - polygon1.points[i].xPos) * (point1.yPos - polygon1.points[i].yPos) /
                       (polygon1.points[j].yPos - polygon1.points[i].yPos) + polygon1.points[i].xPos)
                    {
                        inside = !inside;
                    }
                }
                return inside;
            },
            solveCollision : function(point1, polygon1) {},
        },
        "pointslope" : {
            colliding : function(point1, slope1)
            {
                return observer.collisionTypes.pointpolygon.colliding(point1, {
                    points : physics.getSlopePoints(slope1)
                });
            },
            solveCollision : function() {},
        },
        "circleslope" : {
            colliding : function(circle1, slope1)
            {
                var colliding = false;
                var point = {
                    xPos : circle1.xPos,
                    yPos : circle1.yPos,
                };
                switch(slope1.direction)
                {  
                    case "leftup" :
                        var hyp = dist(slope1.xPos, slope1.yPos, slope1.xPos + slope1.width, slope1.yPos + slope1.height);
                        var angle = asin(slope1.width / hyp);
                        point.xPos -= cos(angle) * circle1.radius;
                        point.yPos += sin(angle) * circle1.radius + (circle1.gravity || 1);
                        break;
                        
                    case "rightup" :
                        var hyp = dist(slope1.xPos, slope1.yPos + slope1.height, slope1.xPos + slope1.width, slope1.yPos);
                        var angle = asin(slope1.width / hyp);
                        point.xPos += cos(angle) * circle1.radius;
                        point.yPos += sin(angle) * circle1.radius + (circle1.gravity || 1);
                        break;
                        
                    case "leftdown" :
                        var hyp = dist(slope1.xPos, slope1.yPos + slope1.height, slope1.xPos + slope1.width, slope1.yPos);
                        var angle = asin(slope1.width / hyp);
                        point.xPos -= cos(angle) * circle1.radius;
                        point.yPos -= sin(angle) * circle1.radius;
                        break;
                        
                    case "rightdown" :
                        var hyp = dist(slope1.xPos, slope1.yPos, slope1.xPos + slope1.width, slope1.yPos + slope1.height);
                        var angle = asin(slope1.width / hyp);
                        point.xPos += cos(angle) * circle1.radius;
                        point.yPos -= sin(angle) * circle1.radius;
                        break;
                }
                
                if(circle1.xPos <= slope1.xPos)
                {
                    point.xPos = slope1.xPos;
                }
                if(circle1.xPos >= slope1.xPos + slope1.width)
                {
                    point.xPos = slope1.xPos + slope1.width;
                }
                if(circle1.yPos <= slope1.yPos && (slope1.direction === "leftdown" || slope1.direction === "rightdown"))
                {
                    point.yPos = slope1.yPos;
                }
                if(circle1.yPos >= slope1.yPos + slope1.height &&  (slope1.direction === "leftup" || slope1.direction === "rightup"))
                {
                    point.yPos = slope1.yPos + slope1.height;
                }
                circle1.keptPoint = point;
                //Re-use anther colliding function
                colliding = observer.collisionTypes.rectslope.colliding({}, slope1, [point]);
                return colliding;
            },
            solveCollision : function(circle1, slope1)
            {
                var angle = atan2(slope1.height, slope1.width);
                if(circle1.keptPoint === undefined)
                {
                   return; 
                }
                
                switch(slope1.direction)
                {
                    case "leftup" :
                        var right = slope1.xPos + slope1.width;
                        var w1 = abs(right - circle1.keptPoint.xPos);
                        var h2 = sin(angle) * w1;
                        if(circle1.keptPoint.xPos < right)
                        {
                            circle1.inAir = false;
                            circle1.yVel = min(0, circle1.yVel);
                            circle1.xPos += (slope1.slip || 1);
                            circle1.xVel += (slope1.slip || 1);
                            circle1.yVel += (slope1.slip || 1);
                            circle1.yPos = (slope1.yPos + (slope1.height - h2)) - (circle1.radius - (circle1.gravity || 1));
                        }
                        break;
                        
                    case "rightup" :
                        var w1 = abs(circle1.keptPoint.xPos - slope1.xPos);
                        var h2 = sin(angle) * w1;
                        if(circle1.keptPoint.xPos > slope1.xPos)
                        {
                            circle1.inAir = false;
                            circle1.yVel = min(0, circle1.yVel);
                            circle1.xPos -= (slope1.slip || 1);
                            circle1.xVel -= (slope1.slip || 1);
                            circle1.yVel += (slope1.slip || 1);
                            circle1.yPos = (slope1.yPos + (slope1.height - h2)) - (circle1.radius - (circle1.gravity || 1));
                        }
                        break;
                        
                    case "leftdown" :
                        var right = slope1.xPos + slope1.width;
                        var w1 = abs(right - circle1.keptPoint.xPos);
                        var h2 = sin(angle) * w1;
                        if(circle1.keptPoint.xPos < right)
                        {
                            circle1.yVel = max(0, circle1.yVel);
                            circle1.xPos += (slope1.slip || 1);
                            circle1.yPos = slope1.yPos + h2 + circle1.radius;
                        }
                        break;
                        
                    case "rightdown" :
                        var w1 = abs(circle1.keptPoint.xPos - slope1.xPos);
                        var h2 = sin(angle) * w1;
                        if(circle1.keptPoint.xPos > slope1.xPos)
                        {
                            circle1.yVel = max(0, circle1.yVel);
                            circle1.xPos -= (slope1.slip || 1);
                            circle1.yPos = slope1.yPos + h2 + circle1.radius;
                        }
                        break;
                }  
            },
        },
        "rectslope" : {
            colliding : function(rect1, slope1, customRectPoints)
            {
                var rect1Points = customRectPoints || [{
                    xPos : rect1.xPos,
                    yPos : rect1.yPos
                }, {
                    xPos : rect1.xPos + rect1.width,
                    yPos : rect1.yPos
                }, {
                    xPos : rect1.xPos,
                    yPos : rect1.yPos + rect1.height,
                }, {
                    xPos : rect1.xPos + rect1.width,
                    yPos : rect1.yPos + rect1.height,
                }];
                var points = physics.getSlopePoints(slope1);
                
                for(var i = 0; i < rect1Points.length; i++)
                {
                    if(observer.collisionTypes.pointpolygon.colliding(rect1Points[i], {
                            points : points
                        }))
                    {
                        return true;
                    }
                }
                if(rect1Points.length > 1)
                {
                    for(var i = 0; i < points.length; i++)
                    {
                        if(observer.collisionTypes.pointpolygon.colliding(points[i], {
                                points : rect1Points
                            }))
                        {
                            return true;
                        }
                    }
                }  
            },
            solveCollision : function(rect1, slope1)
            {
                rect1.lastSlopeCollider = slope1;
                var slopeRight = slope1.xPos + slope1.width;

                switch(slope1.direction)
                {
                    case "leftup" :
                        /*Collide Bottom*/
                        var slopeBottom = slope1.yPos + slope1.height;

                        if(rect1.yPos - rect1.yVel >= slopeBottom && !slope1.fromSpike)
                        {
                            rect1.yPos = slopeBottom;
                            rect1.yVel = 0;
                            rect1.inAir = false;
                            break;
                        }
                        
                        /*Collide diagonal*/
                        if(rect1.xPos - 2 <= slope1.xPos && !slope1.fromSpike)
                        {
                            rect1.yPos = slope1.yPos - rect1.height;
                            rect1.yVel = 0;
                            rect1.inAir = false;
                        }
                        else if(rect1.xPos <= slopeRight)
                        {
                            rect1.yVel = 0;
                            rect1.inAir = false;
                            var angle = atan2(slope1.height, slope1.width);
                            var w1 = abs(rect1.xPos + 4 - slope1.xPos);
                            var h2 = sin(angle) * w1;
                            if(!slope1.fromSpike)
                            {
                                rect1.yPos = (slope1.yPos + h2) - rect1.height;
                            }else{
                                rect1.yVel = -3;
                                rect1.yPos -= 3;
                            }

                            if(slope1.slippy)
                            {
                                if(rect1.xVel >= -0.1)
                                {
                                    rect1.yVel += 0.75;
                                    rect1.xVel += 0.2;
                                    rect1.xVel *= 1.1;
                                }
                            }
                        }
                        break;

                    case "rightup" :
                       /* if(rect1.yPos < slope1.yPos + slope1.height && 
                            rect1.yPos + rect1.height + 10 > slope1.yPos + slope1.height && 
                            rect1.xPos < slope1.xPos + rect1.xVel)
                        if(observer.collisionTypes.pointrect.colliding({
                            xPos : slope1.xPos,
                            yPos : slope1.yPos + slope1.height,
                        }, rect1))
                        {
                            console.log(true);
                            rect1.xPos = slope1.xPos - rect1.width;
                            break;
                        }*/


                        /*Collide Bottom*/
                        var slopeBottom = slope1.yPos + slope1.height;

                        if(rect1.yPos - rect1.yVel >= slopeBottom && !slope1.fromSpike)
                        {
                            rect1.yPos = slopeBottom;
                            rect1.yVel = 0;
                            rect1.inAir = false;
                            break;
                        }

                        /*Collide diagonal*/
                        var rect1PointXPos = rect1.xPos + rect1.width;

                        if(rect1PointXPos + 2 >= slopeRight && !slope1.fromSpike)
                        {
                            rect1.yPos = slope1.yPos - rect1.height;
                            rect1.yVel = 0;
                            rect1.inAir = false;
                        }
                        else if(rect1PointXPos >= slope1.xPos)
                        {
                            rect1.yVel = 0;
                            rect1.inAir = false;
                            var angle = atan2(slope1.height, slope1.width);
                            var w1 = abs(slope1.xPos - rect1.xPos + rect1.width + 4);
                            var h2 = sin(angle) * w1;
                            if(!slope1.fromSpike)
                            {
                                rect1.yPos = (slope1.yPos + h2) - rect1.height;
                            }else{
                                rect1.yVel = -3;
                                rect1.yPos -= 3;
                            }

                            if(slope1.slippy)
                            {
                                if(rect1.xVel <= 0.1)
                                {
                                    rect1.yVel += 0.75;
                                    rect1.xVel -= 0.2;
                                    rect1.xVel *= 1.1;
                                }
                            }
                        }
                        break;

                    case "leftdown" :
                        if(slope1.fromSpike)
                        {
                            break;
                        }

                        /*Collide Top*/
                        if(rect1.yPos + rect1.height <= slope1.yPos + rect1.yVel)
                        {
                            rect1.yPos = slope1.yPos - rect1.height;
                            rect1.yVel = 0;
                            rect1.inAir = false;
                            break;
                        }

                        /*Collide diagonal*/
                        if(rect1.xPos <= slopeRight)
                        {
                            rect1.inAir = true;
                            rect1.yVel = max(rect1.yVel, 0);
                            var angle = atan2(slope1.height, slope1.width);
                            var w1 = abs(slopeRight - rect1.xPos);
                            var h2 = sin(angle) * w1;
                            rect1.yPos = (slope1.yPos + h2);
                        }
                        break;

                    case "rightdown" :
                        if(slope1.fromSpike)
                        {
                            break;
                        }

                        /*Collide Top*/
                        if(rect1.yPos + rect1.height <= slope1.yPos + rect1.yVel)
                        {
                            rect1.yPos = slope1.yPos - rect1.height;
                            rect1.yVel = 0;
                            rect1.inAir = false;
                            break;
                        }

                        /*Collide diagonal*/
                        var rect1PointXPos = rect1.xPos + rect1.width;

                        if(rect1PointXPos >= slope1.xPos)
                        {
                            rect1.inAir = true;
                            rect1.yVel = max(rect1.yVel, 0);
                            var angle = atan2(slope1.height, slope1.width);
                            var w1 = abs(slope1.xPos - rect1PointXPos);
                            var h2 = sin(angle) * w1;
                            rect1.yPos = (slope1.yPos + h2);
                        }
                        break;
                }
                rect1.lastSlopeCollider = slope1;
            }
        },
        "circlecircle" : {
            colliding : function(circle1, circle2)
            {
                circle1.measuredDist = dist(circle1.xPos, circle1.yPos, circle2.xPos, circle2.yPos);
                return(circle1.measuredDist <= circle1.radius + circle2.radius);
            },
            solveCollision : function(circle1, circle2)
            {
                var angle = atan2(circle1.yPos - circle2.yPos, circle1.xPos - circle2.xPos) + (circle1.winding || 0);
                var input = circle1.radius + circle2.radius - circle1.measuredDist;
                circle1.xPos += input * cos(angle);
                circle1.yPos += input * sin(angle);
                circle1.inAir = (circle1.yPos - circle1.radius > circle2.yPos);
                circle1.touchedCircle = true;
                circle2.touchedCircle = true;
            },
        },
        "rectcircle" : {
            colliding : function(rect1, circle1)
            {
                var point1 = {};
                rect1.middleXPos = rect1.xPos + rect1.halfWidth;
                rect1.middleYPos = rect1.yPos + rect1.halfHeight;
                rect1.halfLineThrough = dist(rect1.xPos, rect1.yPos, rect1.xPos + rect1.width, rect1.yPos + rect1.height) / 2;

                //Step 1  : Get the closest point on the circle on the rectangle to the circle
                var angle = atan2(circle1.yPos - rect1.middleYPos, circle1.xPos - rect1.middleXPos);
                point1.xPos = rect1.middleXPos + (rect1.halfLineThrough * cos(angle));
                point1.yPos = rect1.middleYPos + (rect1.halfLineThrough * sin(angle));

                //Step 2  : Constrain the point into the rectangle
                point1.xPos = constrain(point1.xPos, rect1.xPos, rect1.xPos + rect1.width);
                point1.yPos = constrain(point1.yPos, rect1.yPos, rect1.yPos + rect1.height);

                //Step 3  : check if the point is colliding with the circle
                circle1.pointDist = dist(circle1.xPos, circle1.yPos, point1.xPos, point1.yPos);

                if(circle1.physics.solidObject)
                {
                    return (circle1.pointDist <= circle1.radius);
                }else{
                    return (circle1.xPos + circle1.radius > rect1.xPos &&
                            circle1.yPos + circle1.radius > rect1.yPos &&
                            circle1.xPos - circle1.radius < rect1.xPos + rect1.width &&
                            circle1.yPos - circle1.radius < rect1.yPos + rect1.height);
                }
            },
            solveCollision : function(rect1, circle1)
            {
                var angle = atan2(rect1.middleYPos - circle1.yPos, rect1.middleXPos - circle1.xPos);
                var input = (circle1.radius - circle1.pointDist);
                var inputX = input * cos(angle);
                var inputY = input * sin(angle);
                if(rect1.physics.movement === "dynamic")
                {
                    rect1.xPos += inputX;
                    rect1.yPos += inputY;
                    rect1.inAir = (rect1.yPos + rect1.height >= circle1.yPos);
                    if(circle1.physics.movement === "dynamic" && circle1.yVel === rect1.yVel && !rect1.touchedRect)
                    {
                        circle1.yVel = max(circle1.yVel, 3);
                    }
                    if(rect1.touchedRect)
                    {
                        if(inputX > 0)
                        {
                            rect1.xVel = max(0, rect1.xVel);
                        }
                        else if(inputX < 0)
                        {
                            rect1.xVel = min(0, rect1.xVel);
                        }
                        //Reboot the collision
                        if(rect1.lastRectCollider !== undefined)
                        {
                            if(observer.collisionTypes.rectrect.colliding(rect1, rect1.lastRectCollider))
                            {
                                observer.collisionTypes.rectrect.solveCollision(rect1, rect1.lastRectCollider);
                            }
                        }
                        rect1.collidedWithCircle = false;
                        rect1.touchedRect = false;
                    }
                    
                    //Reboot the collision with the slopes
                    if(rect1.lastSlopeCollider !== undefined)
                    {
                        if(observer.collisionTypes.rectrect.colliding(rect1, rect1.lastSlopeCollider))
                        {
                            observer.collisionTypes.rectrect.solveCollision(rect1, rect1.lastSlopeCollider);
                        }
                    }
                    if(!rect1.inAir)
                    {
                        rect1.yVel = min(rect1.yVel, rect1.maxYVel * (circle1.friction || 0.25));
                    }
                }
                if(circle1.physics.movement === "dynamic")
                {
                    if(rect1.arrayName !== "oneWay")
                    {
                        circle1.xPos -= inputX;
                        circle1.yPos -= inputY;
                        circle1.inAir = (inputY < 0);
                    } else {
                        if(inputX < 0 && rect1.physics.sides.right)
                        {
                            circle1.xPos -= inputX;
                        }
                        else if(inputX > 0 && rect1.physics.sides.left)
                        {
                            circle1.xPos -= inputX;
                        }
                        if(inputY < 0 && rect1.physics.sides.down)
                        {
                            circle1.yPos -= inputY;
                        }
                        else if(inputY > 0 && rect1.physics.sides.up)
                        {
                            circle1.yPos -= inputY;
                        }
                    }
                    if(circle1.touchedCircle)
                    {
                        if((inputX < 0 && circle1.xVel > 0) ||
                            (inputX > 0 && circle1.xVel < 0))
                        {
                            circle1.xVel = 0;
                        }
                        if((inputY < 0 && circle1.yVel > 0) ||
                            (inputY > 0 && circle1.yVel < 0))
                        {
                            circle1.yVel = 0;
                        }
                    }
                    circle1.touchedCircle = false;
                    if((circle1.xPos > rect1.xPos && circle1.xPos < rect1.xPos + rect1.width))
                    {
                        circle1.inAir = (circle1.yPos > rect1.yPos);
                        if(circle1.yPos - circle1.radius >= rect1.yPos + rect1.height)
                        {
                            circle1.yVel = max(circle1.yVel, 0);
                            circle1.inAir = true;
                        }
                        if(!circle1.inAir)
                        {
                            circle1.yVel = 0;
                        }
                    }
                }
            },
        },
        "rectrect" : {
            colliding : function(rect1, rect2)
            {
                return ((rect1.xPos + rect1.width > rect2.xPos &&
                         rect1.xPos < rect2.xPos + rect2.width) &&
                       (rect1.yPos + rect1.height > rect2.yPos &&
                         rect1.yPos < rect2.yPos + rect2.height));
            },
            getSide : function(rect1, rect2)
            {
                /*
                    @dx: Difference xPos or the difference between both centers 
                         of rectangles in X-axis.
                         
                    @dy: Difference yPos or the difference between both centers 
                         of rectangles in Y-axis.
                */
                var dx = ((rect1.xPos + rect1.halfWidth) - (rect2.xPos + rect2.halfWidth)),
                    dy = ((rect1.yPos + rect1.halfHeight) - (rect2.yPos + rect2.halfHeight));
                
                // Important for normalizing differences between our values (vx, vy)
                var hWidths = (rect1.halfWidth + rect2.halfWidth),
                    hHeights = (rect1.halfHeight + rect2.halfHeight);

                var sx = 1, sy = 1;

                // Based on the last decided side ignore x or y.
                if(rect1._side === "up" || rect1._side === "down" || rect1._side === "")
                {
                    sx = 0;
                }
                else if(rect1._side === "left" || rect1._side === "right")
                {
                    sy = 0;
                }

                var ox = hWidths  - Math.abs(dx - (rect1.xVel + (rect2.xVel || 0)) * sx),
                    oy = hHeights - Math.abs(dy - (rect1.yVel + (rect2.yVel || 0)) * sy);

                if(ox < oy)
                {
                    if(dx < 0)
                    {
                        return "left";
                    }else{
                        return "right";
                    }
                }else{
                    if(dy < 0)
                    {
                        return "up";  
                    }else{
                        return "down";  
                    }
                }
            },
            applySide : function(side, rect1, rect2, noZero)
            {
                switch(side)
                {
                    case "left" :
                        rect1.xVel = (!noZero) ? 0 : rect1.xVel;
                        rect1.xPos = rect2.xPos - rect1.width;
                        break;
                    
                    case "right" :
                        rect1.xVel = (!noZero) ? 0 : rect1.xVel;
                        rect1.xPos = rect2.xPos + rect2.width;
                        break;
                             
                    case "up" :
                        rect1.inAir = false;
                        rect1.yVel = (!noZero) ? 0 : min(0, rect1.yVel);
                        rect1.yPos = rect2.yPos - rect1.height;                        
                        break;
                    
                    case "down" :
                        rect1.inAir = true;
                        rect1.yVel = (!noZero || rect1.yVel < -rect1.upForce) ? 0 : rect1.yVel;
                        rect1.yPos = rect2.yPos + rect2.height;

                        //Enable the double lifting of crates
                        if(noZero && rect2.upForce && rect1.yVel <= 0)
                        {
                            rect2.yVel = min(rect2.yVel, -rect2.upForce); 
                        }
                        break;
                }
            },
            getSideOneWay : function(side, rect1, oneWay) //For oneways
            {
                switch(side)
                {
                    case "left" :
                        if(oneWay.physics.sides.left && rect1.xVel > 0 && 
                        rect1.xPos + rect1.width <= oneWay.xPos + abs(rect1.xVel) + rect1.maxXVel)
                        {
                            return "left";    
                        }
                        break;
                    
                    case "right" :
                        if(oneWay.physics.sides.right && rect1.xVel < 0 && 
                        rect1.xPos + abs(rect1.xVel) + rect1.maxXVel >= oneWay.xPos + oneWay.width)
                        {
                            return "right";    
                        }
                        break;
                        
                    case "up" :
                        if(oneWay.physics.sides.up && rect1.yVel > 0 && 
                        rect1.yPos + rect1.height <= oneWay.yPos + abs(rect1.yVel) + rect1.maxYVel)
                        {
                            return "up"; 
                        }
                        break;
                        
                    case "down" :
                        if(oneWay.physics.sides.down && rect1.yVel < 0 && 
                        rect1.yPos + abs(rect1.yVel) + rect1.maxYVel >= oneWay.yPos + oneWay.height)
                        {
                            return "down";    
                        }
                        break;
                }
                return "";
            },
            applyVelSide : function(side, rect1, rect2) //For crates
            {
                switch(side)
                {
                    case "left" :
                        if(rect1.xVel > 0)
                        {
                            rect2.xVel += rect1.xForce || rect1.xAcl * (rect1.mass || 1);  
                        }
                        return true;
                    
                    case "right" :
                        if(rect1.xVel < 0) 
                        {
                            rect2.xVel -= rect1.xForce || rect1.xAcl * (rect1.mass || 1);  
                        }
                        return true;
                        
                    case "up" :
                        if(rect1.yVel > 0 && rect2.yVel < 0)
                        {
                            rect2.yVel += (rect1.yForce || (rect1.yAcl || 2) * (rect1.mass || 1));
                        }
                        return true;
                        
                    case "down" :
                        if(rect1.yVel < 0)
                        {
                            rect2.yVel -= rect1.yForce || (rect1.yAcl || 2) * (rect1.mass || 1); 
                        }
                        return true;
                }
                return false;
            },
            solveCollision : function(rect1, rect2, extra)
            {
                var side = this.getSide(rect1, rect2);

                if(rect2.physics.sides !== undefined)
                {
                    side = this.getSideOneWay(side, rect1, rect2);
                }

                //Record the last decided side
                rect1._side = side;

                var noZero;
                if(rect2.physics.movement === "dynamic")
                {
                    noZero = this.applyVelSide(side, rect1, rect2);
                }

                this.applySide(side, rect1, rect2, noZero);

                rect1.lastRectCollider = rect2;

                return {
                    side : side,
                };
            },
        },
    },
    accessSlow : function(object1, object2, access)
    {
        var info = observer.getType(
            object1.physics.shape,
            object2.physics.shape,
            observer.collisionTypes
        );
        var colliding = false;

        if(!info.flipped)
        {
            colliding = observer.collisionTypes[info.type][access](object1, object2);
        }else{
            colliding = observer.collisionTypes[info.type][access](object2, object1);
        }
        return colliding;
    },
    access : function(object1, object2, access)
    {
        if(observer.collisionTypes[object1.physics.shape + object2.physics.shape])
        {
            return observer.collisionTypes[object1.physics.shape + object2.physics.shape][access](object1, object2);
        }else{
            return observer.collisionTypes[object2.physics.shape + object1.physics.shape][access](object2, object1);
        }
    },
    colliding : function(object1, object2)
    {
        if(observer.collisionTypes[object1.physics.shape + object2.physics.shape])
        {
            return observer.collisionTypes[object1.physics.shape + object2.physics.shape].colliding(object1, object2);
        }else{
            return (observer.collisionTypes[object2.physics.shape + object1.physics.shape] || observer.collisionTypes.blank).colliding(object2, object1);
        }
    },
    solveCollision : function(object1, object2)
    {
        if(observer.collisionTypes[object1.physics.shape + object2.physics.shape])
        {
            return observer.collisionTypes[object1.physics.shape + object2.physics.shape].solveCollision(object1, object2);
        }else{
            return (observer.collisionTypes[object2.physics.shape + object1.physics.shape] || observer.collisionTypes.blank).solveCollision(object2, object1);
        }
    },
    boundingBoxesColliding : function(box1, box2)
    {
        return ((box1.xPos + box1.width > box2.xPos &&
                 box1.xPos < box2.xPos + box2.width) &&
               (box1.yPos + box1.height > box2.yPos &&
                 box1.yPos < box2.yPos + box2.height));
    },
    fastBoundingBoxesColliding : function(box1, box2)
    {
        return (box1.minX < box2.maxX && box1.maxX > box2.minX && 
                box1.minY < box2.maxY && box1.maxY > box2.minY);
    },
    getType : function(name1, name2, delegate)
    {
        var typeToReturn = "blank";
        var flipped = false;
        var type = name1 + name2;
        if(delegate[type] !== undefined)
        {
            typeToReturn = type;
        }else{
            //Flip shapes
            flipped = true;
            type = name2 + name1;
            if(delegate[type])
            {
                typeToReturn = type;
            }
        }
        return {
            type : typeToReturn,
            flipped : flipped,
        };
    },
};

////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
/*************************************************************World-Helpers****************************************************************/
////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

var Camera = function(xPos, yPos, width, height)
{
    this.xPos = xPos;
    this.yPos = yPos;
    this.width = width;
    this.height = height;

    this.halfWidth = this.width / 2;
    this.halfHeight = this.height / 2;
    this.focusXPos = this.halfWidth;
    this.focusYPos = this.halfHeight;

    var _halfWidth = this.halfWidth;
    var _halfHeight = this.halfHeight;

    this.upperLeft = {
        col : 0,
        row : 0,
    };
    this.lowerRight = {
        col : 0,
        row : 0,
    };

    this.lastSpeed = 0.125;
    this.speed = 0.125;

    this.getObject = function()
    {
        return this;
    };

    this.boundingBox = {};
    this.updateBoundingBox = function()
    {
        this.boundingBox = {
            xPos : this.focusXPos - this.halfWidth,
            yPos : this.focusYPos - this.halfHeight,
            width : this.focusXPos + this.halfWidth,
            height : this.focusYPos + this.halfHeight
        };
    };

    this.updateBoundingBox();

    this.attach = function(func, directAttach, time, endFunc)
    {
        if(this.getObject === func)
        {
            return;
        }

        this.lastGetObject = this.getObject;
        this.getObject = func;
        var object = func();
        if(directAttach && object)
        {
            this.focusXPos = object.boundingBox.xPos + (object.boundingBox.width / 2);
            this.focusYPos = object.boundingBox.yPos + (object.boundingBox.height / 2);
        }

        if(!directAttach && object && (object.arrayName === "itemChest" || object.arrayName === "chest"))
        {
            sounds.playSound("ChestAppear.mp3");
        }

        this.getObject.attachTime = millis();
        this.getObject.time = time;
        this.getObject.endFunc = endFunc;
    };

    this.scale = 0.3;
    this.maxScale = 0.26;
    this.scaleVel = 0.03;

    this.scaleZoom = function(override)
    {
        if((this.scale > 0 || override) && typeof this.scale !== "undefined")
        {
            var sc = 1 + Math.floor(this.scale * 10) / 10;

            // Center ship.
            if(levels[levelInfo.level].createStars)
            {
                translate(-14, -14);
            }
            scale(sc, sc);
        }
    };

    this.keepInGrid = true;
    this.scaleOut = -0.6;

    this.view = function(object)
    {
        if(this.getObject.time !== undefined && 
        millis() - this.getObject.attachTime > this.getObject.time)
        {
            (this.getObject.endFunc || function() {})();
            this.getObject = this.lastGetObject || this.getObject;
        }

        if(object === undefined)
        {
            object = this.getObject();

            if(!object)
            {
                (this.getObject.endFunc || function() {})();
                this.getObject = this.lastGetObject || this.getObject;
                object = this.getObject();
            }
        }

        if(this.scale <= 0 || this.scale >= this.maxScale)
        {
            if(object.controls && object.controls.zoom)
            {
                if(object.controls.zoom())
                {
                    this.scaleVel = -abs(this.scaleVel);
                }else{
                    this.scaleVel = abs(this.scaleVel);
                }
            }
        }

        this.scale += this.scaleVel;
        this.scale = constrain(this.scale, 0, this.maxScale);

        this._cFactor = 1;

        if(!this.keepInGrid || this.scaled)
        {
            this.scale = this.scaleOut || 0;

            if(this.scale)
            {
                var c = (1 - this.scale) * (1 / -this.scale);

                this.halfWidth = _halfWidth * c;
                this.halfHeight = _halfHeight * c;
                this.width = width * c;
                this.height = height * c;

                this._cFactor = c;
            }else{
                this.halfWidth = _halfWidth;
                this.halfHeight = _halfHeight;
                this.width = width;
                this.height = height;
            }
        }else{
            this.halfWidth = _halfWidth;
            this.halfHeight = _halfHeight;
            this.width = width;
            this.height = height;
        }


        var speed = this.speed;

        if(levels[levelInfo.level].createStars)
        {
            speed = 1;
        }

        this.scaleZoom(!this.keepInGrid || this.scaled);

        if(this.useAnotherScale)
        {
            translate(this.width * (1 - this.ANScaleX) / 2, this.height * (1 - this.ANScaleY) / 2);

            var cfX = 1 + this.ANScaleX;
            var cfY = 1 + this.ANScaleY;

            scale(this.ANScaleX, this.ANScaleY);

            translate(this.width * (1 - cfX) / 2, this.height * (1 - cfY) / 2);

            this.width = width * this._cFactor * cfX;
            this.height = height * this._cFactor * cfY;
            this.halfWidth = _halfWidth * this._cFactor * cfX;
            this.halfHeight = _halfHeight * this._cFactor * cfY;
        }

        // Get the camera position
        var xPos = object.overrideXMiddle || object.boundingBox.xPos + (object.boundingBox.width / 2);
        var yPos = object.overrideYMiddle || object.boundingBox.yPos + (object.boundingBox.height / 2);

        this.angle = atan2(yPos - this.focusYPos, xPos - this.focusXPos);
        this.distance = dist(this.focusXPos, this.focusYPos, xPos, yPos) * speed;

        this.focusXPos += this.distance * cos(this.angle);
        this.focusYPos += this.distance * sin(this.angle);

        if(this.keepInGrid)
        {
            // Keep it in the grid
            this.focusXPos = constrain(this.focusXPos, levelInfo.xPos + this.halfWidth, 
                                        levelInfo.xPos + levelInfo.width - this.halfWidth);
            this.focusYPos = constrain(this.focusYPos, levelInfo.yPos + this.halfHeight, 
                                        levelInfo.yPos + levelInfo.height -this.halfHeight);
        }

        // Get the corners position on the grid
        this.upperLeft = cameraGrid.getPlace(this.focusXPos + EPSILON - this.halfWidth, 
                                             this.focusYPos + EPSILON - this.halfHeight);
        this.lowerRight = cameraGrid.getPlace(this.focusXPos + this.halfWidth - EPSILON, 
                                             this.focusYPos + this.halfHeight - EPSILON);

        translate(this.xPos, this.yPos);

        if(levelInfo.width >= this.width)
        {
            translate(this.halfWidth - this.focusXPos, 0);
        }else{
            translate(-levelInfo.xPos, 0);
        }
        if(levelInfo.height >= this.height)
        {
            translate(0, this.halfHeight - this.focusYPos);
        }else{
            translate(0, -levelInfo.yPos);
        }

        this.updateBoundingBox();
    };

    this.untranslate = function()
    {
        translate(-this.xPos, -this.yPos);
    };

    this.draw = function()
    {
        fill(255, 255, 255, 50);
        fastRect(cameraGrid.xPos + this.upperLeft.col * cameraGrid.cellWidth, cameraGrid.yPos + this.upperLeft.row * cameraGrid.cellHeight, ((this.lowerRight.col + 1) - this.upperLeft.col) * cameraGrid.cellWidth, ((this.lowerRight.row + 1) - this.upperLeft.row) * cameraGrid.cellHeight);
    };

    this.drawOutline = function()
    {
        noFill();
        stroke(255, 255, 255);
        fastRect(this.xPos, this.yPos, this.width, this.height);
        noStroke();
    };
};
var cam = new Camera(0, 0, width, height); //Use this as the default
// window.cam = cam;

/*Production createArray*/
var createArray = function(object, inArray)
{
    var array = inArray || [];
    array.references = {};
    array.add = function()
    {
        if(object.apply !== undefined)
        {
            //Instatiate
            var oNew = Object.create(object.prototype);
            object.apply(oNew, Array.prototype.slice.call(arguments));
            this.push(oNew);
        }else{
            array.push(Array.prototype.slice.call(arguments)[0]);
        }
        
        //Set props
        var lastIndex = array.length - 1;
        array[lastIndex].arrayName = array.name;
        array[lastIndex].name = array.tempArg || array.name;
        array[lastIndex].index = lastIndex;
        array[lastIndex].firstIndex = lastIndex;

        return array[lastIndex];
    };
    //Add an object with a name addObject(name, arg1, arg2...)
    array.addObject = function(name) 
    {
        if(this.references[name] === undefined)
        {
            this.references[name] = this.length;
        }else{
            println("Warning: You cannot have multiple objects \n" + 
                    "with the same name \'" + name + "\', Object removed.");
            //Exit the function immediately.
            return;
        }
        
        var args = Array.prototype.slice.call(arguments);
        this.tempArg = args[0];
        args.shift();
        this.add.apply(null, args);
    };
    array.getObject = function(name)
    {
        if(this[this.references[name]] !== undefined)
        {
            return this[this.references[name]];
        }else{
            // println("Error referencing object '" + name + "'"); 
            // delete this.references[name];
            return {
                fake : true,
            };
        }
    };
    array.removeObject = function(name)
    {
        if(this.references[name] !== undefined)
        {
            this.splice(this.references[name], 1);
            delete this.references[name];
        }
    };

    //Want to reference your array as if when it was first created?
    //Call this while iterating if you're constantly moving objects around
    array.applyObject = function(i)
    {
        if(!this[i])
        {
            return;
        }

        // if(this[i].delete)
        // {
        //     this.splice(i, 1);
        //     return;
        // }

        if(this[i].hideDelete && !this[i].fake)
        {
            //Dummy object
            this[i] = {
                xPos : 0,
                yPos : 0,
                boundingBox : {
                    off : true,
                },
                physics : {},
                draw : function() {},
                update : function() {},

                fake : true,
            };
            return;
        }

        if(!this[i].fake)
        {
            this[i].index = i;
            this[i].arrayName = this.name || this[i].arrayName;
        }
    };
    array.clear = function()
    {
        this.length = 0;
        this.references = {};
    };
    array.input = function(index) //Use this for safe references
    {
        return this[index] || {
            fake : true
        };
    };
    array.last = array.getLast = function()
    {
        return this.input(this.length - 1);
    };
    array.draw = function()
    {
        for(var i = 0; i < this.length; i++)
        {
            this[i].draw();
        }
    };
    array.update = function(applyObject)
    {
        for(var i = 0; i < this.length; i++)
        {
            this[i].update();
            
            if(applyObject)
            {
                this.applyObject(i);   
            }
        }
    };
    return array;
};

////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
/*************************************************************Engine-Core******************************************************************/
////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

var cameraGrid = [];
cameraGrid.setup = function(xPos, yPos, cols, rows, cellWidth, cellHeight)
{
    this.xPos = xPos;
    this.yPos = yPos;
    this.cellWidth = cellWidth;
    this.cellHeight = cellHeight;
    this.halfCellWidth = this.cellWidth / 2;
    this.halfCellHeight = this.cellHeight / 2;

    this.create(cols, rows);
};
cameraGrid.create = function(cols, rows)
{
    this.length = 0;
    this.length = 0;

    for(var col = 0; col < cols; col++)
    {
        this.push([]);
        for(var row = 0; row < rows; row++)
        {
            this[col].push({});
            Object.defineProperty(this[col][row], "_lights",
            {
                value : {},
                enumerable: false,
                writable: true,
                configurable: true,
            });   
        }
    }
    this.cols = cols;
    this.rows = rows;

    if(levels[levelInfo.level].createStars)
    {
        let _stars = [];
        
        var col, row, i;

        for(col = 0; col < cols; col++)
        {
            for(row = 0; row < rows; row++)
            {
                _stars = [];

                for(i = 0; i < random(40, 80); i++)
                {
                    _stars.push([col * this.cellWidth + random() * this.cellWidth, row * this.cellHeight + random() * this.cellHeight, random(0, 2)]);
                }

                Object.defineProperty(this[col][row]._lights, "_stars",
                {
                    value : _stars,
                    enumerable: false,
                    writable: true,
                    configurable: true,
                });  
            }
        }

        stars = null;
    }

    this._length = this.length - 1;
    this[0]._length = this[0].length - 1;
};
cameraGrid.addLight = function(xPos, yPos, name, value)
{
    var place = this.getPlace(xPos, yPos);
    this[place.col][place.row]._lights[name] = value;
};
cameraGrid.free = function()
{
    // I wonder if I'll ever manage to figure out what to put here.
};         
cameraGrid.reset = function()
{
    this.create(this.rows, this.cols);
};
cameraGrid.getPlace = function(xPos, yPos)
{
    return {
        col : constrain(round(((xPos - this.xPos) - this.halfCellWidth) / this.cellWidth), 0, this._length),
        row : constrain(round(((yPos - this.yPos) - this.halfCellHeight) / this.cellHeight), 0, this[0]._length),
    };
};
cameraGrid.addReference = function(object)
{
    var toSet = {
        arrayName : object.arrayName,
        index : object.firstIndex
    };

    if(!object.boundingBox.off)
    {
        var upperLeft = this.getPlace(object.boundingBox.xPos, object.boundingBox.yPos);
        var lowerRight = this.getPlace(object.boundingBox.xPos + object.boundingBox.width, object.boundingBox.yPos + object.boundingBox.height);
        for(var col = upperLeft.col; col <= lowerRight.col; col++)
        {
            for(var row = upperLeft.row; row <= lowerRight.row; row++)
            {
                this[col][row][object.arrayName + object.index] = toSet;
            }
        }

        object._places = {
            upperLeft : upperLeft,
            lowerRight : lowerRight,
        };
    }else{
        var place = this.getPlace(object.xPos, object.yPos);
        this[place.col][place.row][object.arrayName + object.index] = toSet;
        object.place = place;

        object._places = {
            upperLeft : place,
            lowerRight : place,
        };
    }
};
cameraGrid.removeReference = function(object)
{
    var upperLeft = object._places.upperLeft,
        lowerRight = object._places.lowerRight;

    var index = object.arrayName + object.index;

    for(var col = upperLeft.col; col <= lowerRight.col; col++)
    {
        for(var row = upperLeft.row; row <= lowerRight.row; row++)
        {
            delete this[col][row][index];
        }
    }       
};
cameraGrid.draw = function()
{
    noFill();
    stroke(0, 0, 0);
    if(screenUtils.debugMenuWhite)
    {
        stroke(255, 255, 255, 100);
    }
    strokeWeight(1);
    for(var col = cam.upperLeft.col; col <= cam.lowerRight.col; col++)
    {
        for(var row = cam.upperLeft.row; row <= cam.lowerRight.row; row++)
        {  
            $pjs.rect(this.xPos + col * this.cellWidth, this.yPos + row * this.cellHeight, this.cellWidth, this.cellHeight);
        }
    }
};

var gameObjects = createArray([]);
gameObjects.lastAddObject = gameObjects.addObject;
gameObjects.drawBoundingBoxes = function()
{
    if(!game.boundingBoxes)
    {
        return;  
    }

    noFill();
    stroke(0, 0, 0);

    if(levels[levelInfo.level].createStars)
    {
        stroke(255, 255, 255);
    }

    strokeWeight(0.5);

    var boundingBox, array, object, i, j, shape;

    //Render!
    for(i = 0; i < this.toOrder.length; i++)
    {
        array = this.renderPlace[this[this.toOrder[i]].name];

        for(j = 0; j < array.length; j++)
        {
            if(this[this.toOrder[i]][array[j]])
            {
                shape = this[this.toOrder[i]][array[j]].boundingBox;
                $pjs.rect(shape.xPos, shape.yPos, shape.width, shape.height);
            }
        }
    }

    noStroke();
};
gameObjects.removeObjects = function()
{
    var savedObjects = [];
    for(var i = 0; i < this.length; i++)
    {
        savedObjects.push([]);

        //Keep objects where save equals true, 
        for(var j = 0; j < this[i].length; j++)
        {
            if(this[i][j].save)
            {
                savedObjects[i].push(this[i][j]);
            }
        }

        this[i].clear();
    }

    //Add the objects back
    for(var i = 0; i < savedObjects.length; i++)
    {
        for(var j = 0; j < savedObjects[i].length; j++)
        {
            if(savedObjects[i][j].reAdd !== undefined)
            {
                savedObjects[i][j].reAdd();
            }
            savedObjects[i][j].toSetAfter = true;

            this[i].push(savedObjects[i][j]);
            this[i].applyObject(j); // Don't forget to apply our object!
        }
    }
};
gameObjects.findOrder = function()
{
    this.renderPlace = {};
    for(var i = 0; i < this.length; i++)
    {
        this.renderPlace[this[i].name] = [];
    }

    this.toOrder = [];
};
gameObjects.addObjectsToCameraGrid = function()
{
    for(var i = 0; i < this.length; i++)
    {
        for(var j = 0; j < this[i].length; j++)
        {
            cameraGrid.addReference(this[i][j]);
        }
    }
};
gameObjects.setAfter = function()
{
    for(var i = 0; i < this.length; i++)
    {
        for(var j = 0; j < this[i].length; j++)
        {
            if(this[i][j] === undefined)
            {
                this[i][j] = {
                    fake : true
                };
            }
            if(this[i][j].toSetAfter && this[i][j].setAfter !== undefined)
            {
                this[i][j].setAfter();
                this[i][j].toSetAfter = false;
            }
        }
    }

    this.objectsApplied = 0;
};
gameObjects.delag = function(clearEffects, deleteSnow)
{
    if(deleteSnow)
    {        
        gameObjects.getObject("snow").length = 0;
    }

    if(clearEffects)
    {
        var clouds = gameObjects.getObject("cloud");

        //Get clouds in screen
        var cloudsIndexes = [];
        for(var i = 0; i < clouds.length; i++)
        {
            if(Math.pow(cam.focusXPos - clouds[i].boundingBox.xPos, 2) +
               Math.pow(cam.focusYPos - clouds[i].boundingBox.yPos, 2) <= 160000)
            {
                cloudsIndexes.push(i);
            }
        }

        var toSleep = (cloudsIndexes.length - 2) - 1;

        //Sleep clouds
        var picked = 0;
        for(var i = 0; i < cloudsIndexes.length; i++)
        {
            if(random(0, 1) < 0.5 || cloudsIndexes.length - i <= toSleep)
            {
                clouds[cloudsIndexes[i]].sleep(1700);
                picked++;
            }

            if(picked > toSleep)
            {
                break;
            }
        }
    }else{
        for(var i = 0; i < cameraGrid.length; i++)
        {
            for(var j = 0; j < cameraGrid[i].length; j++)
            {
                cameraGrid[i][j] = {};
            }
        }
        gameObjects.addObjectsToCameraGrid();
    }
};
gameObjects.applyCollision = function(objectA)
{
    if(objectA.physics.movement === "static" || objectA.physics.skipCollision)
    {
        return; //We don't want to process anything that doesn't move
    }

    var pcs = {};

    var cell, array, objectB, col, row, info;
    
    for(col = objectA._places.upperLeft.col; col <= objectA._places.lowerRight.col; col++)
    {
        for(row = objectA._places.upperLeft.row; row <= objectA._places.lowerRight.row; row++)
        {
            cell = cameraGrid[col][row];

            for(var i in cell)
            {
                //If an object is going to be tested with itself skip the loop
                if(pcs[i] || objectA.arrayName === cell[i].arrayName && objectA.index === cell[i].index)
                {
                    continue;
                }

                array = this[this.references[cell[i].arrayName]] || [];
                objectB = array[cell[i].index];

                if(!objectB || objectB.fake)
                {
                    continue;
                }

                // May need to use this in certain cases.
                /*if(object.physics.movement === "dynamic" || object.physics.changes)
                {
                    cameraGrid.removeReference(object);
                    cameraGrid.addReference(object);
                }*/

                // Test boundingBoxes
                if(!objectA.boundingBox.off && !objectB.boundingBox.off && 
                   !observer.boundingBoxesColliding(objectA.boundingBox, objectB.boundingBox))
                {
                    continue;
                }

                if(objectA.physics.shape === "rect" && objectB.physics.shape === "rect" && 
                    !(objectA.boundingBox.overSized || objectB.boundingBox.overSized) ||
                    observer.colliding(objectA, objectB))
                {
                    info = {};

                    if(objectA.physics.solidObject && objectB.physics.solidObject && 
                       !(objectA.avoidCollision(objectB, info) || objectB.avoidCollision(objectA, info)))
                    {
                        info = observer.solveCollision(objectA, objectB);

                        objectA.updateBoundingBox();
                        objectB.updateBoundingBox();
                    }

                    array.applyObject(cell[i].index);
                    objectA.onCollide(objectB, info);
                    objectB.onCollide(objectA, info);
                }

                pcs[i] = true;
            }
        }
    }
};
gameObjects.apply = function(noApply)
{
    if(noApply)
    {
        return;
    }

    var pcs = {};
    this.indexes = {};

    for(var i = 0; i < this.toOrder.length; i++)
    {
        this.renderPlace[this[this.toOrder[i]].name].length = 0;
    }

    var col, row, cell, i, array, object;

    for(col = cam.upperLeft.col; col <= cam.lowerRight.col; col++)
    {
        for(row = cam.upperLeft.row; row <= cam.lowerRight.row; row++)
        {           
            cell = cameraGrid[col][row];

            for(i in cell)
            {  
                if(pcs[i])
                {
                    continue;
                }

                array = this[this.references[cell[i].arrayName]] || [];
                object = array[cell[i].index];

                //Delete any refs to objects removed
                if(!object || object.fake)
                {
                    delete cameraGrid[col][row][i];
                    continue;
                }

                array.applyObject(cell[i].index); //Needed for moving objects around

                /*Keep the cell up to date
                Note : use this before referencing a cell*/
                if(object.physics.movement === "dynamic" || object.physics.changes)
                {
                    cameraGrid.removeReference(object);
                    cameraGrid.addReference(object);
                }

                if(!game.cutScening || !object.isLifeForm)
                {
                    object.lastXPos = object.xPos;
                    object.lastYPos = object.yPos;

                    object.update();
                    gameObjects.applyCollision(object);
                }

                //Signify that we've used the object for this loop
                pcs[i] = true;
                this.renderPlace[object.arrayName].push(object.index);
                this.indexes[this.references[object.arrayName]] = true;
            }
        }
    }
};

var noop = function() {};
gameObjects.draw = function(noDraw)
{
    if(noDraw)
    {
        return;
    }

    var array, i, j;


    if(levels[levelInfo.level].createStars)
    {
        stroke(255, 255, 255);

        var col, row, _stars, i;

        for(col = cam.upperLeft.col; col <= cam.lowerRight.col; col++)
        {
            for(row = cam.upperLeft.row; row <= cam.lowerRight.row; row++)
            {           
                if(!cameraGrid[col][row]._lights)
                {
                    continue;
                }

                _stars = cameraGrid[col][row]._lights._stars;

                for(i = 0; i < _stars.length; i++)
                {
                    strokeWeight(_stars[i][2]);
                    point(_stars[i][0], _stars[i][1]);
                }
            }
        }

        noStroke();
    }

    var order = [];
    for(i in this.indexes)
    {
        if(order.indexOf(i) === -1)
        {
            order.push(i);
        }
    }

    if(this.objectsApplied >= 2)
    {
        try{
            for(i = 0; i < order.length; i++)
            {
                array = this.renderPlace[this[order[i]].name];

                for(j = 0; j < array.length; j++)
                {
                    this[order[i]][array[j]].draw();
                }
            }
        }
        catch(e)
        {

        }
    }else{
        for(i = 0; i < order.length; i++)
        {
            array = this.renderPlace[this[order[i]].name];

            for(j = 0; j < array.length; j++)
            {
                if(this[order[i]][array[j]])
                {
                    this[order[i]][array[j]].draw();
                }
            }
        }
    }

    this.toOrder = order;
};
gameObjects.updateLoops = 0;
gameObjects.counter = -100;
var lastReleaseMemoryTime = 0;
gameObjects.update = function(remote)
{
    if((screenUtils.fade.fading && game.gameState === "play" && game.tempState !== "load" && 
        gameObjects.updateLoops > 120) && !game.cutScening)
    {
        return;
    }

    var clouds = gameObjects.getObject("cloud");

    //Delag the game when running at over 30 fps with clouds
    if(game.fps > 30 && millis() % 1000 >= 915 && clouds.length >= 4 && clouds.length <= 400)
    {
        if(fpsCatcher.actualFps <= 50)
        {
            frameRate(game.fps);
            this.delag(true);
        }
    }
    if(game.fpsType === "auto" && !remote)
    {
        if(!this.lastCheckTime || millis() - this.lastCheckTime > ((game.fps === 60) ? 600 : 1000))
        {
            if(game.fps === 30 && fpsCatcher.actualFps >= 30)
            {
                game.fps = 60;
                game.applyFps();
            }
            else if(game.fps === 60 && fpsCatcher.actualFps <= 50)
            {
                game.fps = 30;
                game.applyFps();
            }

            this.lastCheckTime = millis();
        }
    }

    this.objectsApplied++;

    gameObjects.apply(messageHandler.active);

    if(game.fps === 30 && game.gameState !== "load")
    {
        gameObjects.apply(messageHandler.active);
    }

    gameObjects.updateLoops++;

    // Release memory from the camera grid every 60 seconds
    if(millis() - lastReleaseMemoryTime > 60000 && cameraGrid.cols < 400 && cameraGrid.rows < 400 && levelInfo.theme !== "space")
    {
        for(var i = 0; i < cameraGrid.length; i++)
        {
            for(var j = 0; j < cameraGrid[i].length; j++)
            {
                var _lights = cameraGrid[i][j]._lights;
                cameraGrid[i][j] = {};
                Object.defineProperty(cameraGrid[i][j], "_lights",
                {
                    value : _lights,
                    enumerable: false,
                    writable: true,
                    configurable: true,
                });  
            }
        }
        gameObjects.addObjectsToCameraGrid();

        lastReleaseMemoryTime = millis();
    }
};

////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
/****************************************************************Effects*******************************************************************/
////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

var lighting = {
    map : [],
    fixtures : {},
    lumin : 0.3,
    maxLighting : 255,
    minLighting : 0,
    end : function()
    {
        if(levelInfo.lastLevel !== levelInfo.level)
        {
            this.fixtures = {};
            this.initFixtures = false;
        }
    },
    create : function(noReload)
    {
        this.lastMaxLighting = this.maxLighting;
        this.maxLighting = 255;

        this.map = [];
        for(var i = 0; i < levelInfo.width / levelInfo.unitWidth + 1; i++)
        {
            this.map.push([]);
            for(var j = 0; j < levelInfo.height / levelInfo.unitHeight + 1; j++)
            {
                this.map[i].push({
                    color : color(0, 0, 0, 0),
                });
            }
        }

        for(var i = 0; i < gameObjects.length; i++)
        {
            if(gameObjects[i].length > 0 && gameObjects[i][0].type === "block" && 
               gameObjects[i][0].width === levelInfo.unitWidth &&
               gameObjects[i][0].height === levelInfo.unitHeight)
            {
                for(var j = 0; j < gameObjects[i].length; j++)
                {
                    var place = this.getPlace(gameObjects[i][j].xPos + 1, gameObjects[i][j].yPos + 1);
                    var cell = this.map[place.col][place.row];
                    cell.usable = true;
                    cell.blockName = gameObjects[i].name; 
                    cell.color = color(red(cell.color), green(cell.color), blue(cell.color), alpha(cell.color));
                }
            }
        }

        levelInfo.halfUnitWidth = levelInfo.unitWidth / 2;
        levelInfo.halfUnitHeight = levelInfo.unitHeight / 2;
        this.blockDist = dist(0, 0, levelInfo.unitWidth, levelInfo.unitHeight);
        this.maxLumin = abs(this.minLighting - this.maxLighting);

        this.img = get(0, 0, 400, 400);   
        this.initFixtures = false;
        this.pg = createGraphics(cam.width, cam.height, P2D);
        this.startMillis = millis();

        this.pg.noStroke();
        this.pg.noSmooth();

        this.map._length = this.map.length - 1;
        this.map[0]._length = this.map[0].length - 1;
    },
    getPlace : function(xPos, yPos)
    {
        return {
            col : constrain(round(((xPos - levelInfo.xPos) - levelInfo.unitWidth / 2) / levelInfo.unitWidth), 0, this.map._length),
            row : constrain(round(((yPos - levelInfo.yPos) - levelInfo.unitHeight / 2) / levelInfo.unitHeight), 0, this.map[0]._length),
        };
    },
    setAllFixtures : function()
    {
        if(this.initFixtures)
        {
            return;
        }

        var inCamFixtures = [];

        for(var fixture in this.fixtures)
        {
            var fixture1 = this.fixtures[fixture];

            if(fixture1.perX !== undefined && fixture1.perY !== undefined && !fixture1.mapped)
            {
                fixture1.xPos = levelInfo.xPos + constrain(fixture1.xPos, fixture1.perX, levelInfo.width - fixture1.perX) - fixture1.halfWidth;
                fixture1.yPos = levelInfo.yPos + constrain(fixture1.yPos, fixture1.perY, levelInfo.height - fixture1.perY) - fixture1.halfHeight;
            }

            inCamFixtures.push(fixture);

            if(fixture1.map === undefined)
            {
                fixture1.map = [[]];
                fixture1.index = 0;
            }
        }

        for(var i = 0; i < this.map.length; i++)
        {
            for(var j = 0; j < this.map[i].length; j++)
            {
                var xPos = levelInfo.xPos + levelInfo.unitWidth * i;
                var yPos = levelInfo.yPos + levelInfo.unitHeight * j;
                var pivotXPos = xPos + levelInfo.halfUnitWidth;
                var pivotYPos = yPos + levelInfo.halfUnitHeight;

                var cell = this.map[i][j];

                for(var k = 0; k < inCamFixtures.length; k++)
                {
                    if(!this.fixtures[inCamFixtures[k]].mapped)
                    {
                        this.setFixture(this.fixtures[inCamFixtures[k]], cell, pivotXPos, pivotYPos, inCamFixtures[k]);
                    }
                }
            }

            for(var k = 0; k < inCamFixtures.length; k++)
            {
                var fixture1 = this.fixtures[inCamFixtures[k]];

                if(!fixture1.mapped && fixture1.map[fixture1.index].length > 0)
                {
                    fixture1.index++;
                    fixture1.map.push([]);
                }
            }
        }

        for(var k = 0; k < inCamFixtures.length; k++)
        {
            var fixture1 = this.fixtures[inCamFixtures[k]];

            if(!fixture1.mapped && fixture1.map.length > 1)
            {
                fixture1.map = this.filterMap(fixture1.map);
                fixture1.mapped = true;
            }
        }

        this.initFixtures = true;

        this.maxLighting = this.lastMaxLighting || 255;
    },
    filterMap : function(map)
    {
        var testMap = [];
        var maxXLength = 0;

        for(var n = 0; n < map.length; n++)
        {
            if(map[n].length > 0)
            {
                testMap.push(map[n]);

                if(maxXLength < map[n].length)
                {
                    maxXLength = map[n].length;
                }
            }
        }

        map = testMap;

        for(var n = 0; n < map.length; n++)
        {   
            while(map[n].length < maxXLength)
            {
                map[n].unshift(0);
                map[n].push(0);
            }

            if(map[n].length > maxXLength)
            {
                map[n].pop();
            }
        }

        return map;
    },
    setFixture : function(fixture, cell, pivotXPos, pivotYPos, fixtureIndex)
    {
        var distance = (Math.pow(Math.abs(fixture.xPos - pivotXPos), 2) +
                        Math.pow(Math.abs(fixture.yPos - pivotYPos), 2));

        if(distance < fixture.range * fixture.range)
        {
            distance = Math.sqrt(distance);

            var percent = ((100 - fixture.brightness) + ((distance / this.blockDist) * 
                          (fixture.centeredLighting || 100) / (fixture.range / this.blockDist)));
            
            var inputAlpha = this.minLighting + (constrain(percent, 1, 100) * max(this.maxLumin, 1) / 100); 
            
            cell.state = fixture.state || cell.state;
            cell.fixtureIndex = fixtureIndex || cell.fixtureIndex;

            if(cell.alpha < this.maxLighting)
            {
                if(inputAlpha < cell.alpha)
                {
                    cell.alpha = inputAlpha;
                }
            }else{
                cell.alpha = inputAlpha;
            }

            if(!fixture.mapped)
            {
                fixture.map[fixture.index].push(cell.alpha);
            }
        }
    },
    setImage : function()
    {
        this.place = this.getPlace((cameraGrid.xPos + (cam.upperLeft.col) * cameraGrid.cellWidth),
        (cameraGrid.yPos + (cam.upperLeft.row) * cameraGrid.cellHeight));
        this.place2 = this.getPlace((cameraGrid.xPos + (cam.lowerRight.col + 2) * cameraGrid.cellWidth), 
        (cameraGrid.yPos + (cam.lowerRight.row + 2) * cameraGrid.cellHeight));

        var i, j;

        for(i = this.place.col; i < min(this.place2.col, this.map.length); i++)
        {
            for(j = this.place.row; j < min(this.place2.row, this.map[i].length); j++)
            {
                this.map[i][j].alpha = this.maxLighting;
            }
        }

        var inCamFixtures = [];

        var col, row, _lights, i;

        for(col = cam.upperLeft.col; col <= cam.lowerRight.col; col++)
        {
            for(row = cam.upperLeft.row; row <= cam.lowerRight.row; row++)
            {
                for(i in cameraGrid[col][row]._lights)
                {
                    inCamFixtures.push(i);
                }
            }
        }

        inCamFixtures.push("player");

        var k, place, halfX, halfY, x, y, cell;
        for(k = 0; k < inCamFixtures.length; k++)
        {
            fixture1 = this.fixtures[inCamFixtures[k]];

            if(!fixture1 || !fixture1.mapped)
            {
                delete this.fixtures[inCamFixtures[k]];
                continue;
            }

            place = this.getPlace(fixture1.xPos, fixture1.yPos);

            halfX = Math.floor(fixture1.map.length / 2);
            halfY = Math.floor(fixture1.map[0].length / 2);

            for(x = 0; x < fixture1.map.length; x++)
            {
                for(y = 0; y < fixture1.map[0].length; y++)
                {
                    cell = (this.map[x + place.col - halfX] || [])[y + place.row - halfY];

                    if(cell && fixture1.map[x][y] > 0)
                    {
                        if(cell.alpha > fixture1.map[x][y])
                        {
                            cell.alpha = fixture1.map[x][y];
                        }
                    }
                }
            }
        }

        var offX = Math.round(cam.focusXPos - cam.halfWidth);
        var offY = Math.round(cam.focusYPos - cam.halfHeight);
        var wd = levelInfo.unitWidth;
        var hd = levelInfo.unitHeight;

        this.pg.beginDraw();
        this.pg.background(0, 0, 0, 0);
        
        for(i = this.place.col; i < Math.min(this.place2.col, this.map.length); i++)
        {
            for(j = this.place.row; j < Math.min(this.place2.row, this.map[i].length); j++)
            {
                this.pg.fill(0, 0, 0, constrain(this.map[i][j].alpha, this.minLighting, this.maxLighting));
                this.pg.fastRect(wd * i - offX, hd * j - offY, wd, hd);
            }
        }
        this.pg.noSourceImg = true;

        this.pg.endDraw();
    },
    draw : function()
    {
        this.working = false;

        // Is it off or too dim?
        if(this.off || this.lumin <= 0 || this.maxLighting < 3 ||
            //Wrong game state? 
            game.gameState !== "play" && game.tempState !== "play" ||
            //Night mode is off or daylightCycle is off.
            (!levelInfo.daylightCycle && !levelInfo.nightMode && 
            !(levels[levelInfo.level] || {}).nightMode))
        {
            return;
        }

        this.working = true;

        //Will execute once
        this.setAllFixtures();

        if(millis() - this.lastSetImageTime > 36)
        {
            this.setImage();
            this.lastSetImageTime = millis();
        }

        image(this.pg, 0, 0);
    },
    lastSetImageTime : millis()
};

var daylightCycle = {
    switchTime : millis(),
    lastMillis : 0,
    defaultDayLength : 1000 * 60,
    dayLength : 1000 * 60,
    state : "day",
    maxLighting : 252,
    first : true,
    defaultDivTime : 140,
    divTime : 100,
    setState : function(state)
    {
        this.switchTime = millis();
        this.state = state;
        this.switchState = undefined;
        this.switching = false;
        this.first = false;

        switch(this.state)
        {
            case "day" :
                lighting.maxLighting = 2; 
                break;

            case "night" :
                lighting.maxLighting = this.maxLighting; 
                break;
        }
    },
    update : function()
    {
        if(!levelInfo.daylightCycle && !levelInfo.nightMode)
        {
            return;
        }
        lighting.off = this.first;

        if(!levelInfo.daylightCycle && levelInfo.nightMode)
        {
            this.setState("night");
            return;
        }

        var div = abs(this.lastMillis - millis()) / this.divTime;
        
        this.switching = false;
        if(abs(millis() - this.switchTime) >= this.dayLength)
        {
            this.switching = true;
            switch(this.state)
            {
                case "day" :
                    this.switchState = "night";
                    lighting.maxLighting += div;
                    if(lighting.maxLighting >= this.maxLighting)
                    {
                        this.setState("night");
                    }
                    break;

                case "night" :
                    this.switchState = "day";
                    lighting.maxLighting -= div;
                    if(lighting.maxLighting <= 2)
                    {
                        this.setState("day");
                    }
                    break;
            }
        }
        this.recMaxLighting = lighting.maxLighting;
        this.lastMillis = millis();
    },
};

var travelObjects = [];
travelObjects.add = function(object)
{
    this.push({
        index : object.index,
        arrayName : object.arrayName,
    });
};

////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
/*************************************************************Game-Objects*****************************************************************/
////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

var GameObject = function(xPos, yPos)
{
    this.xPos = xPos;
    this.yPos = yPos;

    this.boundingBox = {
        xPos : this.xPos,
        yPos : this.yPos,
    };

    this.physics = {
        shape : "?",
        movement : "static",
        solidObject : true,
    };

    this.draw = function() {};
    this.update = function() {};

    this.onCollide = function(object, info) {};
    this.avoidCollision = function(object, info) {};

    this.updateBoundingBox = function() {};

    this.remove = function()
    {
        this.hideDelete = true;
    };
};

var Rect = function(xPos, yPos, width, height)
{
    GameObject.call(this, xPos, yPos);

    this.width = width;
    this.height = height;
    this.halfWidth = this.width / 2;
    this.halfHeight = this.height / 2;
    this.boundingBox.width = width;
    this.boundingBox.height = height;
    this.physics.shape = "rect";
    this.type = "block";

    physics.getMiddleXPos(this);
    physics.getMiddleYPos(this);

    this.draw = function()
    {
        noStroke();
        fill(this.color);
        fastRect(this.xPos, this.yPos, this.width, this.height);
    };
};
gameObjects.addObject("rect", createArray(Rect));

var Circle = function(xPos, yPos, diameter)
{
    GameObject.call(this, xPos, yPos);

    this.diameter = diameter;
    this.radius = this.diameter / 2;
    this.boundingBox.xPos = this.xPos - this.radius;
    this.boundingBox.yPos = this.yPos - this.radius;
    this.boundingBox.width = this.diameter;
    this.boundingBox.height = this.diameter;
    this.physics.shape = "circle";
    this.type = "collision";

    this.rotation = 0;
    this.showRotation = false;

    this.draw = function()
    {
        noStroke();
        fill(this.color);
        circle(this.xPos, this.yPos, this.diameter);

        if(this.showRotation)
        {
            $pjs.pushMatrix();
                translate(this.xPos, this.yPos);
                rotate(this.rotation);
                stroke(0, 0, 0);
                line(0, 0, this.radius * 0.7, this.radius * 0.7);
            $pjs.popMatrix();
        }
    };
};
gameObjects.addObject("circle", createArray(Circle));

var DynamicObject = function()
{
    this.physics.movement = "dynamic";
    this.xVel = 0;
    this.maxXVel = 0;

    this.yVel = 0;
    this.maxYVel = 0;
    this.gravity = 0;
    this.inAir = false;

    this.update = function()
    {
        this.updateVel();
        this.updateBoundingBox();
    };

    this.updateVel = function()
    {
        if(this.autoXDeacl)
        {
            if(this.xVel < 0)
            {
                this.xVel += this.xDeacl;  
            }
            else if(this.xVel > 0)
            {
                this.xVel -= this.xDeacl;
            }
            
            if(Math.abs(this.xVel) < this.xDeacl)
            {
                this.xVel = 0;  
            }
        }
        else if(this.xDeacl !== undefined)
        {
            if(this.xVel > 0)
            {
                this.xVel -= this.xDeacl;
            }
            if(this.xVel < 0)
            {
                this.xVel += this.xDeacl;
            }
            if(this.xVel >= -this.xDeacl && this.xVel <= this.xDeacl)
            {
                this.xVel = 0;
            }

            this.xDeacl = this.lastXDeacl || this.xDeacl;
        }

        if(this.boundingBox.xPos <= levelInfo.xPos)
        {
            this.xVel = max(0, this.xVel);
            this.xPos = abs(this.xPos - this.boundingBox.xPos) + levelInfo.xPos;
        }
        if(this.boundingBox.xPos + this.boundingBox.width >= levelInfo.xPos + levelInfo.width)
        {
            this.xVel = min(0, this.xVel);
            this.xPos = (levelInfo.xPos + levelInfo.width - this.boundingBox.width) - abs(this.boundingBox.xPos - this.xPos) + (this.diameter || 0);
        }
        this.xVel = constrain(this.xVel, -this.maxXVel, this.maxXVel);
        this.xPos += this.xVel;

        if(this.boundingBox.yPos <= levelInfo.yPos)
        {
            this.yPos = abs(this.yPos - this.boundingBox.yPos) + levelInfo.yPos;
            this.yVel = 0;
        }

        if(this.yVel !== 0)
        {
            this.inAir = true;
        }
        if(!this.onLadder)
        {
            this.yVel += this.gravity;
        }
       
        this.inLiquid = false;
        this.onLadder = false;
        
        this.yVel = constrain(this.yVel, -this.maxYVel, this.maxYVel);

        if(this.minYVel !== undefined)
        {
            this.yVel = max(this.yVel, this.minYVel);
        }else{
            this.yVel = max(this.yVel, -this.maxYVel);  
        }
        this.yPos += this.yVel;
    };
};

//The lifeform package (object) must be instantiated with a dynamic object
var LifeForm = function(hp, notNormalDeath)
{
    this.type = "lifeform";
    this.isLifeForm = true;

    //Death stats
    this.maxHp = hp || 5;
    this.hp = this.maxHp;
    this.dead = false;
    this.normalDeath = !notNormalDeath;
    
    //xVel
    this.xAcl = 0.8;//1.0 is the default
    this.xDeacl = 0.05;
    this.maxXVel = 3;

    //yVel
    this.maxYVel = 10; //Max falling speed
    this.minYVel = -18; //Min jumping speed
    this.gravity = 0.325;
    this.jumpHeight = 9.4;

    //Speeds
    this.swimSpeed = 2;
    this.climbSpeed = 2.5;
    this.friction = 1; //Friction as a multiplier
    
    this.revive = function()
    {
        this.dead = false;
        this.hp = this.maxHp;
    };
        
    //Make sure we have damage!
    this.damage = this.damage || 0;

    this.lps = false;

    this.defense = 0;

    this.subDefense = function(amt)
    {
        return (1 - ((amt || Math.min(this.defense, 99)) / 100));
    };

    this.takeDamage = function(object, amt)
    {
        if(!this.lps || performance.now() % this.lps >= this.lps - 1)
        {
            var damage1 = ((object.getDamage !== undefined) ? object.getDamage(object, amt) : (amt || object.damage));
            this.hp -= (damage1) * this.subDefense();

            if(this.scoreValue && this.hp <= 0 && 
            (object.isLifeForm || object.likeLifeForm) && typeof object.score === "number")
            {
                this.killer = {
                    arrayName : object.arrayName,
                    index : object.index
                };
            }
        }
    };

    this.handleDeath = function()
    {
        if(!this.save)
        {
            if(this.killer)
            {
                var object = gameObjects.getObject(this.killer.arrayName)[this.killer.index];
                if(object)
                {
                    object.score += this.scoreValue;
                    this.scoreValue = 0;
                }
            }

            (this.onHandleDeath || function(){})();
            this.remove();
        }
    };

    this.setMaxHp = function(type, amt)
    {
        if(type === "set")
        {
            this.maxHp = amt;
            this.hp = this.maxHp;
        }
        else if(type === "add")
        {
            this.maxHp += amt;
            this.hp = this.maxHp;
        }
    };

    this.update = function()
    {
        //The controls controller for moving
        if(this.controls !== undefined)
        {
            if(this.controls.left())
            {
                this.xVel -= this.xAcl;
            }
            if(this.controls.right())
            {
                this.xVel += this.xAcl;
            }
    
            if(!this.controls.left() && !this.controls.right())
            {
                var xDeacl = ((this.inAir) ? (this.xDeacl * this.friction) * 0.75 : (this.xDeacl * this.friction));
                if(this.inAir)
                {
                    if(this.xVel > 0)
                    {
                        this.xVel += this.xAcl * 0.05;
                    }
                    if(this.xVel < 0)
                    {
                        this.xVel -= this.xAcl * 0.05;
                    }
                }
                if(this.xVel > 0)
                {
                    this.xVel -= xDeacl;
                }
                if(this.xVel < 0)
                {
                    this.xVel += xDeacl;
                }
    
                if(this.xVel > -xDeacl && this.xVel < xDeacl)
                {
                    this.xVel = 0;
                }
            }
            
            if(this.controls.up())
            {
                if(this.inLiquid)
                {
                    this.yVel = -this.swimSpeed; 
                }
                else if(this.onLadder)
                {
                    this.yVel = -this.climbSpeed; 
                }
                else if(!this.inAir)
                {
                    if(this.jumpTime === undefined)
                    {
                        this.yVel = -this.jumpHeight;
                    }else{
                        this.isJumping = true;
                        this.jumpTimer = this.jumpTime;
                    }
                }
                if(this.flying && this.yFlySpeed !== undefined)
                {
                    this.yVel = -this.yFlySpeed;    
                }

                if(this.isJumping)
                {
                    if(this.jumpTimer <= 0 || this.yVel < -this.jumpHeight)
                    {
                        this.isJumping = false;
                    }

                    this.yVel -= this.jumpSpeed || (this.jumpHeight / this.jumpTime);
                    this.jumpTimer--;
                }
            }else{
                this.jumpTimer = 0;
                this.isJumping = false;
            }
            
            if(this.controls.down())
            {
                if(this.inLiquid)
                {
                    this.yVel = this.swimSpeed; 
                }
                else if(this.onLadder)
                {
                    this.yVel = this.climbSpeed; 
                }
                if(this.flying && this.yFlySpeed !== undefined)
                {
                    this.yVel = this.yFlySpeed;    
                }
            }
    
            if(!this.controls.up() && !this.controls.down() && this.onLadder)
            {
                this.yVel = 0;
            }
        }

        //If it fell out of the level restart the level
        if(this.yPos >= levelInfo.yPos + levelInfo.height || this.hp <= 0)
        {
            this.dead = true;
        }
      
        if(this.dead && this.normalDeath)
        {
            this.handleDeath();
        }
        
        this.friction = 1;
        if(this.setXAcl !== undefined)
        {
            this.xAcl = this.setXAcl;
        }

        if(this.frozen)
        {
            this.xVel = constrain(this.xVel, -0.3, 0.3);
            this.yVel = max(this.yVel, -0.3);
        }

        if(!this.stunned)
        {
            this.updateVel();
        }
        this.updateBoundingBox();
    };

    this.__lastOnCollide = this.onCollide;
    this.onCollide = function(object, info)
    {
        if(object.arrayName === "water" && object.freezing)
        {
            //Stop the water from freezing!
            object.temp += object.freezeRate * 3;

            if(object.temp < object.freezeTemp + 3)
            {
                object.temp = object.freezeTemp + 3;
            }
            return;
        }

        this.__lastOnCollide(object, info);
    };
};

var DynamicCircle = function(xPos, yPos, diameter, colorValue)
{
    Circle.call(this, xPos, yPos, diameter);
    DynamicObject.call(this);

    this.color = colorValue;
    this.xAcl = 1.5;
    this.xDeacl = 0.3;
    this.maxXVel = 4;

    this.maxYVel = 12;
    this.gravity = 0.4;
    this.jumpHeight = 10.5;

    this.rotateVel = 0;
    this.rotateFr = 0.3;

    this.updateBoundingBox = function()
    {
        this.boundingBox.xPos = this.xPos - this.radius;
        this.boundingBox.yPos = this.yPos - this.radius;
    };

    this.lastUpdate2 = this.update;
    this.update = function()
    {
        if(this.rotateVel > 0)
        {
            this.rotateVel -= this.rotateFr;
        }
        else if(this.rotateVel < 0)
        {
            this.rotateVel += this.rotateFr;
        }

        if(abs(this.rotateVel) < this.rotateFr)
        {
            this.rotateVel = 0;
        }

        this.rotation += this.rotateVel;

        if(this.rotation > 360)
        {
            this.rotation = 0;
        }
        else if(this.rotation < 0)
        {
            this.rotation = 360;
        }

        this.xVel += this.rotateVel;
            
        if(this.rotateVel !== 0)
        {
            if(this.xVel > 0)
            {
                this.xVel -= this.rotateFr;
            }
            else if(this.xVel < 0)
            {
                this.xVel += this.rotateFr;
            }
        }

        this.lastUpdate2();
    };
};
gameObjects.addObject("dynamicCircle", createArray(DynamicCircle));

var DynamicRect = function(xPos, yPos, width, height, colorValue)
{
    Rect.call(this, xPos, yPos, width, height);
    DynamicObject.call(this);

    this.color = colorValue;
    this.xAcl = 1.5 * 0.7;
    this.xDeacl = 0.4 * 0.3;
    this.maxXVel = 4 * 0.7;

    this.maxYVel = 12 * 0.75;
    this.gravity = 0.4 * 0.6;
    this.jumpHeight = 10.5 * 0.75;
    this.inAir = true;

    this.yAcl = 3;

    this.mass = 2;
    
    this.upForce = 3.51;

    this.lastUpdate3 = this.update;
    this.update = function()
    {
        this.touchingBlock = false;
        this.lastUpdate3();
    };

    this.updateBoundingBox = function()
    {
        this.boundingBox.xPos = this.xPos;
        this.boundingBox.yPos = this.yPos;
    };

    this.onCollide = function(object)
    {
        if(object.physics.movement === "dynamic" && object.physics.shape === "circle")
        {
            physics.push.rectcircle(this, object);
        }
    };
};
gameObjects.addObject("dynamicRect", createArray(DynamicRect));

var BackBlock = function(xPos, yPos, width, height, colorValue)
{
    Rect.call(this, xPos, yPos, width, height);
    this.color = colorValue || color(0, 0, 0, 150);
    this.physics.solidObject = false;
    
    this.draw = function()
    {
        if(!this.imageLoaded)
        {
            var pg = createGraphics(width, height, P2D);
            pg.noStroke();
            pg.beginDraw();
            pg.fill(this.color); 
            pg.rect(0, 0, this.width, this.height, 5);
            for(var x = 0; x < this.width; x += 30)
            {
                for(var y = 0; y < this.height; y += 30)
                {
                    pg.rect(0 + 5 + x, 0 + 5 + y, 20, 20, 5);
                }
            }
            pg.endDraw();
            this.img = pg;

            this.imageLoaded = true;
        }

        image(this.img, this.xPos, this.yPos);
    };

    this.notExplosive = true;
};
gameObjects.addObject("backBlock", createArray(BackBlock));

var Pillar = function(xPos, yPos, width, height, colorValue, pillarBlock)
{
    Rect.call(this, xPos, yPos, width, height);
    this.color = colorValue || color(0, 0, 0, 150);

    this.pillarBlock = pillarBlock;

    this.physics.sides = (this.pillarBlock) ? {} : {
        up : true,
    };

    var wDiv = this.width * 0.1;
    var wVert = this.width * 0.3;
    var hVert = this.height * 0.2;

    if(levelInfo.theme === "underground")
    {
        this.color = color(0, 149, 45);
    } 

    this.draw = function()
    {   
        noStroke();

        fill(this.color);
        fastRect(this.xPos, this.yPos, this.width, this.height);

        strokeWeight(0.8);
        
        stroke(95, 95, 95);

        if(!this.pillarBlock)
        {
            $pjs.pushMatrix();
                translate(this.xPos, this.yPos);
                for(var x = 0; x < this.width; x += (this.width / 5))
                {
                    line(x, 3, x, this.height);
                }
            $pjs.popMatrix();

            strokeWeight(0.3);
            stroke(255, 255, 255);

            beginShape();
                vertex(this.xPos - wVert, this.yPos);
                vertex(this.xPos + this.width + wVert, this.yPos);
                vertex(this.xPos + this.width + wDiv, this.yPos + hVert);
                vertex(this.xPos - wDiv, this.yPos + hVert);
            endShape(CLOSE);

            noStroke();
            fill(85, 85, 85);
            fastRect(this.xPos - wVert, this.yPos, this.width + wVert * 2, 3);
        }else{
            $pjs.pushMatrix();
                translate(this.xPos, this.yPos);
                for(var x = 0; x < this.width; x += (this.width / 5))
                {
                    line(x, 0, x, this.height);
                }
            $pjs.popMatrix();
            
            noStroke();
        }
    };


    var _lastDraw = this.draw;
};
gameObjects.addObject("pillar", createArray(Pillar));

var Tree = function(xPos, yPos, width, height, type)
{
    Rect.call(this, xPos, yPos, width, height);

    this.physics.solidObject = false;

    switch(type)
    {
        case "fur":
            var t_tn = 0.1;

            this._img = createGraphics(this.width, this.height + 30, P2D);

            this.loadDraw = function()
            {
                physics.getMiddleXPos(this);
                physics.getMiddleYPos(this);

                this._img.beginDraw();
                this._img.noStroke();

                var yPos = 0;
                var xPos = 0;
                var middleXPos = xPos + this.width / 2;

                this._img.fill(128, 85, 49);
                this._img.fastRect(floor(middleXPos - this.width * t_tn), floor(yPos + this.height * 0.4), floor(this.width * t_tn * 2), floor(this.height));

                var h = this.height * 0.4;
                var hWidth = this.width * 0.67 * 0.5;

                this._img.pushMatrix();
                this._img.translate(0, 40);
                for(var y = 0; y < 3; y++)
                {
                    this._img.fill(0, 110, 48);
                    this._img.triangle(middleXPos, yPos, floor(middleXPos - hWidth + y * 1), yPos + h, floor(middleXPos + hWidth - y * 1), yPos + h);

                    this._img.fill(0, 133, 50);
                    this._img.triangle(middleXPos, yPos, middleXPos, yPos + h, floor(middleXPos + hWidth - y * 1), yPos + h);

                    this._img.translate(0, -20);
                }
                this._img.popMatrix();
                this._img.endDraw();
            };

            this.toSetAfter = true;
            this.setAfter = function()
            {
                this.loadDraw();

                screenUtils.speedUpImage(this._img);

                this.draw = function()
                {
                    image(this._img, this.xPos, this.yPos);
                };
            };
            break;

        default:
            this.img = trees.createTree(this.width, this.height, 3, 3);

            this.draw = function()
            {
                image(this.img, this.xPos, this.yPos + 5, this.width, this.height);
            };
            break;
    }
};
gameObjects.addObject("tree", createArray(Tree));

var Slope = function(xPos, yPos, width, height, colorValue)
{
    Rect.call(this, xPos, yPos, width, height);
    this.color = colorValue || color(175, 175, 175, 100);
    this.physics.shape = "slope";
    this.direction = "leftup";

    var thicknessX = 0.1;
    var bindingX = 3;
    var thicknessY = 0.1;
    var bindingY = 3;
    this.slip = 0.5;
    this.type = "collision";
    
    this.updateBoundingBox = function()
    {
        this.boundingBox.xPos = this.xPos;
        this.boundingBox.yPos = this.yPos;
    };

    this.draw = function()
    {
        fill(this.color);
        switch(this.direction)
        {
            case "leftup" :
                triangle(this.xPos, this.yPos, this.xPos, this.yPos + this.height, this.xPos + this.width, this.yPos + this.height);
                break;

            case "rightup" :
                triangle(this.xPos, this.yPos + this.height, this.xPos + this.width, this.yPos, this.xPos + this.width, this.yPos + this.height);
                break;

            case "leftdown" :
                triangle(this.xPos, this.yPos, this.xPos + this.width, this.yPos, this.xPos, this.yPos + this.height);
                break;

            case "rightdown" :
                triangle(this.xPos, this.yPos, this.xPos + this.width, this.yPos, this.xPos + this.width, this.yPos + this.height);
                break;
        }
    };
};
gameObjects.addObject("slope", createArray(Slope));

var OneWay = function(xPos, yPos, width, height, colorValue, direction, inHeritance, dynamic)
{
    if(!dynamic)
    {
        Rect.call(this, xPos, yPos, width, height);
    } else {
        DynamicRect.call(this, xPos, yPos, width, height);
    }

    this.type = "block";

    this.color = colorValue;
    this.direction = direction;
    this.physics.sides = {};
    
    switch(this.direction)
    {
        case "left" :
            this.physics.sides.left = true;
            break;

        case "right" :
            this.physics.sides.right = true;
            break;

        case "up" :
            this.physics.sides.up = true;
            break;

        case "down" :
            this.physics.sides.down = true;
            break;
    }

    this.lastDraw = this.draw;
    this.draw = function()
    {
        noStroke();
        fill(this.color);
        fastRect(this.xPos, this.yPos, this.width, this.height);

        var symbol = "L";
        var textXPos = this.width * 0.2;

        $pjs.pushMatrix();
        translate(this.xPos, this.yPos);
        switch(this.direction)
        {
            case "right" :
                translate(this.width, this.height);
                rotate(180);
                break;

            case "up" :
                translate(this.width, 0);
                rotate(90);
                break;

            case "down" :
                translate(0, this.height);
                rotate(270);
                break;
        }
        fill(0, 0, 0, 100);
        textAlign(CENTER, CENTER);
        textSize(20 * this.width / 40);
        fill(0, 0, 0, 100);
        fastRect(this.width * 0.0, 0, this.width * 0.1, this.height);
        fastRect(this.width * 0.3, 0, this.width * 0.1, this.height);
        for(var i = 0; i < floor(this.height / 10); i++)
        {
            text(symbol, 0 + textXPos, 0 + this.height * 0.10 + 10 * i);
        }
        textAlign(NORMAL, NORMAL);
        $pjs.popMatrix();
    };

    if(!inHeritance)
    {
        screenUtils.loadImage(this, true, "oneWay" + this.direction);
    }
};
gameObjects.addObject("oneWay", createArray(OneWay));

var FallingBlock = function(xPos, yPos, width, height, colorValue)
{
    Rect.call(this, xPos, yPos, width, height);
    this.color = colorValue || color(80, 0, 160, 150);
    this.timer = 0;
    this.trigTime = 1;
    this.fallTime = 70;
    this.gravity = 1.5;
    this.type = "block";
    
    //Don't forget to set this to true since this object moves but it's not dynamic
    
    this.physics.sides = {
        up : true,
    };

    if(levelInfo.theme === "underground")
    {
        this.color = color(0, 168, 0, 100);
    }
    
    this.originalYPos = this.yPos;
    this.originalColor = this.color;
    this.opacity = 130;
    this.maxOpacity = 130;
    this.draw = function()
    {
        fill(this.color);
        fastRect(this.xPos, this.yPos, this.width, this.height);
        fastRect(this.xPos + this.width * 0.15, this.yPos + this.height * 0.15, this.width * 0.7, this.height * 0.7);
    };

    this.update = function()
    {
        if(this.activated)
        {
            this.timer++; 
            this.color = color(100, 0, 0, this.opacity);  
            
            if(this.yPos > this.originalYPos && this.opacity > 50)
            {
                this.opacity -= 0.5;
            }
             
            if(this.timer >= this.fallTime)
            {
                this.yPos += this.gravity;
            }

            //Make the bounding box grow with difference in position,
            //So that it always comes back when it gets to the bottom of the level
            if(this.yPos > this.originalYPos)
            {
                this.boundingBox.height = abs(this.yPos - this.originalYPos) + this.height;
            }
                      
            if(this.opacity <= 50)
            {
                this.timer = 0;
                this.activated = false;
                this.opacity = this.maxOpacity;
                this.boundingBox.overSized = false;
                this.yPos = this.originalYPos;
                this.color = this.originalColor;
                this.boundingBox.height = this.height;            
            }
        }
    };
    
    this.onCollide = function(object)
    {
        if((object.type === "lifeform" || (object.arrayName === "crate" && object.noBreak)) && !object.inAir && !this.activated && object.arrayName !== "ninja")
        {
            if(this.timer >= this.trigTime)
            {
                this.boundingBox.overSized = true;
                this.activated = true;
                this.physics.changes = true; 
            }else{  
                if(levelInfo.theme === "winter")
                {
                    this.boundingBox.overSized = true;
                    this.activated = true;
                    this.physics.changes = true; 
                    this.timer = this.fallTime - 10;
                }

                this.timer++;
            } 
        }
    };
};
gameObjects.addObject("fallingBlock", createArray(FallingBlock));

var MovingPlatform = function(xPos, yPos, width, height, colorValue, direction, fixed, noRender)
{
    OneWay.call(this, xPos, yPos, width, height, colorValue, direction, true, !fixed);
    this.physics.independent = true;
    this.updateVel = function() {};
    this.physics.sides = {
        up : true,
    };
    this.physics.movement = (fixed) ? "static" : "dynamic"; 
    this.boundingBox.maxWidth = WIDTH * 0.5;
    
    this.type = "block";

    this.lastUpdate = this.update;
    this.gravity = 0;

    this.xSpeed = 0;
    this.outerXVel = this.xSpeed;
    this.lastXVel = this.outerXVel;

    this.ySpeed = 0;
    this.outerYVel = this.ySpeed;
    this.lastYVel = this.outerYVel;
    
    this.draw = function()
    {
        fill(this.color);
        fastRect(this.xPos, this.yPos, this.width, this.height);
        fill(0, 0, 0, 50);
        triangle(this.xPos, this.yPos, this.xPos + this.width, this.yPos, this.xPos, this.yPos + this.height);
    };
    
    screenUtils.loadImage(this, true, "movingPlatform" + this.color + this.width);

    if(levelInfo.theme === "underground")
    {
        var img = loadedImages["triangleBlockYellow"];

        if(img.__isDirty)
        {
            img.updatePixels();
        }

        this.draw = function()
        {
            ctx.drawImage(img.sourceImg, 0, 0, img.sourceImg.width, img.sourceImg.height, Math.round(this.xPos), Math.round(this.yPos), this.width, this.height);
        };
    }

    this.updateBoundingBox = function()
    {     
        if(this.outerXVel !== 0)
        {
            this.boundingBox.overSized = true;
            if(this.xPos < this.boundingBox.xPos)
            {
                this.boundingBox.width += abs(this.boundingBox.xPos - this.xPos);
                this.boundingBox.xPos = this.xPos;  
            }else{
                var rightX = this.xPos + this.width;
                var rightXB = this.boundingBox.xPos + this.boundingBox.width;
                if(rightX > rightXB)
                {
                    var diff = abs(rightX - rightXB);
                    this.boundingBox.width += diff; 
                    if(this.boundingBox.width >= this.boundingBox.maxWidth)
                    {
                        this.boundingBox.xPos += diff;
                    }
                }
            }
            this.boundingBox.width = min(this.boundingBox.maxWidth, this.boundingBox.width);
        }else{
            this.boundingBox.xPos = this.xPos;
        }
        this.boundingBox.yPos = this.yPos;
    };

    this.toSetAfter = true;
    this.setAfter = function()
    {
        switch(this.type)
        {
            case "blocks":
                this.color = color(0, 90, 150, 90);

                var s = this.width / 4;
                this.height = s;
                this.draw = function() 
                {
                    noStroke();
                    strokeWeight(0.2);

                    var border = 3.5;
                    var x, y, w, h;

                    for(var i = 0; i < this.width; i += s)
                    {
                        x = this.xPos + i;
                        y = this.yPos;

                        fill(this.color);
                        fastRect(x, y, s, s);

                        stroke(0, 0, 10);
                        fill(0, 0, 10);
                        fastRect(x, y, s, border);
                        fastRect(x + s - border, y, border, s);
                        fastRect(x, y + s - border, s, border);
                        fastRect(x, y, border, s)
                    }

                    noStroke();
                };
                break;
        }
    };

    this.changedX = 0;
    this.update = (this.physics.movement === "dynamic") ? function()
    {   
        this.outerXVel = this.nextXVel || this.outerXVel;
        if(this.outerXVel === 0 && this.xSpeed !== 0)
        {
            this.outerXVel = ((random(0, 100) > 50) ? -this.xSpeed : this.xSpeed);
        }
        
        if(this.xPos <= levelInfo.xPos)
        {
            this.outerXVel = this.xSpeed;
        }
        else if(this.xPos >= levelInfo.xPos + levelInfo.width - this.width)
        {
            this.outerXVel = -this.xSpeed;
        }

        this.xPos += this.outerXVel;
        this.nextXVel = undefined;
        
        this.outerYVel = this.nextYVel || this.outerYVel;
        if(this.outerYVel === 0 && this.ySpeed !== 0)
        {
            this.outerYVel = ((random(0, 100) > 50) ? -this.ySpeed : this.ySpeed);
        }
        
        if(this.yPos <= levelInfo.yPos)
        {
            this.outerYVel = this.ySpeed;
        }
        else if(this.yPos >= levelInfo.yPos + levelInfo.width - this.width)
        {
            this.outerYVel = -this.ySpeed;
        }

        this.yPos += this.outerYVel;
        this.nextYVel = undefined;
        this.lastUpdate();
        this.lastXPos = this.xPos;
        this.lastYPos = this.yPos;
        this.lastOuterXVel = this.outerXVel;
        this.changedX--;
    } : this.update;

    this.onCollide = (this.physics.movement === "dynamic") ? function(object)
    {
        if(this.arrayName === object.arrayName || object.arrayName === "snow" || object.arrayName === "rain")
        {
            return;  
        }

        if(object.type === "block" && object.arrayName !== "crate" && (object.arrayName !== "backBlock"))
        {
            this.nextXVel = ((this.xPos > object.xPos) ? this.xSpeed : -this.xSpeed);
            this.nextYVel = ((this.yPos > object.yPos) ? this.ySpeed : -this.ySpeed);
            this.changedX = 20;
        }
        else if(object.physics.movement === "dynamic" || object.arrayName === "crate")
        {
            if(object.yPos + object.height < this.yPos + this.height * 0.3)
            {
                if(this.changedX <= 0 && this.outerXVel !== 0 && abs(object.xVel) < abs(this.outerXVel) && abs(object.xVel) < this.xSpeed)
                {
                    object.xPos += this.outerXVel;
                }
                if(this.outerYVel < 0)
                {
                    object.yVel = max(-1, object.yVel);
                    object.inAir = false;
                    object.yPos -= 2;
                }
                else if(this.outerYVel !== 0 && abs(object.yVel) <= abs(this.outerYVel) && abs(object.yVel) <= this.ySpeed)
                {
                    object.yVel = this.outerYVel;   
                }
            }
            this.xPos = this.lastXPos;
            this.yPos = this.lastYPos;
        }
    } : this.onCollide;
};
gameObjects.addObject("movingPlatform", createArray(MovingPlatform));

var Lava = function(xPos, yPos, width, height, colorValue, damage)
{
    Rect.call(this, xPos, yPos, width, height);
    this.color = colorValue || color(175, 30, 40);
    this.color2 = color(130, 70, 80);
    this.physics.solidObject = false;
    /*Add padding to the boundingBox so it doesn't kill 
    you while your standing on an edge of a block */
    var padding = 0.1;
    var xPadding = this.width * padding;
    var yPadding = this.height * padding;
    var widthPadding = this.width * (1 - padding * 2);
    var heightPadding = this.height * (1 - padding * 2);
    this.boundingBox.xPos = this.xPos + xPadding;
    this.boundingBox.yPos = this.yPos + yPadding;
    this.boundingBox.width = widthPadding;
    this.boundingBox.height = heightPadding;

    this.type = "hazard";

    this.grid = [];
    this.setupGrid = function(cols, rows)
    {
        this.grid.length = 0;
        for(var col = 0; col < cols; col++)
        {
            this.grid.push([]);
            for(var row = 0; row < rows; row++)
            {
                this.grid[col].push(color(random(0, 200), random(0, 25), random(0, 25), random(100, 250)));
            }
        }
    };
    this.drawGrid = function()
    {
        var cellWidth = this.width / this.grid.length;
        var cellHeight = this.height / this.grid[0].length;
        for(var col = 0; col < this.grid.length; col++)
        {
            for(var row = 0; row < this.grid[col].length; row++)
            {
                fill(this.grid[col][row]);
                fastRect(this.xPos + col * cellWidth, this.yPos + row * cellHeight, cellWidth, cellHeight);
            }
        }
    };

    this.setupGrid(3, 3);

    this.draw = function()
    {
        fill(this.color);
        fastRect(this.xPos, this.yPos, this.width, this.height);
        this.drawGrid();
    };

    this.toSetAfter = true;
    this.setAfter = function()
    {
        this.fixturePlace = (this.arrayName + this.index);

        this.getPlace = cameraGrid.getPlace(this.boundingBox.xPos, this.boundingBox.yPos);
        
        lighting.fixtures[this.fixturePlace] = {
            xPos : this.xPos,
            yPos : this.yPos,
            range : 60,
            brightness : 100, //0-100
            centeredLighting : 100,
            state : this.physics.movement,
        };

        lighting.fixtures[this.fixturePlace].place = this.getPlace;

        var place = cameraGrid.getPlace(this.xPos, this.yPos);
        cameraGrid[place.col][place.row]._lights[this.fixturePlace] = this.fixturePlace;
    };

    this.lastUpdate1 = this.update;
    this.update = function()
    {
        var fixture = lighting.fixtures[this.fixturePlace];
        if(this.physics.movement === "dynamic")
        {
            fixture.xPos = this.xPos;
            fixture.yPos = this.yPos;
            this.getPlace = cameraGrid.getPlace(this.boundingBox.xPos, this.boundingBox.yPos);
            fixture.place = this.getPlace;
        }

        this.update = this.lastUpdate1;
    };

    this.num = Math.round(random(0, 1000));
    screenUtils.loadImage(this, true, "lava" + this.num);

    this.damage = damage || 0.1;


    if(levelInfo.theme === "underground")
    {
        this.damage *= 6;
    }

    this.onCollide = function(object)
    {
        if(object.type === "lifeform" && !object.lavaImmune)
        {
            object.takeDamage(this);
        }
    };
};
gameObjects.addObject("lava", createArray(Lava));

var MovingLava = function(xPos, yPos, width, height, colorValue, damage)
{
    Lava.call(this, xPos, yPos, width, height, colorValue);
    MovingPlatform.call(this, xPos, yPos, width, height, colorValue, "left", false);
    this.lastOnCollide = this.onCollide;
    this.imageName = "lava" + this.num;
    
    this.type = "hazard";
    
    this.physics.solidObject = true;

    this.damage = damage || 0.05;
    this.onCollide = function(object)
    {
        this.lastOnCollide(object);
        if(object.type === "lifeform" && !object.lavaImmune)
        {
            object.takeDamage(this);
        }
    };
};
gameObjects.addObject("movingLava", createArray(MovingLava));

var Coin = function(xPos, yPos, diameter, colorValue, amt)
{
    Circle.call(this, xPos, yPos, diameter);
    this.color = colorValue || color(184, 194, 75, 200);
    this.amt = amt || 1;
    this.score = this.amt * 100;
    this.physics.solidObject = false;
    this.type = "item";
    
    this.rot = 0;
    this.rotVel = ((random(0, 100) >= 50) ? -0.75 : 0.75);
    this.maxRot = this.diameter;

    this.draw = function()
    {  
        if(this.doNotDraw)
        {
            return;
        }

        //Shadow splash
        fill(0, 0, 0, 50);
        ellipse(this.xPos, this.yPos, this.rot * this.diameter * 1.3 / this.maxRot, this.diameter * 1.3);

        noStroke();
        fill(this.color);
        ellipse(this.xPos, this.yPos, this.rot, this.diameter);

        //Show a value for abnormal amts
        if(this.amt !== 1 && !(this.arrayName === "hpCoin" && this.amt === 3))
        {
            fill(0, 0, 0, 100);
            textSize(12);       
            textAlign(CENTER, CENTER);
            text(this.amt, this.xPos, this.yPos);
        }
    };
    
    this.startTime = millis();
    this.lastFlickerTime = millis();

    this.lastUpdate = this.update;
    this.update = function()
    {
        this.lastUpdate();

        if(this.rot < -this.maxRot || this.rot > this.maxRot)
        {
            this.rotVel = -this.rotVel;
        }

        this.rot += this.rotVel;

        if(this.doNotSave)
        {
            if(millis() - this.startTime > 3500)
            {
                if(millis() - this.lastFlickerTime > 30)
                {
                    this.doNotDraw = !this.doNotDraw;
                    this.lastFlickerTime = millis();
                }

                if(millis() - this.startTime > 4500)
                {
                    this.remove();
                }
            }
        }
    };

    this.onCollide = function(object)
    {
        if(object.arrayName === "player")
        {
            object.coins += this.amt;
            object.score += this.score;
            sounds.mplaySound("coinSound.mp3");
            this.remove(); //Don't forget to delete the coin!
        }
    };
};
gameObjects.addObject("coin", createArray(Coin));

var HpCoin = function(xPos, yPos, diameter, colorValue, amt)
{
    Coin.call(this, xPos, yPos, diameter);

    this.color = colorValue || color(75, 194, 164 - 50);
    this.type = "item";
    this.amt = amt || 1;
    this.score = this.amt * 100;
    this.physics.solidObject = false;

    this.onCollide = function(object)
    {
        if(object.arrayName === "player")
        {
            object.hp += this.amt;
            object.hp = min(object.hp, object.maxHp);
            object.score += this.score;
            sounds.mplaySound("coinSound.mp3");
            this.remove(); //Don't forget to delete the hpCoin!
        }
    };
};
HpCoin.prototype = Object.create(Coin.prototype);
gameObjects.addObject("hpCoin", createArray(HpCoin));

var Ring = function(xPos, yPos, diameter, colorValue)
{
    Circle.call(this, xPos, yPos, diameter);
    this.color = colorValue;
    this.type = "collision";

    this.angle = 0;
    this.bladeSpeed = Math.round(random(3, 8)) * ((random(0, 100) > 50) ? 1  : -1) * 0.75;
    this.bladeColor = color(0, 100, 230);

    this.arcSize = this.diameter * 2 / 3;
    this.bladeRanges = [
        [0, 90],
        [90, 180],
        [180, 270],
        [270, 360]
    ];

    if(MODE === "pjs")
    {
        for(var i = 0; i < this.bladeRanges.length; i++)
        {
            this.bladeRanges[i][0] *= PI_MULT;
            this.bladeRanges[i][1] *= PI_MULT;
        }
    }

    this.draw = function()
    {
        noStroke();
        fill(this.color);
        circle(this.xPos, this.yPos, this.diameter);
       
        $pjs.pushMatrix();
        translate(this.xPos, this.yPos);
        rotate(this.angle);
        fill(this.bladeColor);
        arc(0, 0, this.arcSize, this.arcSize, this.bladeRanges[1][0], this.bladeRanges[1][1]);
        arc(0, 0, this.arcSize, this.arcSize, this.bladeRanges[3][0], this.bladeRanges[3][1]);
        $pjs.popMatrix();
    };

    this.lastUpdate = this.update;
    this.update = function()
    {
        this.lastUpdate();
        this.angle += this.bladeSpeed;
    };
};
gameObjects.addObject("ring", createArray(Ring));

var PhaserBlast = function(xPos, yPos, diameter, colorValue)
{
    Circle.call(this, xPos, yPos, diameter);
    
    this.hp = 1;
    this.damage = 2;

    this.physics.solidObject = false;
    this.physics.shape = "point";
     
    this.boundingBox = {};
    this.boundingBox.off = true;
    this.physics.movement = "dynamic";

    this.color = colorValue;

    this.xVel = 0;
    this.yVel = 0;

    this.life = 100;
    this.maxVel = 22;
    this.blastAngle = 0;

    this.streakLength = 14;

    this.draw = function()
    {        
        stroke(this.color);
        strokeWeight(this.diameter);
        line(this.xPos, this.yPos, this.xPos + Math.cos(this.blastAngle) * this.streakLength, 
                                   this.yPos + Math.sin(this.blastAngle) * this.streakLength);
        noStroke();
    };

    this.lastUpdate = this.update;
    this.update = function()
    {
        this.lastUpdate();
        
        this.life--;
        if(this.life < 0)
        {
            this.remove();
        }
        
        this.acl = this.maxVel;
        this.xVel = this.acl * cos(this.blastAngle);
        this.xVel = constrain(this.xVel, -this.maxVel, this.maxVel);
        this.xPos += this.xVel;
        
        this.yVel = this.acl * sin(this.blastAngle);
        this.yVel = constrain(this.yVel, -this.maxVel, this.maxVel);
        this.yPos += this.yVel;

        // if(Math.abs(this.xPos - cam.focusXPos) > cam.halfWidth || 
        //    Math.abs(this.yPos - cam.focusYPos) > cam.halfHeight)
        // {
        //     this.remove();
        // }
    };

    this.onCollide = function(object)
    {
        if(object.isLifeForm && object.arrayName !== this.shooterArrayName)
        {
            object.takeDamage(this);
            this.remove();
            gameObjects.getObject("phaserBlast").applyObject(this.index);
        }
    };
};

gameObjects.addObject("phaserBlast", createArray(PhaserBlast));

var Bomb = function(xPos, yPos, diameter, colorValue, life)
{
    Circle.call(this, xPos, yPos, diameter);

    this.hp = 1;
    this.damage = 8;

    this.physics.solidObject = false;
    this.physics.shape = "point";
     
    this.boundingBox = {};
    this.boundingBox.off = true;
    this.physics.movement = "dynamic";

    this.xVel = 0;
    this.yVel = 0;

    this.gravity = 0;

    this.color = colorValue;
    this.physics.solidObject = false;

    this.driftXVel = random(-2, 2);
    this.driftYVel = random(-2, 2);

    this.life = life || 100;

    this.diameterPercent = 1;

    this.draw = function()
    {
        noStroke();
        fill(this.color);
        circle(this.xPos, this.yPos, this.diameter * this.diameterPercent);

        fill(0, 0, 0, 100);
        circle(this.xPos, this.yPos, (this.diameter - 8) * this.diameterPercent);
    };

    var _lastUpdate = this.update;
    this.update = function()
    {
        this.xPos += this.driftXVel;
        this.yPos += this.driftYVel;

        this.xPos += (this.outXVel || 0);
        this.yPos += (this.outYVel || 0);

        _lastUpdate.apply(this, arguments);
        this.life--;

        if(this.life < 200)
        {
            this.diameterPercent = this.life / 200;

            if(this.life < 0)
            {
                this.kill();
            }
        }
    };

    this.kill = function()
    {
        cameraGrid.removeReference(this);

        this.onCollide = function() {};
        this.draw = function() {};
        this.update = function() {};

        this.remove();
    };

    this.onCollide = function(object)
    {
        if(object.arrayName === "phaserBlast")
        {
            this.kill();
            return;
        }

        if(object.isLifeForm && object.arrayName !== this.shooterArrayName)
        {
            sounds.mplaySound("hit2.mp3");
            object.takeDamage(this);

            this.kill();
        }
    };
};
gameObjects.addObject("bomb", createArray(Bomb));

var Missle = function(xPos, yPos, diameter, colorValue, targetObject, life)
{
    Circle.call(this, xPos, yPos, diameter);

    this.hp = 1;
    this.damage = 10;

    this.physics.solidObject = false;
    this.physics.shape = "point";

    this.boundingBox = {};
    this.boundingBox.off = true;
    this.physics.movement = "dynamic";

    this.color = colorValue;

    this.xVel = 0;
    this.yVel = 0;

    this.outXVel = 0;
    this.outYVel = 0;

    this.speedAcl = 0.4;
    this.speed = 3;
    this.maxSpeed = 20;

    this.rotation = 0;

    this.targetObject = targetObject;

    this.life = life || 500;

    this.draw = function()
    {
        // strokeWeight(this.diameter * 2);
        // stroke(255, 255, 255, 90);

        // line(this.xPos, this.yPos, this.xPos + Math.cos(this.rotation) * 20, 
        //                            this.yPos + Math.sin(this.rotation) * 20);

        strokeWeight(this.diameter);
        stroke(this.color);

        line(this.xPos, this.yPos, this.xPos + Math.cos(this.rotation) * 36, 
                                   this.yPos + Math.sin(this.rotation) * 36);
        noStroke();
    };

    this.switchTimes = 0;
    this.maxSwitchTimes = 3000;//20;

    this.lastSwitchTime = millis();
    this.switchTimeInterval = 0;//500;

    this.toggle = true;
    this.lastToggleTime = millis();
    this.toggleInterval = 500;

    var _lastUpdate = this.update;
    this.update = function()
    {
        this.xVel = 0;
        this.yVel = 0;

        _lastUpdate.apply(this, arguments);
        this.life--;

        if(this.life < 0)
        {
            this.kill();
        }

        if(millis() - this.lastToggleTime > this.toggleInterval)
        {
            this.toggle = !this.toggle;

            if(this.toggle)
            {
                this.toggleInterval = 1400;
            }else{
                this.toggleInterval = 500;
            }

            this.lastToggleTime = millis(); 
        }

        this.speed = Math.min(this.speed + this.speedAcl, this.maxSpeed); 

        if(this.toggle && typeof this.targetObject === "object" && this.switchTimes < this.maxSwitchTimes && millis() - this.lastSwitchTime > this.switchTimeInterval)
        {
            var obj = this.targetObject;
            var targetRotation = atan2(obj.yPos + obj.halfHeight - this.yPos, 
                                     obj.xPos + obj.halfWidth - this.xPos);

            this.angle = physics.formulas.resolveAngle(this.rotation * RAD_TO_DEG);
            var targetAngle = physics.formulas.resolveAngle(targetRotation * RAD_TO_DEG);

            if(physics.formulas.findDirection(this.angle, targetAngle))
            {
                this.rotation += 2 * DEG_TO_RAD;
            }else{
                this.rotation -= 2 * DEG_TO_RAD;
            }

            this.outXVel = cos(this.rotation) * this.speed;
            this.outYVel = sin(this.rotation) * this.speed;

            this.switchTimes++;

            this.lastSwitchTime = millis();
        }

        this.xPos += this.outXVel;
        this.yPos += this.outYVel;
    };

    this.kill = function()
    {
        cameraGrid.removeReference(this);

        this.onCollide = function() {};
        this.draw = function() {};
        this.update = function() {};

        this.remove();
    };

    this.onCollide = function(object)
    {
        if(object.isLifeForm && object.arrayName !== this.shooterArrayName)
        {
            object.takeDamage(this);
            sounds.mplaySound("hit2.mp3");
            this.kill();
            gameObjects.getObject("missle").applyObject(this.index);
        }
    };
};
gameObjects.addObject("missle", createArray(Missle));

var TalonShip = function(xPos, yPos, width, height)
{
    DynamicRect.call(this, xPos, yPos, width, height);
    LifeForm.call(this, 300);

    this.physics.solidObject = false;

    this.scoreValue = 2600;
    this.isBoss = true;

    this.gravity = 0;
    this.angle = 180;

    var self = this;
    var _this = this;

    this.firstMiddleXPos = xPos + width / 2;
    this.firstMiddleYPos = yPos + height / 2;

    this.flames = [];
    this.flames.add = function(x, y)
    {
        this.push({
            x : x, 
            y : y,
            angle : 90 + random(-10, 10),
            speed : random(1, 2) * 8,
            diameter : ((random() < 0.5) ? 6 : 7),
            color : color(9, 170, 100, 210),
            life : random(5, 20) * (_this.speed / _this.maxSpeed), 
            length : Math.round(random(1, 3)) * 8
        });
    };
    this.flames.draw = function()
    {
        noStroke();
        strokeWeight(1);
        for(var i = 0; i < this.length; i++)
        {
            fill(this[i].color);
            fastRect(this[i].x, this[i].y, Math.round(random(2, 4)), this[i].length);
        }
    };
    this.flames.update = function()
    {
        var a;
        for(var i = this.length - 1; i >= 0; i--)
        {
            if(this[i].life < 0)
            {
                this.splice(i, 1);
                continue;
            }

            this[i].life--;

            a = this[i].angle * DEG_TO_RAD;
            this[i].x += cos(a) * this[i].speed;
            this[i].y += sin(a) * this[i].speed;
        }
    };

    this.f_lastAddTime = 0;
    this.f_nextTime = random(20, 50);

    this.draw = function()
    {
        if(this.flames.length < 100 && millis() - this.f_lastAddTime > this.f_nextTime)
        {
            for(var i = 0; i < random(3, 5); i++)
            {
                this.flames.add(random(-18, 18), this.halfHeight - 20);
            }

            this.f_lastAddTime = millis();
            this.f_nextTime = random(20, 50);
        }

        $pjs.pushMatrix();
            translate(this.middleXPos, this.middleYPos);
            rotate(this.angle + 90);

            if(this.hp > 0)
            {
                this.flames.draw();
                this.flames.update();
            }

            this.imageName = "talonShip";

            ctx.drawImage(loadedImages[this.imageName].sourceImg, -this.halfWidth, -this.halfHeight, this.width, this.height);
        $pjs.popMatrix();
    };

    this.emitters = [];
    this.stepEmitters = function()
    {
        for(var i = this.emitters.length - 1; i >= 0; i--)
        {
            if(millis() - this.emitters[i].startTime > this.emitters[i].time)
            {
                this.emitters[i].func.apply(this, this.emitters[i].info);
                this.emitters.splice(i, 1);
            }
        }
    };
    this.emit = function(info, time, func)
    {
        this.emitters.push({
            info : info,
            time : time,
            func : func,
            startTime : millis()
        });
    };

    this.state = "idle";
    this.speed = 0;
    this.maxSpeed = 10;

    var lastShiftTime = millis();
    var shiftInterval = 300;
    var correcting = true;

    var lastAddBombTime = millis();
    var addBombInterval = 6000;

    var driftTime = 1500;
    var lastDriftMillis = millis();
    var driftInterval = 8000;

    var lastAngleChangeTime = millis();
    var angleChangeInterval = 1000;

    this.outXVel = 0;
    this.outYVel = 0;

    // this.updateBoundingBox = function()
    // {
    //     var box = this.boundingBox;

    //     box.xPos = this.xPos + 30;
    //     box.yPos = this.yPos + 30;
    //     box.width = this.width - 60;
    //     box.height = this.height - 60;
    // };

    this.bail = function()
    {
        this.state = "run";

        this.emit([], 1000, function()
        {
            this.state = "drift";
        });
    };

    this.runTargetAngle = 0;

    var _lastUpdate = this.update;

    this.__lastUpdate = _lastUpdate;

    this.update = function(remote)
    {
        this.updateBoundingBox();

        if(!remote)
        {
            return;
        }

        this.stepEmitters();

        this.xVel = 0;
        this.yVel = 0;

        _lastUpdate.apply(this, arguments);

        physics.getMiddleXPos(this);
        physics.getMiddleYPos(this);

        var helixShip = gameObjects.getObject("helixShip")[0];

        switch(this.state)
        {
            case "start" :
                this.state = "follow";
                this.speed = 0;
                break;

            case "follow" :

                // if(millis() - lastShiftTime > shiftInterval)
                // {
                //     correcting = !correcting;
                //     lastShiftTime = millis();
                // }

                correcting = true;

                if(correcting)
                {
                    var dx = helixShip.middleXPos - this.middleXPos,
                        dy = helixShip.middleYPos - this.middleYPos;

                    if(dx * dx + dy * dy > 150 * 150)
                    {
                        var angle = atan2(dy, dx);
                        var targetAngle = angle * RAD_TO_DEG;

                        this.angle = physics.formulas.resolveAngle(this.angle);
                        targetAngle = physics.formulas.resolveAngle(targetAngle);

                        if(physics.formulas.findDirection(this.angle, targetAngle))
                        {
                            this.angle += 1.6;
                        }else{
                            this.angle -= 1.6;
                        }

                        if(Math.abs(this.angle - targetAngle) <= 3.2)
                        {
                            this.angle = targetAngle;
                        }

                        this.speed = 9;
                        this.outXVel = cos(this.angle * DEG_TO_RAD) * this.speed;
                        this.outYVel = sin(this.angle * DEG_TO_RAD) * this.speed;
                    }else{
                        // Hmm too close to helix's Ship.
                        // But we don't want this behavior all the time.
                        // So add a little bit of randomness to it.
                        if(Math.random() < 0.5)
                        {
                            this.bail();
                        }
                    }
                }

                if(millis() - lastDriftMillis > driftInterval)
                {
                    this.state = "drift";
                    lastDriftMillis = millis();
                }
                break;

            case "return" :
                var dx = this.firstMiddleXPos - this.middleXPos,
                    dy = this.firstMiddleYPos - this.middleYPos;

                var tAngle = atan2(dy, dx) * RAD_TO_DEG;

                this.angle = physics.formulas.resolveAngle(this.angle);
                tAngle = physics.formulas.resolveAngle(tAngle);

                if(physics.formulas.findDirection(this.angle, tAngle))
                {
                    this.angle += 2;
                }else{
                    this.angle -= 2;
                }

                if(Math.abs(this.angle - tAngle) <= 4)
                {
                    this.angle = tAngle;
                }

                this.speed = 10;
                this.outXVel = cos(this.angle * DEG_TO_RAD) * this.speed;
                this.outYVel = sin(this.angle * DEG_TO_RAD) * this.speed;

                if(dx * dx + dy * dy < 600 * 600)
                {
                    this.state = "start";
                }

                if(this.hp * 100 / this.maxHp < 20)
                {
                    // this.state = "rage";
                    this.state = "run";
                }
                break;

            case "drift" :
                this.speed = 9;
                this.outXVel = cos(this.angle * DEG_TO_RAD) * this.speed;
                this.outYVel = sin(this.angle * DEG_TO_RAD) * this.speed;

                if(--driftTime < 0)
                {
                    this.state = "follow";
                    lastDriftMillis = millis() + 5000;
                    driftTime = 1000;
                }
                break;

            case "lowHp" :
                break;

            case "rage" :
                break;

            case "run" :
                this.speed = 10;

                if(millis() - lastAngleChangeTime > angleChangeInterval)
                {
                    this.runTargetAngle = random(0, 360);

                    lastAngleChangeTime = millis();
                }

                if(typeof this.runTargetAngle === "number")
                {
                    var tAngle = this.runTargetAngle;

                    this.angle = physics.formulas.resolveAngle(this.angle);
                    tAngle = physics.formulas.resolveAngle(tAngle);

                    if(physics.formulas.findDirection(this.angle, tAngle))
                    {
                        this.angle += 1;
                    }else{
                        this.angle -= 1;
                    }

                    if(Math.abs(this.angle - tAngle) <= 2)
                    {
                        this.angle = tAngle;
                    } 
                }

                this.outXVel = cos(this.angle * DEG_TO_RAD) * this.speed;
                this.outYVel = sin(this.angle * DEG_TO_RAD) * this.speed;

                if(millis() - this.lastStateChangeTime > 10000)
                {
                    this.state = "start";
                }
                break;
        }

        // if(this.hp * 100 / this.maxHp < 14)
        // {
        //     // this.state = "rage";
        //     this.state = "run";
        // }

        if(this.state !== "return")
        {
            var dx = this.firstMiddleXPos - this.middleXPos,
                dy = this.firstMiddleYPos - this.middleYPos;

            var radiusSq = (levelScripts[levelInfo.level] || { ring : {} }).ring.radiusSq;

            if(dx * dx + dy * dy > radiusSq)
            {
                // var lastState = this.state;
                this.state = "return";

                // this.emit([], 1000, function()
                // {
                //     this.state = lastState;
                // });
            }
        }

        if(["follow", "return", "rage", "lowHp", "run", "drift"].indexOf(this.state) !== -1)
        {
            this.shoot();

            if(millis() - lastAddBombTime > addBombInterval)
            {
                this.addBomb();

                lastAddBombTime = millis();
                addBombInterval = round(random(4500, 7000));
            }
        }

        this.xPos += this.outXVel;
        this.yPos += this.outYVel;

        this.xPos = constrain(this.xPos, 0, levelInfo.width - this.width);
        this.yPos = constrain(this.yPos, 0, levelInfo.height - this.height);

        this.updateBoundingBox();

        cameraGrid.removeReference(this);
        cameraGrid.addReference(this);

        if(typeof this.lastHp === "number" && this.lastHp !== this.hp)
        {
            if(this.lastHp > this.hp)
            {
                this.turnDir = (random() < 0.5) ? -1 : 1;

                this.emit([], 1000, function()
                {
                    this.turnDir = 0;
                });
            }
        }

        if(this.turnDir)
        {
            this.angle += this.turnDir;
            this.runTargetAngle += this.turnDir;
        }

        this.lastHp = this.hp;

        if(typeof this.lastState === "string" && this.lastState !== this.state)
        {
            this.lastStateChangeTime = millis();
        }
        
        this.lastState = this.state;
    };

    this.lastStateChangeTime = 0;

    this.turrets = [];
    this.turrets.add = function(x, y, fire)
    {
        this.push({
            x : x,
            y : y,
            fire : fire,
            angle : atan2(y, x),
            length : Math.sqrt(x * x + y * y)
        })
    };

    function shoot(turrets)
    {
        var angle = this.angle + (self.angle + 90) * DEG_TO_RAD;

        var blast = gameObjects.getObject("phaserBlast").add(
            Math.round(self.middleXPos + Math.cos(angle) * this.length), 
            Math.round(self.middleYPos + Math.sin(angle) * this.length), 4, color(19, 200, 65));

        blast.blastAngle = self.angle * DEG_TO_RAD;
        blast.life = 200;
        blast.shooterArrayName = self.arrayName;
        blast.maxVel = 32;

        cameraGrid.addReference(blast);
    }

    this.turrets.add(-52, -122, shoot);
    this.turrets.add( 52, -122, shoot);

    this.lastShootTime = 0;
    this.shootInterval = 400;

    this.shoot = function()
    {
        if(millis() - this.lastShootTime > this.shootInterval)
        {
            for(var i = 0; i < this.turrets.length; i++)
            {
                this.turrets[i].fire.call(this.turrets[i], this.turrets);
            }

            this.lastShootTime = millis();
        }
    };

    function blastMissle()
    {
        if(this.hp * 100 / this.maxHp < 60)
        {
            this.blastMissle();
        }

        if(this.hp * 100 / this.maxHp < 30)
        {
            this.emit([], 750 + 50, blastMissle);
        }else{
            this.emit([], 1500 + 50, blastMissle);
        }
    }

    this.emit([], 3000, blastMissle)

    this.blastMissle = function()
    {
        var missle = gameObjects.getObject("missle").add(this.middleXPos, this.middleYPos, 9, color(19, 200, 65), gameObjects.getObject("helixShip")[0]);
        missle.shooterArrayName = this.arrayName;
        cameraGrid.addReference(missle);
    };

    this.addBomb = function()
    {
        var bombs = gameObjects.getObject("bomb");

        var bomb = bombs.add(this.middleXPos, this.middleYPos - 40, 30, color(19, 200, 65, 214), 300);
        bomb.shooterArrayName = this.arrayName;

        cameraGrid.addReference(bomb);
    };
};
gameObjects.addObject("talonShip", createArray(TalonShip));

// Helix's Space Ship
var HelixShip = function(xPos, yPos, width, height)
{
    DynamicRect.call(this, xPos, yPos, width, height);
    LifeForm.call(this, 150);

    this.physics.solidObject = false;

    if(levelInfo.level !== "desert oasis")
    {
        this.angle = 0;
    }else{
        this.angle = 30;
    }

    this.goto = shipGoto;

    this.messages = {
        up : true,
        "start" : {
            message : "Ship: Down to open hatch, q to enter.",
            choices : {
                "exit" : "..."
            }
        }
    };

    var _this = this;

    this.maxSpeed = 14;
    this.minSpeed = -3;

    this.flames = [];
    this.flames.add = function(x, y)
    {
        this.push({
            x : x, 
            y : y,
            angle : 90 + random(-10, 10),
            speed : random(1, 2) * 8,
            diameter : ((random() < 0.5) ? 6 : 7),
            color : color(9, 100, 170, 210),
            life : random(5, 20) * (_this.speed / _this.maxSpeed),
            length : Math.round(random(1, 3)) * 8
        });
    };
    this.flames.draw = function(x, y)
    {
        noStroke();
        strokeWeight(1);
        for(var i = 0; i < this.length; i++)
        {
            fill(this[i].color);
            fastRect((x || 0) + this[i].x, (y || 0) + this[i].y, Math.round(random(2, 4)), this[i].length);
        }
    };
    this.flames.update = function()
    {
        var a;
        for(var i = this.length - 1; i >= 0; i--)
        {
            if(this[i].life < 0)
            {
                this.splice(i, 1);
                continue;
            }

            this[i].life--;

            a = this[i].angle * DEG_TO_RAD;
            this[i].x += cos(a) * this[i].speed;
            this[i].y += sin(a) * this[i].speed;
        }
    };

    this.f_lastAddTime = 0;
    this.f_nextTime = random(20, 50);

    // this.updateBoundingBox = function()
    // {
    //     this.boundingBox.overSized = true;
    //     this.boundingBox.xPos = this.middleXPos - this.width;
    //     this.boundingBox.width = this.width * 2;

    //     this.boundingBox.yPos = this.yPos;
    //     this.boundingBox.height = this.height;
    // };

    // this.AABB = {};

    // this.updateAABB = function()
    // {
    //     this.AABB.left = this.xPos;
    //     this.AABB.right = this.xPos + this.width;
    //     this.AABB.up = this.middleXPos - this.halfWidth;
    //     this.AABB.down = this.middleXPos + this.halfHeight;
    // };

    // this.updateAABB();

    this.points = [];
    this.points.add = function(x, y)
    {
        this.push({
            xPos : x, 
            yPos : y,
            angle : atan2(y, x),
            length : Math.sqrt(x * x + y * y)
        });
    };
    this.points.update = function()
    {
        var angle = self.angle * DEG_TO_RAD;
        var a;

        for(var i = this.length - 1; i >= 0; i--)
        {
            this[i].xPos = Math.cos(a = angle + this[i].angle) * this[i].length;
            this[i].yPos = Math.sin(a) * this[i].length;
        }
    };
    this.points.draw = function(x, y)
    {
        strokeWeight(2);
        stroke(255, 23, 90, 200);
        fill(255, 23, 90, 200);
        for(var i = this.length - 1; i >= 0; i--)
        {
            point(self.middleXPos + this[i].xPos + (x || 0), self.middleYPos + this[i].yPos + (y || 0));
        }
        noStroke();
    };

    this.points.add(-this.halfWidth + 4, 76);
    this.points.add(this.halfWidth - 4, 76);
    this.points.add(0, -this.halfHeight + 3);
    this.points.add(0, this.halfHeight - 3);

   /* this.updateBoundingBox = function()
    {
        this.points.update();

        // Get ready to do work
        var left = Infinity, right = 0, up = Infinity, down = 0;
        var i;

        // Do our work
        for(i = 0; i < this.points.length; i++)
        {
            if(this.points[i].xPos < left)
            {
                left = this.points[i].xPos;
            }
            if(this.points[i].xPos > right)
            {
                right = this.points[i].xPos;
            }
            if(this.points[i].yPos < up)
            {
                up = this.points[i].yPos;
            }
            if(this.points[i].yPos > down)
            {
                down = this.points[i].yPos;
            }
        }

        physics.getMiddleXPos(this);
        physics.getMiddleYPos(this);

        // Finish off our work
        left += this.middleXPos;
        right += this.middleXPos;
        up += this.middleYPos;
        down += this.middleYPos;

        left += 30;
        right -= 30;
        up += 30;
        down -= 30;

        var box = this.boundingBox;
        box.xPos = left;
        box.yPos = up;
        box.width = right - left;
        box.height = down - up;
    };*/

    this.addFlames = function(x, y)
    {
        if(this.flames.length < 100 && millis() - this.f_lastAddTime > this.f_nextTime)
        {
            for(var i = 0; i < random(3, 5); i++)
            {
                this.flames.add((x || 0) + random(-18, 18), (y || 0) + this.halfHeight - 20);
            }

            this.f_lastAddTime = millis();
            this.f_nextTime = random(20, 50);
        }
    };

    this.draw = function(x, y)
    {
        this.addFlames();

        pushMatrix();
            translate(this.middleXPos + (x || 0), this.middleYPos + (y || 0));
            rotate(this.angle);

            if(this.hp > 0)
            {
                this.flames.draw();
                this.flames.update();
            }

            fill(this.color);

            this.imageName = "helixShip";

            if(this.hatchOpen)
            {
                this.imageName += "Open";
            }

            // ctx.drawImage(loadedImages[this.imageName].sourceImg, -this.halfWidth, -this.halfHeight, this.width, this.height);
            image(loadedImages[this.imageName], -this.halfWidth, -this.halfHeight, this.width, this.height);

        popMatrix();

        if((levelScripts[levelInfo.level] || {}).battling)
        {
            pushMatrix();
            translate(this.middleXPos, this.middleYPos);

                fill(73, 155, 195, 150);
                var talonShip = gameObjects.getObject("talonShip")[0];
                rotate(atan2(talonShip.middleYPos - this.middleYPos, talonShip.middleXPos - this.middleXPos) * RAD_TO_DEG);
                rect(this.width * 1.3, 0, 12, 60);

            popMatrix();
        }
    };

    this.lastChangeTime = 0;

    var loops = 0;
    var self = this;

    this.speed = 0;

    this.controls = {
        loadInterior : function()
        {
            return keys.q && !(levelScripts[levelInfo.level] || {}).battling;
        },
        shoot : function()
        {
            return keys[" "];
        },
    };

    var lastAddBombTime = millis(),
        addBombInterval = 2000;

    var _lastUpdate = this.update;
    this.update = function()
    {
        // _lastUpdate.apply(this, arguments);

        if(this.hp <= 0)
        {
            window.location.reload();
        }

        if(!levels["desert oasis"].save.messaged && loops > 200)
        {
            talkHandler.start(this.messages, "start", "", true);
            levels["desert oasis"].save.messaged = true;
        }

        loops++;

        if(this.goto.launched)
        {
            if(!this.vInit)
            {
                console.log("launching!");
                cam.scaleOut = 0;

                cam.attach(function()
                {
                    return self;
                }, 
                true, 1500, function()
                {
                    cam.attach(function()
                    {
                        cam.keepInGrid = false;

                        return self;
                    },
                    true, 9999999999, function()
                    {   
                        cam.keepInGrid = true;
                    });
                });
               
                this.vInit = true;
            }

            cam.scaleOut = max(cam.scaleOut -= 0.003, -0.6);

            if(levels[levelInfo.level].createStars)
            {
                var angle = (this.angle - 90) % 360 + 180;

                this.speed = constrain(this.speed, this.minSpeed, this.maxSpeed);

                this.xVel = sin(this.angle * DEG_TO_RAD) * this.speed;
                this.yVel = cos(this.angle * DEG_TO_RAD) * -this.speed;

                if(player.controls.up())
                {
                    this.speed += 0.1;
                }
                else if(player.controls.down())
                {
                    this.speed -= 0.1;
                }else{
                    this.speed -= 0.05;

                    this.speed = Math.max(0, this.speed);
                }

                if(player.controls.left())
                {
                    this.angle -= 3.6;
                }
                if(player.controls.right())
                {
                    this.angle += 3.6;                
                }

                cam.keepInGrid = true;

                if(this.controls.loadInterior())
                {
                    this.loadInterior();
                }

                if((player.controls.activate() || this.controls.shoot()) && millis() - lastAddBombTime > addBombInterval)
                {
                    this.addBomb();
                    lastAddBombTime = millis();
                }

                shipGoto.inSpace = true;

                shipGoto.xPos = this.xPos;
                shipGoto.yPos = this.yPos;
                shipGoto.angle = this.angle;

                if(this.controls.shoot())
                {
                    this.shoot();
                }
            }else{
                shipGoto.inSpace = false;

                this.angle = 0;

                this.xVel = 0;
                this.yVel = -this.maxSpeed;
                this.speed = 7;
            }

            this.xPos += this.xVel;
            this.yPos += this.yVel;

            this.overrideXMiddle = physics.getMiddleXPos(this);
            this.overrideYMiddle = physics.getMiddleYPos(this);

            if(levels[levelInfo.level].createStars)
            {
                this.xPos = constrain(this.xPos, 0, levelInfo.width - this.width);
                this.yPos = constrain(this.yPos, 0, levelInfo.height - this.height);
            }

            this.updateBoundingBox();
        }
    };

    this.turrets = [];
    this.turrets.add = function(x, y, fire)
    {
        this.push({
            x: x,
            y: y,
            fire: fire,
            angle : atan2(y, x),
            length : Math.sqrt(x * x + y * y)
        })
    };

    function shoot(turrets)
    {
        var angle = this.angle + self.angle * DEG_TO_RAD;

        var blast = gameObjects.getObject("phaserBlast").add(
            Math.round(self.middleXPos + Math.cos(angle) * this.length), 
            Math.round(self.middleYPos + Math.sin(angle) * this.length), 4, color(19, 158, 192)); 

        blast.blastAngle = (self.angle - 90) * DEG_TO_RAD;
        blast.life = 250;
        blast.shooterArrayName = self.arrayName;
        blast.maxVel = 28;
        blast.damage = 2;

        cameraGrid.addReference(blast);
    }

    this.turrets.add(-66, -38, shoot);
    this.turrets.add(66, -38, shoot);
    this.turrets.add(-86, 12, shoot);
    this.turrets.add(86, 12, shoot);

    this.lastShootTime = 0;
    this.shoot = function()
    {
        if(millis() - this.lastShootTime > 250)
        {
            for(var i = 0; i < this.turrets.length; i++)
            {
                this.turrets[i].fire.call(this.turrets[i], this.turrets);
            }

            this.lastShootTime = millis();
        }
    };

    this.loadInterior = function()
    {
        game.gameState = "play";
        player.goto.doorSymbol = 'a';
        player.goto.travelType = "door";
        loader.startLoadLevel("helixShip", "door");

        cam.scaled = false;
        cam.keepInGrid = true;
        cam.scale = 0.3;
    };

    this.onCollide = function(object)
    {
        if(object.arrayName === "player")
        {
            if(object.yPos < this.yPos + 180 && this.angle === 30)
            {
                if(object.activate() && millis() - this.lastChangeTime > 500)
                {
                    this.hatchOpen = !this.hatchOpen;
                    this.lastChangeTime = millis();
                }
                if(this.hatchOpen && object.controls.enter())
                {
                    this.loadInterior();
                }
            }
        }
    };

    this.addBomb = function()
    {
        var bombs = gameObjects.getObject("bomb");

        var bomb = bombs.add(this.middleXPos, this.middleYPos - 40, 30, color(0, 123, 160, 200), 300);
        bomb.shooterArrayName = this.arrayName;

        // var a = (this.angle - 90) * DEG_TO_RAD;
        // bomb.outXVel = cos(a) * 10;
        // bomb.outYVel = sin(a) * 10;

        cameraGrid.addReference(bomb);
    };
};
gameObjects.addObject("helixShip", createArray(HelixShip));

var Ground = function(xPos, yPos, width, height, colorValue, name, dir)
{
    Rect.call(this, xPos, yPos, width, height);
    this.color = colorValue;
    this.grassColor = this.grassColor || color(28, 156, 30);
    this.type = "block";

    this.snowflakes = 0;

    if(dir)
    {
        return;
    }

    if(levelInfo.theme === "surface" && this.arrayName !== "block")
    {
        this.color = color(237 - 30, 201 - 30, 175 - 30);
        this.grassColor = color(219, 89, 37);

        name += "surface" + this.grassColor;
    }

    this.draw = function()
    {
        noStroke();
        fill(this.color);
        fastRect(this.xPos, this.yPos, this.width, this.height);

        if(!this.noGrass)
        {
            noStroke();
            fill(this.grassColor);
            fastRect(this.xPos, this.yPos, this.width, this.height * 0.15);
        }

        fill(0, 0, 0, 50);
        triangle(this.xPos + this.width, this.yPos + this.height, this.xPos + this.width, this.yPos, this.xPos, this.yPos + this.height);
    };

    screenUtils.loadImage(this, true, name);
};
gameObjects.addObject("ground", createArray(Ground));

var Dirt = function(xPos, yPos, width, height, colorValue)
{
    if(levelInfo.theme === "underground")
    {
        colorValue = color(67, 7, 20, 100);
    }
    else if(levelInfo.theme === "surface")
    {
        this.color = colorValue = color(237 - 30, 201 - 30, 175 - 30);
        this.noGrass = true;
        this.arrayName = "dirt";

        Ground.call(this, xPos, yPos, width, height, colorValue, undefined, true);

        this.draw = function()
        {
            noStroke();
            fill(this.color);
            fastRect(this.xPos, this.yPos, this.width, this.height);
            fill(0, 0, 0, 50);
            triangle(this.xPos + this.width, this.yPos + this.height, this.xPos + this.width, this.yPos, this.xPos, this.yPos + this.height);
        };

        screenUtils.loadImage(this, true, "dirtsurface");
        return;
    }

    this.noGrass = true;
    this.arrayName = "dirt";
    Ground.call(this, xPos, yPos, width, height, colorValue);
    screenUtils.speedUpImage(storedImages[this.imageName]);
};
gameObjects.addObject("dirt", createArray(Dirt));

var Block = function(xPos, yPos, width, height, colorValue, override)
{
    this.noGrass = true;
    this.arrayName = "block";
    Ground.call(this, xPos, yPos, width, height, colorValue, "block" + colorValue);
    screenUtils.speedUpImage(storedImages[this.imageName]);
};
gameObjects.addObject("block", createArray(Block));

var ImageBlock = function(xPos, yPos, width, height, imageName)
{
    Rect.call(this, xPos, yPos, width, height);

    this.imageName = imageName;

    this.snowflakes = 0;

    var img = loadedImages[imageName];

    if(!img)
    {
        this.draw = function() {};
        return;
    }

    if(img.__isDirty)
    {
        img.updatePixels();
    }

    this.draw = function()
    {
        // try{
        //     image(loadedImages[this.imageName], this.xPos, this.yPos, this.width, this.height);
        // }
        // catch(e) { }

        ctx.drawImage(img.sourceImg, 0, 0, img.sourceImg.width, img.sourceImg.height, Math.round(this.xPos), Math.round(this.yPos), this.width, this.height);
    };

    this.notExplosive = true;
};
gameObjects.addObject("imageBlock", createArray(ImageBlock));

var Ice = function(xPos, yPos, width, height, colorValue, slipFactor, override)
{
    if(!levelInfo.cold || override)
    {
        this.noGrass = true;
        this.arrayName = "ice";
        Ground.call(this, xPos, yPos, width, height, colorValue || color(33, 198, 207));

        this.triangular = true;

        this.draw = function()
        {
            fill(33, 198, 207);
            fastRect(this.xPos, this.yPos, this.width, this.height);
            fill(0, 0, 0, 70);
            triangle(this.xPos, this.yPos + this.height, 
                    this.xPos + this.width, this.yPos, 
                    this.yPos + this.height, this.xPos + this.width);
        };

        screenUtils.loadImage(this, true, "ice_actual" + (millis() * Math.random()).toFixed(5), undefined, undefined, undefined/*, 225*/);
    }else{
        Rect.call(this, xPos, yPos, width, height);
        this.color = colorValue || color(33, 198, 207);

        this.type = "block";
        this.imageName = "ice1";

        if(typeof storedImages[this.imageName] === "undefined")
        {
            this.xSize = this.width / 10;
            this.ySize = this.height / 10;
            this.layout = [
                "1111  1111",
                "1        1",
                "1 444444 1",
                "1 444444 1",
                "  44  44  ",
                "  44  44  ",
                "1 444444 1",
                "1 444444 1",
                "1        1",
                "1111  1111",
            ];

            this.draw = function()
            {  
                fill(this.color);
                fastRect(this.xPos, this.yPos, this.width, this.height);

                noStroke();
                for(var i = 0; i < this.layout.length; i++)
                {
                    for(var j = 0; j < this.layout[i].length; j++)
                    {
                        switch(this.layout[i][j])
                        {
                            case '0' :
                                fill(2, 22, 80);
                                fastRect(this.xPos + j * this.xSize, this.yPos + i * this.ySize, this.xSize, this.ySize);
                                break;

                            case '1' :
                                fill(2, 152, 182);
                                fastRect(this.xPos + j * this.xSize, this.yPos + i * this.ySize, this.xSize, this.ySize);
                                break;

                            case '2' :
                                fill(2, 122, 202);
                                fastRect(this.xPos + j * this.xSize, this.yPos + i * this.ySize, this.xSize, this.ySize);
                                break;

                            case '3' : 
                                fill(240, 240, 240);
                                fastRect(this.xPos + j * this.xSize, this.yPos + i * this.ySize, this.xSize, this.ySize);
                                break;

                            case '4' :
                                fill(32, 182, 212);
                                fastRect(this.xPos + j * this.xSize, this.yPos + i * this.ySize, this.xSize, this.ySize);
                                break;
                        }
                    }
                }
            };

            screenUtils.loadImage(this, true, this.imageName, undefined, undefined, undefined, 200);
        }

        this.draw = function()
        {
            image(storedImages[this.imageName], this.xPos, this.yPos, this.width, this.height);
        };
    }

    this.shapes = [];
    this.shapes.add = function(xPos, yPos, width, height, color, life)
    {
        this.push({
            xPos : xPos, 
            yPos : yPos,
            width : width,
            height : height,

            rotation : 0,
            rotateVel : 5 * random(-1, 1),

            xVel : random(-3, 3),
            yVel : random(2, 6),

            color : color,

            life : life || 100,
            gravity : 0.06,

            halfWidth : width / 2,
            halfHeight : height / 2,
        });
    };
    this.shapes.draw = function()
    {
        for(var i = this.length - 1; i >= 0; i--)
        {
            var shape = this[i];

            shape.xPos += shape.xVel;
            shape.yPos += shape.yVel;
            shape.rotation += shape.rotateVel;

            shape.yVel += shape.gravity;

            shape.life--;

            if(shape.life < 0)
            {
                this.splice(i, 1);
            }

            fill(shape.color);
            $pjs.pushMatrix();
                translate(shape.xPos, shape.yPos);
                rotate(shape.rotation);
                fastRect(-shape.halfWidth, -shape.halfHeight, shape.width, shape.height);
            $pjs.popMatrix();
        }
    };

    // Define a sourceImg in this PImage 
    screenUtils.speedUpImage(storedImages[this.imageName]);

    this.shatter = function(wl, hl, life)
    {
        if(this.shattered)
        {
            return;
        }

        sounds.mplaySound("IceCrack.mp3");

        sounds.mplaySound("quickBoom.wav");

        this.draw = function() 
        {
            this.shapes.draw();

            if(this.shapes.length <= 0)
            {
                this.remove();
            }
        };

        wl = wl || 3;
        hl = hl || 3;

        var shapeWidth = this.width / wl;
        var shapeHeight = this.width / hl;

        for(var i = 0; i < wl; i++)
        {
            for(var j = 0; j < hl; j++)
            {
                this.shapes.add(this.xPos + i * shapeWidth, this.yPos + i * shapeHeight, shapeWidth * random(0.5, 1), shapeHeight * random(0.5, 1), this.color, life);
            }
        }

        this.physics.solidObject = false;
        this.shattered = true;
    };

    this.slipFactor = slipFactor || -0.45;
    this.onCollide = function(object)
    {
        if(object.arrayName === "water" && levelInfo.cold)
        {
            object.temp -= 3;
            object.freezing = true;
        }
        else if(object.physics.movement === "dynamic")
        {
            if(object.friction !== undefined)
            {
                object.friction = this.slipFactor; //Make friction work against itself
            }
            
            if(object.setXAcl === undefined)
            {
                object.setXAcl = object.xAcl;
            }
            
            object.xAcl = object.setXAcl;

            //The restraining of trying to go the other way on ice
            if(abs(object.xVel) <= object.maxXVel * 0.6 && abs(object.xVel) > 0)
            {
                object.xAcl = object.setXAcl * 0.6;
            }
        }
    };
};
gameObjects.addObject("ice", createArray(Ice));

var UndergroundBlock = function(xPos, yPos, width, height)
{
    Rect.call(this, xPos, yPos, width, height);

    var left = this.xPos;
    var right = this.xPos + this.width;
    var up = this.yPos;
    var down = this.yPos + this.height;

    physics.getMiddleXPos(this);
    physics.getMiddleYPos(this);

    this.rotation = 90 * 2;

    this.draw = function()
    {
        $pjs.pushMatrix();
            translate(xPos + this.halfWidth, yPos + this.halfHeight);
            rotate(this.rotation);
            translate(-xPos - this.halfWidth, -yPos - this.halfHeight);
            fill(0, 0, 0, 100);
            fastRect(xPos, yPos, width, height);
            fill(245, 245, 245, 90);
            triangle(left, down, right, up, right, down);
            fill(0, 0, 0, 70);
            $pjs.rect(xPos + 6, yPos + 6, width - 12, height - 12, 5);
        $pjs.popMatrix();
    };

    this.lastTwistTime = 0;
    this.update = function()
    {
        if(mouseIsPressed && millis() - this.lastTwistTime > 250)
        {
            var x = cam.focusXPos - cam.halfWidth + mouseX;
            var y = cam.focusYPos - cam.halfHeight + mouseY;

            if(observer.collisionTypes.pointrect.colliding({
                xPos : x, 
                yPos : y
            }, this))
            {
                this.rotation = physics.formulas.resolveAngle(this.rotation + 90);
            }

            this.lastTwistTime = millis();
        }
    };
};
gameObjects.addObject("undergroundBlock", createArray(UndergroundBlock));

var LaserCast = function(xPos, yPos, diameter)
{
    Circle.call(this, xPos, yPos, diameter);

    this.physics.solidObject = false;
    this.physics.shape = "point";
    
    this.xVel = 0;
    this.yVel = 0;
    
    this.boundingBox.off = true;
    this.physics.movement = "dynamic";

    this.color = color(0, 90, 160, 200);

    this.update = function() {};

    // this.draw = function() {};

    this.move = function()
    {
        this.xPos += this.xVel;
        this.yPos += this.yVel;

        // Out of bounds!
        if(this.xPos < levelInfo.xPos || this.xPos > levelInfo.xPos + levelInfo.width || 
           this.yPos < levelInfo.yPos || this.yPos > levelInfo.yPos + levelInfo.height)
        {
            this.destroy();
        }
    };

    this.onDestroy = function()
    {
        // Used by a laser block
    };

    this.destroy = function()
    {
        if(this.destroyed)
        {
            return;
        }

        this.onDestroy();
        this.onCollide = function() {};

        if(this.laserCasts.length > 0)
        {
            for(var i = this.laserCasts.length - 1; i >= 0; i--)
            {
                if(this.laserCasts[i].index === this.index)
                {
                    this.laserCasts.splice(i, 1);
                    break;
                } 
            }
        }
        this.remove();
        this.update = function() {};

        this.destroyed = true;
    };

    this.onDirectionChange = function(object, info)
    {
        // Used by a laser block
    };

    this.avoidCollision = function(object)
    {
        return ["exclamationBlock", "imageBlock", "undergroundBlock"].indexOf(object.arrayName) === -1;
    };

    this.onCollide = function(object, info)
    {
        // Never have I used a switch-case with in a switch-case
        switch(object.arrayName)
        {
            case "exclamationBlock" :
                if(!object.activate())
                {
                    this.destroy();
                }
                break;

            case "imageBlock" :
                this.onCollide = function() {};
                this.destroy();
                return;

            case "undergroundBlock" :
                switch(object.rotation)
                {
                    // left / up open
                    case 0 :
                        if(this.direction === 'r')
                        {
                            this.yVel = -this.xVel;
                            this.xVel = 0;

                            this.xPos = object.middleXPos;
                            this.direction = 'u';

                            this.onDirectionChange(object, info, this.direction);
                        }
                        else if(this.direction === 'd')
                        {
                            this.xVel = -this.yVel;
                            this.yVel = 0;

                            this.yPos = object.middleYPos;
                            this.direction = 'l';

                            this.onDirectionChange(object, info, this.direction);
                        }
                        else if(this.direction === 'l' && this.xVel < 0 && this.xPos > object.middleXPos)
                        {
                            this.xPos = object.xPos + object.width;
                            this.destroy();
                        }
                        else if(this.direction === 'u' && this.yVel < 0 && this.yPos > object.middleYPos)
                        {
                            this.yPos = object.yPos + object.height;
                            this.destroy();
                        }
                        break;

                    // up / right open
                    case 90 :
                        if(this.direction === 'l')
                        {
                            this.yVel = this.xVel;
                            this.xVel = 0;

                            this.xPos = object.middleXPos;
                            this.direction = 'u';

                            this.onDirectionChange(object, info, this.direction);
                        }
                        else if(this.direction === 'd')
                        {
                            this.xVel = this.yVel;
                            this.yVel = 0;

                            this.yPos = object.middleYPos;
                            this.direction = 'r';

                            this.onDirectionChange(object, info, this.direction);
                        }
                        else if(this.direction === 'r' && this.xVel > 0 && this.xPos < object.middleXPos)
                        {
                            this.xPos = object.xPos;
                            this.destroy();    
                        }
                        else if(this.direction === 'u' && this.yVel < 0 && this.yPos > object.middleYPos)
                        {
                            this.yPos = object.yPos + object.height;
                            this.destroy();
                        }
                        break;

                    // right / down open
                    case 180 :
                        if(this.direction === 'l')
                        {
                            this.yVel = -this.xVel;
                            this.xVel = 0;

                            this.xPos = object.middleXPos;
                            this.direction = 'd';

                            this.onDirectionChange(object, info, this.direction);
                        }
                        else if(this.direction === 'u')
                        {
                            this.xVel = -this.yVel;
                            this.yVel = 0;

                            this.yPos = object.middleYPos;
                            this.direction = 'r';

                            this.onDirectionChange(object, info, this.direction);
                        }
                        else if(this.direction === 'r' && this.xVel > 0 && this.xPos < object.middleXPos)
                        {
                            this.xPos = object.xPos;
                            this.destroy();
                        }
                        else if(this.direction === 'd' && this.yVel > 0 && this.yPos < object.middleYPos)
                        {
                            this.yPos = object.yPos;
                            this.destroy();
                        }
                        break;

                    // down / left open
                    case 270 :
                        if(this.direction === 'r')
                        {
                            this.yVel = this.xVel;
                            this.xVel = 0;

                            this.xPos = object.middleXPos;
                            this.direction = 'd';

                            this.onDirectionChange(object, info, this.direction);
                        }
                        else if(this.direction === 'u')
                        {
                            this.xVel = this.yVel;
                            this.yVel = 0;

                            this.yPos = object.middleYPos;
                            this.direction = 'l';

                            this.onDirectionChange(object, info, this.direction);
                        }
                        else if(this.direction === 'l' && this.xVel < 0 && this.xPos > object.middleXPos)
                        {
                            this.xPos = object.xPos + object.width;
                            this.destroy();
                        }
                        else if(this.direction === 'd' && this.yVel > 0 && this.yPos < object.middleYPos)
                        {
                            this.yPos = object.yPos;
                            this.destroy();
                        }
                        break;
                }
                return;
        }
    };  
};
gameObjects.addObject("laserCast", createArray(LaserCast));

var LaserPath = function(xPos, yPos, width, height)
{
    Rect.call(this, xPos, yPos, width, height);
    this.physics.solidObject = false;

    this.points = [];

    this.color = color(23, 134, 176, 200);

    this.draw = function()
    {
        strokeWeight(1);
        stroke(this.color);
        if(this.points.length >= 2)
        {
            for(var i = 1; i < this.points.length; i++)
            {
                line(this.points[i - 1].x, this.points[i - 1].y, this.points[i].x, this.points[i].y);
            }
        }
        noStroke();
    };

    this.update = function() {};

    this.follow = function(laserCast)
    {
        if(!laserCast)
        {
            return;
        }

        var index = this.points.length - 1;
        this.points[index].x = laserCast.xPos;
        this.points[index].y = laserCast.yPos;
    };

    this.followMultiple = function(laserCasts)
    {
        this.follow(laserCasts[0]);
    };

    this.split = function(laserCast, direction)
    {
        this.points.push({
            x : laserCast.xPos,
            y : laserCast.yPos
        });
    };
};
gameObjects.addObject("laserPath", createArray(LaserPath));

var LaserBlock = function(xPos, yPos, width, height, direction)
{
    Rect.call(this, xPos, yPos, width, height);

    this.direction = direction;

    physics.getMiddleXPos(this);
    physics.getMiddleYPos(this);

    this.getAngle = function(direction)
    {
        switch(direction)
        {
            // Left
            case 'l' :
                return 180;

            // Right
            case 'r' :
                return 0;
                      
            // Up
            case 'u' :
                return 270;

            // Down
            case 'd' :
                return 90;
        }
    };
    this.getDirection = function(angle)
    {
        switch(angle)
        {
            // Left
            case 180 :
                return 'l';

            // Right
            case 0 :
                return 'r';
                      
            // Up
            case 270 :
                return 'u';

            // Down
            case 90 :
                return 'd';
        }
    };

    this.rotation = this.getAngle(direction);

    this.draw = function()
    {
        $pjs.pushMatrix();
            translate(this.middleXPos, this.middleYPos);
            rotate(this.rotation);
            translate(-this.middleXPos, -this.middleYPos);

            fill(10, 83, 180, 200);
            ellipse(this.middleXPos, this.middleYPos, this.halfWidth, this.halfWidth);

            fill(0, 0, 0, 100);
            fastRect(this.xPos, this.yPos, this.width, this.height);

            fill(245, 245, 245, 90);
            fastRect(this.xPos, this.yPos, this.halfWidth, this.height);

            var h = this.height * 0.2;
            fastRect(this.xPos + this.halfWidth, this.yPos, this.halfWidth, h);
            fastRect(this.xPos + this.halfWidth, this.yPos + this.height - h, this.halfWidth, h);
        $pjs.popMatrix();
    };

    this.lastTwistTime = 0;
    this.update = function()
    {
        // if(!this._activated)
        // {
        //     this.activate();
        //     this._activated = true;
        // }

        // if(this.laserPath && this.laserCasts)
        // {
        //     this.laserPath.followMultiple(this.laserCasts);
        // }

        if(mouseIsPressed && millis() - this.lastTwistTime > 250)
        {
            var x = cam.focusXPos - cam.halfWidth + mouseX;
            var y = cam.focusYPos - cam.halfHeight + mouseY;

            if(observer.collisionTypes.pointrect.colliding({
                xPos : x, 
                yPos : y
            }, this))
            {
                this.rotation = physics.formulas.resolveAngle(this.rotation + 90);
                this.direction = this.getDirection(this.rotation);
            }

            this.lastTwistTime = millis();
        }
    };

    this.activate = function()
    {
        this.laserCasts = [];
        this.sendCast();
        this.setupLaserBeam();
    };

    this.sendCast = function()
    {
        var laserCast = gameObjects.getObject("laserCast").add(this.middleXPos, this.middleYPos, 3);

        var _angle = this.rotation * DEG_TO_RAD;
        var _speed = laserCast.speed = 3;
        laserCast.xVel = cos(_angle) * _speed;
        laserCast.yVel = sin(_angle) * _speed;
        laserCast.direction = this.getDirection(this.rotation);

        laserCast.laserCasts = this.laserCasts;

        var _this = this; 
        laserCast.onDirectionChange = function(object, info, direction)
        {
            var point = _this.laserPath.points[_this.laserPath.points.length - 1];

            point.x = object.xPos + object.halfWidth;
            point.y = object.yPos + object.halfHeight;
            
            _this.laserPath.split(this, direction);
        };
        laserCast.onDestroy = function()
        {
            _this.laserPath.farthestXPos = this.xPos;
            _this.laserPath.farthestYPos = this.yPos;

            var lc = _this.sendCast();
        };

        cameraGrid.addReference(laserCast);
        this.laserCasts.push(laserCast);

        if(this.laserPath)
        {
            laserCast.xPos = this.middleXPos;
            laserCast.yPos = this.middleYPos;
            this.laserPath.points.length = 0;
            this.laserPath.split(laserCast);
            this.laserPath.split(laserCast);
        }

        return laserCast;
    };

    this.setupLaserBeam = function()
    {
        // Yeah just zeros
        this.laserPath = gameObjects.getObject("laserPath").add(0, 0, 0, 0);

        this.laserPath.split(this.laserCasts[0], this.direction);
        this.laserPath.split(this.laserCasts[0], this.direction);
    };
};
gameObjects.addObject("laserBlock", createArray(LaserBlock));

var ExclamationBlock = function(xPos, yPos, width, height)
{
    Rect.call(this, xPos, yPos, width, height);

    physics.getMiddleXPos(this);
    physics.getMiddleYPos(this);

    var font;

    try{
        font = createFont("Lora");
    }
    catch(e)
    {
        console.log("failed", e);
        font = createFont("cursive");
    }

    this.xScale = 0;
    this.xScaleVel = 0.05;

    this.message = '!';

    this.draw = function()
    {
        fill(7, 45, 151, 146);
        $pjs.rect(this.xPos, this.yPos, this.width, this.height, 6);

        $pjs.pushMatrix();
            translate(this.middleXPos, this.middleYPos);
            scale(this.xScale, 1.0);

            textFont(font);
            textSize(20);
            textAlign(CENTER, CENTER);
            fill(255, 255, 255, 200);

            // text(this.message, 0, 0);
            text('!', 0, 0);
        $pjs.popMatrix();
    };

    this.update = function()
    {
        this.xScale += this.xScaleVel;

        if(Math.abs(this.xScale) > 1.0)
        {
            this.xScaleVel = -this.xScaleVel;
        }

        if(this.activated)
        {
            this.scaleStart += this.scaleVel;

            if(this.scaleStart > 1.3)
            {
                this.scaleVel = -this.scaleVel;   
            }

            if(this.scaleStart < 0.1)
            {
                if(!this.didEvent)
                {
                    this.event();

                    this.didEvent = true;
                }
            }
        }
    };

    this.event = function() 
    {
        // Will be overridden by level scripts
        console.log(true);
    };

    this.activate = function()
    {
        if(this.activated)
        {
            this.physics.solidObject = false;
            return true;
        }

        if((this.okay !== undefined && !this.okay()))
        {
            return false;
        }

        this.activated = true;
        this.scaleStart = 1;
        this.scaleVel = 0.15;

        var _lastDraw = this.draw;
        this.draw = function()
        {
            var cs = 0;

            for(var i = 0; i < 3; i++)
            {
                cs = this.scaleStart - i * 0.1;

                if(cs > 0)
                {
                    $pjs.pushMatrix();
                        translate(this.middleXPos, this.middleYPos);
                        scale(cs, cs);
                        translate(-this.middleXPos, -this.middleYPos);

                        _lastDraw.apply(this, arguments); 
                    $pjs.popMatrix();
                }
            }
        };

        return true;
    };
};
gameObjects.addObject("exclamationBlock", createArray(ExclamationBlock));

// Maybe '?' block next

var BehindBlock = function(xPos, yPos, width, height)
{
    Rect.call(this, xPos, yPos, width, height);

    this.draw = function()
    {
        fill(0, 0, 0, 130);
        $pjs.rect(xPos, yPos, width, height);
    };
};
gameObjects.addObject("behindBlock", createArray(BehindBlock));

var SuperIce = function(xPos, yPos, width, height, colorValue, slipFactor)
{
    this.noGrass = true;
    this.arrayName = "superIce";
    Ground.call(this, xPos, yPos, width, height, colorValue || color(33, 158, 207));
    
    var w = this.width * (1 / 3);
    var h = this.height * (1 / 3);

    this.draw = function()
    {
        noStroke();
        fill(this.color);
        fastRect(this.xPos, this.yPos, this.width, this.height);

        for(var i = 0; i < this.width; i += w)
        {
            for(var j = 0; j < this.height; j += h)
            {
                fill(40, 80, 220, random(40, 150));
                fastRect(this.xPos + i, this.yPos + j, w, h);
            }
        }

        fill(0, 0, 0, 50);
        triangle(this.xPos + this.width, this.yPos + this.height, this.xPos + this.width, this.yPos, this.xPos, this.yPos + this.height);
    };

    screenUtils.loadImage(this, true, "superIce" + random(0, 1).toFixed(2), undefined, undefined, undefined, 200);

    this.slipFactor = slipFactor || -0.75;
    this.onCollide = function(object)
    {
        if(object.arrayName === "water")
        {
            object.temp -= 3;
            object.freezing = true;
        }
        else if(object.physics.movement === "dynamic")
        {
            if(object.friction !== undefined)
            {
                object.friction = this.slipFactor; //Make friction work against itself
            }

            if(object.setXAcl === undefined)
            {
                object.setXAcl = object.xAcl;
            }
            
            //The restraining of trying to go the other way on ice
            if(abs(object.xVel) <= object.maxXVel * 0.35 && abs(object.xVel) > 0)
            {
                object.xAcl = object.setXAcl * 0.5;
            }else{
                object.xAcl = object.setXAcl * 2;
            }
        }
    };
};
gameObjects.addObject("superIce", createArray(SuperIce));

var FilterBlock = function(xPos, yPos, width, height, colorValue)
{
    Rect.call(this, xPos, yPos, width, height);
    this.color = colorValue || color(0, 50, 124, 120);

    this.snowflakes = 0;

    this.draw = function()
    {
        fill(this.color);
        $pjs.rect(this.xPos, this.yPos, this.width, this.height, 5);

        fill(0, 0, 70, 100);
        triangle(this.xPos, this.yPos, this.xPos + this.width, this.yPos, this.xPos, this.yPos + this.height);
    };

    this.avoidCollision = function(object)
    {
        return (object.arrayName !== "player" && object.arrayName !== "xStar");
    };
};
gameObjects.addObject("filterBlock", createArray(FilterBlock));

var Ladder = function(xPos, yPos, width, height, colorValue)
{
    Rect.call(this, xPos, yPos, width, height);
    this.physics.solidObject = false;
    this.type = "use";
    
    this.snowflakes = 0;

    this.color = colorValue || color(0, 0, 0);

    var lines = 4;

    this.draw = function()
    {
        stroke(red(this.color), green(this.color), blue(this.color), alpha(this.color));
        strokeWeight(1);
        var spacing = this.height / lines;
        for(var i = 0; i < lines; i++)
        {
           line(this.xPos, this.yPos + i * spacing, 
           this.xPos + this.width, this.yPos + i * spacing);
        }
        var spacing2 = spacing * 2;
        for(var i = 0; i < lines / 2; i++)
        {
            line(this.xPos, this.yPos + i * 2 * spacing, 
                 this.xPos, this.yPos + (i * 2 + 1) * spacing);
                 
            line(this.xPos + this.width - 1, this.yPos + (i * 2 - 1) * spacing + spacing * 2, 
                 this.xPos + this.width - 1, this.yPos + (i * 2) * spacing + spacing * 2);
        }
    };
    
    this.onCollide = function(object)
    {
        if(object.type === "lifeform")
        {
            object.onLadder = true;
            object.inAir = false;
        }
    };
    
    screenUtils.loadImage(this, true, "ladder", true);
};
gameObjects.addObject("ladder", createArray(Ladder));

var Spring = function(xPos, yPos, width, height, colorValue)
{
    Rect.call(this, xPos, yPos, width, height);
    this.color = colorValue || color(0, 150, 80);
    this.boost = 10.15;
    this.xBoost = this.boost;
    this.yBoost = this.boost;
    this.type = "block";

    this.draw = function()
    {
        fill(this.color);
        fastRect(this.xPos, this.yPos, this.width, this.height);        
        fill(0, 0, 0, 50);
        fastRect(this.xPos + this.width * 0.15, this.yPos + this.height * 0.15, this.width * 0.65, this.height * 0.65);
        fill(0, 0, 0, 60);
        triangle(this.xPos, this.yPos + this.height, this.xPos + this.width, this.yPos, this.xPos + this.width, this.yPos + this.height);
    };

    screenUtils.loadImage(this, true, "spring");

    this.onCollide = function(object)
    {
        var padding = (object.xAcl || 1); //Padding, usually based on acceleration
        if(object.xPos + (object.radius || object.width) < this.xPos + (padding))
        {
            object.xVel = -this.xBoost;
        }
        else if(object.xPos > this.xPos + this.width - (padding))
        {
            object.xVel = this.xBoost;
        }

        padding = (object.yAcl || 0.25); //Padding, usually based on acceleration
        if(object.yPos + (object.radius || object.height) < this.yPos + (padding))
        {
            object.yVel = -this.yBoost;
        }
        if(object.yPos > this.yPos + this.height - (padding))
        {
            object.yVel = this.yBoost;
        }
    };
};
gameObjects.addObject("spring", createArray(Spring));

var Sign = function(xPos, yPos, width, height, colorValue, message, textColor, fontName)
{
    Rect.call(this, xPos, yPos, width, height);
    this.color = colorValue || color(200, 150, 70);
    this.message = message || "This is a sign";
    this.textColor = textColor;
    this.physics.solidObject = false;
    this.type = "use";

    this.fontName = fontName;

    this.draw = function()
    {
        fill(this.color);
        fastRect(this.xPos + this.width * 0.4, this.yPos, this.width * 0.2, this.height);
        fastRect(this.xPos, this.yPos, this.width, this.height * 0.6);
        fill(0, 0, 0, 50);
        fastRect(this.xPos + this.width * 0.1, this.yPos + this.height * 0.1, this.width * 0.8, this.height * 0.4);

        stroke(0, 0, 0, 50);
        strokeWeight(2);
        line(this.xPos + this.width * 0.25, this.yPos + this.width * 0.25, this.xPos + this.width * 0.7, this.yPos + this.width * 0.25);
        line(this.xPos + this.width * 0.25, this.yPos + this.width * 0.35, this.xPos + this.width * 0.7, this.yPos + this.width * 0.35);
        noStroke();
    };
    screenUtils.loadImage(this, true, "sign" + this.color, true);
    
    this.lastDraw = this.draw;
    this.draw = function()
    {
        this.lastDraw();     
        if(this.active)
        {
            this.drawMessage();
        }
        this.active = false;
    };
    
    this.load = function()
    {
        this.textSize1 = (this.textSize || 10);
        this.startX = this.xPos + this.halfWidth + (this.adjustX || 0);
        this.startY = (this.yPos - this.halfHeight) + (this.adjustY || 0);
        this.split = ("").split(this.message).length;
        this.messageHeight = this.adjustH || split * (this.textSize1 * 2.6);
        this.messageWidth = this.adjustW || (this.message.length) * (this.textSize1 / 1.6);
        this.messageWidth2 = this.messageWidth * 0.9;
        this.messageHeight2 = this.messageHeight * 0.8;
        this.textRectX = this.startX - this.messageWidth / 2;
        this.textRectY = this.startY - this.messageHeight / 2;
        this.textRectX2 = this.startX - this.messageWidth2 / 2;
        this.textRectY2 = this.startY - this.messageHeight2 / 2;

        if(this.fontName !== undefined)
        {
            //Note  : There used to be a try catch block here but I removed it because it stalls the program
            this.font = createFont(this.fontName);
            this.fontName = undefined;
        }
    };

    this.sleep = 0;
    this.drawMessage = function()
    {
        this.sleep++;
        //Wait a sec to render the sign's message to reduce lag
        if(this.sleep < 5)
        {
            return;  
        }
        
        if(!this.messageScanned)
        {
            this.message = this.message.replace("/username", player.username);
            this.messageScanned = true;
        }

        textAlign(CENTER, CENTER);
        if(this.font !== undefined)
        {
            textFont(this.font);
        }
        textSize(this.textSize1);
        noStroke();
        fill(this.color);
        fastRect(this.textRectX, this.textRectY, this.messageWidth, this.messageHeight);
        fill(0, 0, 0, 50);
        fastRect(this.textRectX2, this.textRectY2, this.messageWidth2, this.messageHeight2);
        fill(this.textColor || 0);
        text(this.message, this.startX, this.startY);
        textAlign(NORMAL, NORMAL);
    };

    this.onCollide = function(object)
    {
        if(object.arrayName === "player")
        {
            this.active = true;

            if(keys['t'])
            {
                talkHandler.start({
                    "start" : {
                        message : this.message,
                        choices : {
                            "End" : {
                                message : "End",
                            },
                        },
                    },
                }, "start", "", true);
            }

            if(messageHandler.active)
            {
                object.xVel = 0;
            }
        }
    };
};
gameObjects.addObject("sign", createArray(Sign));

var Door = function(xPos, yPos, width, height, colorValue)
{
    Rect.call(this, xPos, yPos, width, height);
    this.physics.solidObject = false;
    this.color = colorValue || color(28, 145, 37);
    this.goto = {};
    this.type = "use";
    
    if(backgrounds.background === "deep" || levelInfo.theme === "ship")
    {
        this.color = color(74, 74, 74);
    }

    this.draw = function()
    {
        fill(this.color);
        fastRect(this.xPos, this.yPos, this.width, this.height);

        fill(0, 0, 0, 30);
        fastRect(this.xPos + this.width * 0.1, this.yPos + this.height * 0.05, this.width * 0.8, this.height * 0.9);

        fill(this.color, this.color, this.color, 20);
        fastRect(this.xPos, this.yPos + this.halfHeight, this.width, this.halfHeight);

        fill(this.color, this.color, this.color, 30);
        var knobRaduis = this.width * 0.30;
        circle(this.xPos + this.width * 0.8, this.yPos + this.height * 0.5, knobRaduis);
    };

    screenUtils.loadImage(this, true, "door" + this.color);

    var self = this;

    this.particles = [];
    this.emitter = {
        add : function()
        {
            self.particles.push({
                xPos : self.middleXPos,
                yPos : self.middleYPos,
                radius : Math.round(random(2, 7)),
                life : 100,
                maxLife : 100,
                xVel : Math.round(random(-2, 2)),
                yVel : Math.round(random(-2, 2)),
                color : ((random(0, 1) < 0.35) ? color(0, 170, 126) : color(0, 50, 200)),
                angle : 0,
                angleVel : random(-this.angleVel, this.angleVel),
                angleSpeed : 5,
            });
        },
        start : function(amt)
        {
            this.amt = amt;
            this.angleVel = TWO_PI / 30;
            for(var i = 0; i < amt; i++)
            {
                this.add();
            }
        },
        update : function()
        {
            for(var i = self.particles.length - 1; i >= 0; i--)
            {
                var p = self.particles[i];

                p.angle += p.angleVel;

                p.xPos += cos(p.angle) * p.angleSpeed;
                p.yPos += sin(p.angle) * p.angleSpeed;

                p.life -= 0.5;

                if(p.life <= 0)
                {
                    self.particles.splice(i, 1);
                    if(self.particles.length < this.amt)
                    {
                        this.add();
                    }
                }
            }
        },
        draw : function()
        {
            for(var i = self.particles.length - 1; i >= 0; i--)
            {
                var p = self.particles[i];

                fill(red(p.color), green(p.color), blue(p.color), p.life * alpha(p.color) / p.maxLife);
                circle(p.xPos, p.yPos, p.radius);
            }
        },
    };

    this.lastDraw = this.draw;
    this.draw = function()
    {
        if(this.goto.hidden)
        {
            return;
        }

        if(!this.magic)
        {
            this.lastDraw();
        }
        else if(!this.goto.locked)
        {
            this.emitter.draw();
        }

        if(this.goto.locked)
        {
            if(this.magic)
            {
                return;
            }

            noStroke();
            fill(0, 0, 0, 120);
            fastRect(this.xPos, this.yPos, this.width, this.height);
        }

        fill(0, 0, 0, 30);
        textAlign(CENTER, CENTER);
        textSize(30);
        text(this.symbol, this.xPos + this.width * 0.5, this.yPos + this.height * 0.4);

        if(this.goto.style === "boss")
        {
            textSize(15);
            fill(220, 0, 0, 40);
            text("!", this.xPos + this.width * 0.5, this.yPos + this.height * 0.76);
            noStroke();

            fill(220, 0, 0, 70);
            arc(this.xPos, this.yPos, 20, 20, radians(0), radians(90));
            arc(this.xPos + this.width, this.yPos, 20, 20, radians(90), radians(180));

            arc(this.xPos, this.yPos + this.height, 20, 20, radians(270), radians(360));
            arc(this.xPos + this.width, this.yPos + this.height, 20, 20, radians(180), radians(270));
        }
    };

    this.update = function()
    {
        if(this.magic && !this.goto.locked)
        {
            if(!this.emitter.started)
            {
                physics.getMiddleXPos(this);
                physics.getMiddleYPos(this);

                this.emitter.start(100);
                this.emitter.started = true;
            }

            this.emitter.update();
            return;
        }
    };

    this.onCollide = function(object)
    {
        if(!this.goto.hidden && object.openDoor !== undefined && object.openDoor())
        {
            if(object.goto.keysHolding !== undefined)
            {
                if(object.goto.keysHolding[levelInfo.level + this.symbol])
                {
                    this.goto.locked = false;
                    object.goto.keysHolding[levelInfo.level + this.symbol] = undefined;
                }
            }

            if(game.usedDoors === undefined)
            {
                game.usedDoors = {};
            }

            if(!this.goto.locked)
            {
                object.save = true;
                object.goto.doorSymbol = this.goto.symbol;
                object.goto.travelType = "door";

                loader.startLoadLevel(this.goto.level, "door", this.index);
                talkHandler.end();

                sounds.playSound("dooropen.mp3");

                if(levels[this.goto.level] !== undefined)
                {
                    levels[this.goto.level].doors[this.goto.symbol].locked = false; // Make sure we're not locked out of the door we go through

                    //Save the door we opened
                    game.usedDoors[this.goto.level + this.goto.symbol] = {
                        symbol : this.goto.symbol,
                        level : this.goto.level,
                        locked : false,
                    };
                }

                game.usedDoors[levelInfo.level + this.symbol] = {
                    symbol : this.symbol,
                    level : levelInfo.level,
                    locked : this.goto.locked,
                };
            }
            else if(!messageHandler.active && !this.magic)
            {
                object.xVel = 0;
                object.yVel = 0;
                keys[keyCode] = false;
                talkHandler.start({
                    "locked" : {
                        message : "It's locked!",
                        choices : {
                            "Ok" : {
                                message : "Okay",
                            },
                        },
                    },
                    "Open" : {
                        message : "It won't open.",
                        choices : {
                            "Ok" : {
                                message : "Okay",
                            },
                        },
                    }
                }, this.setMessage || "locked", "", true);
            }
        }
    };
};
gameObjects.addObject("door", createArray(Door));

var Crate = function(xPos, yPos, width, height, colorValue, noBreak)
{
    DynamicRect.call(this, xPos, yPos, width, height, colorValue || color(190, 160, 84, 255)); 
   
    this.breakPercent = 0;
    this.breakRate = 0.3;
    this.xDeacl = 0.25; //Turn this up for less glitches
    this.type = "block";
    this.noBreak = noBreak;
    this.broken = false;
    this.autoXDeacl = true;

    this.mass = 3;
    this.maxXVel = 3.5;

    this.addDrops = function()
    {
        for(var i = 0; i < Math.round(random(1, 4)); i++)
        {
            var item = (random(0, 100) <= 60) ? "coin" : "hpCoin";
            var array = gameObjects.getObject(item);
            array.add(this.xPos - Math.round(random(-this.width * 0.4, this.width * 0.4)),
            this.yPos - Math.round(random(-this.height * 0.4, this.height * 0.4)), this.halfWidth);  
            cameraGrid.addReference(array.getLast());
        }
    };
    
    this.break = function()
    {
        this.remove();
        if(!this.droppedItems)
        {
            this.addDrops();
            this.droppedItems = true;
        }
    };
    
    this.draw = function()
    {
        noStroke();
        fill(this.color);
        fastRect(this.xPos, this.yPos, this.width, this.height);

        fill(this.color, this.color, this.color, 20);
        fastRect(this.xPos + this.width * 0.15, this.yPos + this.height * 0.15, this.width * 0.7, this.height * 0.7);

        fill(0, 0, 0, 50);
        triangle(this.xPos, this.yPos, this.xPos + this.width, this.yPos, this.xPos, this.yPos + this.height);
        
        if(this.noBreak)
        {
            fill(0, 0, 0, 50);
            triangle(this.xPos, this.yPos, this.xPos + this.width, this.yPos + this.height, this.xPos, this.yPos + this.height); 
        }
    };
 
    this.lastDraw = this.draw;
 
    screenUtils.loadImage(this, true, "crate" + this.noBreak);

    this.lastUpdate = this.update;
    this.update = function()
    {
        this.lastUpdate();
        
        if(!this.noBreak)
        {
            if(this.broken || this.breakPercent >= 70)
            {
                this.color = color(red(this.color), green(this.color), blue(this.color), alpha(this.color) - 5);  
                this.changeDraw = true;
            }
            
            if(this.breakPercent >= 100)
            {
                this.broken = true;  
            }
            
            if(alpha(this.color) < 30)
            {
                this.break();
            }
            
            if(this.changeDraw && !this.changedDraw)
            {
                this.draw = this.lastDraw;
                this.changedDraw = true;  
            }
        }
        this.lastYVel = this.yVel;
    };
    
    this.onCollide = function(object, info)
    {
        if(this.noBreak)
        {
            return;
        }

        if(object.type === "block")
        {
            if(this.lastYVel >= this.maxYVel * 0.9)
            {
                this.broken = true;
            }
            if(abs(this.lastXPos - this.xPos) >= this.maxXVel * 0.9)
            {
                this.breakPercent += this.breakRate;
            }
        }
        else if(object.physics.movement === "dynamic" && abs(this.xVel) >= this.maxXVel * 0.3 && object.arrayName !== this.arrayName)
        {
            this.breakPercent += this.breakRate;
        }
    };
};
gameObjects.addObject("crate", createArray(Crate));

var Key = function(xPos, yPos, width, height, colorValue)
{
    Rect.call(this, xPos, yPos, width, height);
    this.physics.solidObject = false;
    this.color = colorValue || color(180, 170, 30);
    this.goto = {};
    this.type = "item";

    this.updateBoundingBox = function()
    {
        this.boundingBox.xPos = this.xPos;
        this.boundingBox.yPos = this.yPos;
    };

    this.draw = function()
    {
        shapes.key(this.xPos, this.yPos, this.width, this.height);
    };
    
    screenUtils.loadImage(this, true, "key", true);

    this.lastDraw = this.draw;
    this.draw = function()
    {
        if(this.goto.hidden)
        {
            return;
        }

        this.lastDraw();

        if(this.goto.style === "boss")
        {
            var w = width;
            var h = height;
            var x = xPos;
            var y = yPos;

            var unitW = w / 3;
            var unitH = h / 6;
            var unitW2 = unitW * 2;
            var unitH2 = unitH * 2;

            noStroke();
            fill(35, 210 - 60, 160);
            fastRect(x + unitW * 2, y + 4 * unitH, 0.6 * unitW, unitH * 0.7);
            fastRect(x + unitW * 2, y + 5.3 * unitH, unitW, unitH * 0.7);
            fill(35, 210, 70);
            fastRect(x + unitW, y + unitH * 3, unitW, unitH * 3);
            fill(35, 210 - 80, 160);
            fastRect(x, y, unitW2, unitH);
            fill(35, 210 - 60, 160);
            fastRect(x + unitW2, y, unitW, unitH2);
            fill(35, 210 - 40, 160);
            fastRect(x + unitW, y + unitH2, unitW2, unitH);
            fill(35, 210 - 20, 160);
            fastRect(x, y + unitH, unitW, unitH2);
        }
        
        if(this.msgWidth === undefined)
        {
            this.msg = "Key " + this.goto.level + " " + this.goto.symbol;
            textSize(11);
            this.msgWidth = textWidth(this.msg) * 1.2;
            this.lastMsgWidth = this.msgWidth;
        }

        fill(0, 0, 0, 100);
        $pjs.rect(this.xPos + this.halfWidth - this.msgWidth / 2, this.yPos - this.height * 0.75, this.msgWidth, this.halfHeight, 5);
        fill(200, 200, 200, 170);
        textAlign(CENTER, CENTER);
        textSize(11);
        text(this.msg, this.xPos + this.halfWidth, this.yPos - this.halfHeight);
    };
    
    this.lastUpdate = this.update;
    this.update = function()
    {
        if(this.goto.hidden)
        {
            return;
        }

        this.lastUpdate();

        //Remove if the player already has the key
        if(!this.checked)
        {
            var object = player;
            if(object.goto.keysHolding !== undefined &&
            object.goto.keysHolding[this.goto.level + this.goto.symbol] !== undefined &&
            object.goto.keysHolding[this.goto.level + this.goto.symbol].collected)
            {
                this.remove();
            }
            this.checked = true;
        }
    };

    this.onCollide = function(object)
    {
        if(this.goto.hidden)
        {
            return;
        }

        if(object.collectItem !== undefined && object.collectItem())
        {
            sounds.mplaySound("coin.mp3");
            if(object.goto.keysHolding === undefined)
            {
                object.goto.keysHolding = {};
            }
            object.goto.keysHolding[this.goto.level + this.goto.symbol] = this.goto;
            this.goto.collected = true;
            this.remove();
        }
    };
};
gameObjects.addObject("key", createArray(Key));

var CheckPoint = function(xPos, yPos, width, height, colorValue, invisible)
{
    Rect.call(this, xPos, yPos, width, height);
    this.physics.solidObject = false;
    this.green = color(28, 156, 30);
    this.color = colorValue || color(200, 0, 0);
    this.type = "use";
    this.xDiv = this.width * 0.2;
    this.xOff = this.width * 0.13;
    this.flagX2 = this.xOff + this.xDiv;
    this.flagRightX2 = this.width * 0.7 + this.xDiv;
    this.midY = this.yPos + this.height / 4;
    this.bottomY = this.yPos + this.halfHeight;
    this.invisible = invisible;
    
    this.message = "";
    this.timer = 0;
    this.maxTimer = 100;

    this.loadImg = function(colorValue)
    {
        var img = createGraphics(0, 0, P2D);
        img.noStroke();
        img.beginDraw();
        img.background(0, 0, 0, 0);
        img.fill(colorValue);
        img.triangle(this.flagX2, 0, this.flagX2, this.halfHeight, this.flagRightX2, this.height / 4);
        img.fill(0, 0, 0, 50);
        img.fastRect(this.xDiv, 0, this.xOff, this.height);
        img.endDraw();
        return img;
    };
    
    this.draw = function()
    {
        if(storedImages.redFlag === undefined)
        {
            storedImages.redFlag = this.loadImg(color(200, 0, 0));
        }
        if(storedImages.flag === undefined)
        {
            storedImages.flag = this.loadImg(this.green || this.color);
        }
        
        this.draw = function()
        {
            if(this.invisible)
            {
                return;  
            }
            if(this.color !== color(200, 0, 0))
            {
                image(storedImages.flag, this.xPos, this.yPos);
            }else{
                image(storedImages.redFlag, this.xPos, this.yPos);
            }

            if(this.timer <= 0)
            {
                this.message = "";
            }else{
                if(!screenUtils.debugMenuWhite)
                {
                    fill(40, 40, 40, this.timer * 255 / this.maxTimer);
                }else{
                    fill(255, 255, 255, this.timer * 255 / this.maxTimer);
                }

                textAlign(CENTER, CENTER);
                textSize(12);
                text(this.message, this.xPos + this.halfWidth, this.yPos - this.height * 1.5);
            }

            this.timer--;
        };
    };
    
    if(this.goto === undefined)
    {
        this.goto = {};
    }

    this.setObjectProps = function(object)
    {   
        object.save = true;
        object.goto.checkPointLevel = this.goto.level || levelInfo.level;
        object.goto.checkPointIndex = this.index;

        //Don't save if we're not in the play state!
        if(game.gameState === "play")
        {
            if((!this.checked || object.overrideSave !== undefined && object.overrideSave()) && object.onCheckPoint !== undefined)
            {
                object.onCheckPoint(this);
                this.message = "Game saved";
                this.timer = this.maxTimer;
            }

            this.checked = true;
            this.color = this.green;
        }
    };
    
    this.onCollide = function(object)
    {
        if(!this.invisible && object.useCheckPoint !== undefined && object.useCheckPoint())
        {
            this.setObjectProps(object);
        }
    };
};
gameObjects.addObject("checkPoint", createArray(CheckPoint));

var Chest = function(xPos, yPos, width, height)
{
    Rect.call(this, xPos, yPos, width, height);

    this.img = "chest";
   
    this.physics.solidObject = false;

    this.goto = {};

    var eX, eY, pX, pY;

    this.draw = function()
    {
        if(this.goto.hidden)
        {
            var mTime = millis() - this.goto.unHideTimer;

            if(this.goto.unHideTime && (mTime < this.goto.unHideTime))
            {
                eX = mTime * width / this.goto.unHideTime;
                eY = mTime * height / this.goto.unHideTime;
                pX = this.xPos - eX / 2 + this.halfWidth;
                pY = this.yPos - eY / 2 + this.halfHeight;

                fill(0, 0, 0, 50);
                $pjs.rect(pX, this.yPos - eY * 10, eX, eY * 20, 10);
                $pjs.rect(this.xPos - eX * 10, pY, eX * 20, eY, 10);

                image(storedImages[this.img], pX, pY, eX, eY);

                fill(0, 0, 0, 60);
                $pjs.rect(this.xPos + random(-this.halfWidth, this.halfWidth) + this.halfWidth, this.yPos + random(-this.halfHeight, this.halfHeight) + this.halfHeight, this.width * 0.2, this.height * 0.2);
            }

            return;
        }

        fill(0, 0, 0, 50);
        $pjs.rect(pX, this.yPos - eY * 10, eX, eY * 20, 10);
        $pjs.rect(this.xPos - eX * 10, pY, eX * 20, eY, 10);

        this.img = (this.goto.isOpen) ? "chest-open" : "chest";
        image(storedImages[this.img], this.xPos, this.yPos, this.width, this.height);

        fill(0, 0, 0, 50);
        fastRect(this.xPos, this.yPos, this.width, this.height);
    };


    this.lastUpdate = this.update;
    this.update = function()
    {
        if(this.goto.unHideTime && (millis() - this.goto.unHideTimer >= this.goto.unHideTime))
        {
            this.goto.hidden = false;
        }

        if(this.goto.hidden)
        {
            return;
        }

        this.lastUpdate();

        //Regeneration logic.
        if(!this.set)
        {
            if(this.goto.regen)
            {
                this.goto.isOpen = false;

                for(var i = 0; i < this.drops.length; i++)
                {
                    this.drops[i].col1 = false;
                }
            }
            else if(this.goto.save)
            {
                var k = 0;
                this.drops.forEach(function(element) 
                {
                    if(element.col1)
                    {
                        k++;
                    }
                });

                if(k < this.drops.length)
                {
                    this.goto.isOpen = false;
                }
            };

            this.set = true;
        }
    };

    this.dispenseDrop = function(drop)
    {
        for(var j = 0; j < (drop.amt || 1); j++)
        {
            var array = gameObjects.getObject(drop.contains || drop.name);
            if(array.add !== undefined)
            {
                array.add(this.xPos + random(-this.halfWidth, this.halfHeight) + (drop.offX || 0), 
                this.yPos - this.height * 1.2 + (drop.offY || 0), 
                levelInfo.unitWidth / 2 * (drop.scale || 1), 
                levelInfo.unitHeight / 2 * (drop.scale || 1));

                if(array.getLast().physics.shape === "circle")
                {
                    array.pop();
                    var coinAmt = (drop.props || {}).coinAmt;
                    array.add(this.xPos + (drop.xPos || random(-this.halfWidth, this.halfWidth)),
                    this.yPos + (drop.yPos || (random(-this.halfHeight, this.halfHeight) - this.height * 2)), drop.diameter || (levelInfo.unitWidth / 2 * ((coinAmt / 35) || 1)), undefined, coinAmt);
                }

                var object = array.getLast();
                object.lastRemove1 = object.remove;
                object.remove = function()
                {
                    this.lastRemove1();
                    drop.col1 = true;
                };

                cameraGrid.addReference(array.getLast());
            }
        }
    };

    this.dispense = function()
    {
        for(var i = 0; i < this.drops.length; i++)
        {
            if(this.drops[i].total && !this.drops[i].col1)
            {
                this.dispenseDrop(this.drops[i]);
            }
        }
    };

    this.onCollide = function(object)
    {
        if(this.goto.hidden)
        {
            return;
        }

        if(object.openChest !== undefined && object.openChest() && (!this.goto.isOpen || (!this.opened && this.goto.regen)))
        {
            this.goto.isOpen = true;
            this.opened = true;
            this.dispense();
        }
    };
};
gameObjects.addObject("chest", createArray(Chest));

var ItemChest = function(xPos, yPos, width, height)
{
    Rect.call(this, xPos, yPos, width, height);

    this.img = "itemChest";
    this.isOpen = false;

    this.physics.solidObject = false;

    this.goto = {
        items : [],
    };

    this.maxItems = 10;

    var eX, eY, pX, pY;

    this.draw = function()
    {
        if(this.goto.hidden)
        {
            var mTime = millis() - this.goto.unHideTimer;

            if(this.goto.unHideTime && (mTime < this.goto.unHideTime))
            {
                eX = mTime * width / this.goto.unHideTime;
                eY = mTime * height / this.goto.unHideTime;
                pX = this.xPos - eX / 2 + this.halfWidth;
                pY = this.yPos - eY / 2 + this.halfHeight;

                fill(0, 0, 0, 50);
                $pjs.rect(pX, this.yPos - eY * 10, eX, eY * 20, 10);
                $pjs.rect(this.xPos - eX * 10, pY, eX * 20, eY, 10);

                image(storedImages[this.img], pX, pY, eX, eY);

                fill(0, 0, 0, 60);
                $pjs.rect(this.xPos + random(-this.halfWidth, this.halfWidth) + this.halfWidth, this.yPos + random(-this.halfHeight, this.halfHeight) + this.halfHeight, this.width * 0.2, this.height * 0.2);
            }

            return;
        }

        this.img = (this.goto.isOpen) ? "itemChest-open" : "itemChest";
        image(storedImages[this.img], this.xPos, this.yPos, this.width, this.height);

        if(this.goto.locked)
        {
            fill(0, 0, 0, 100);
            fastRect(this.xPos, this.yPos, this.width, this.height);
        }
    };

    var self = this;

    this.updateItemsOrder = function(scene)
    {
        for(var i = 0; i < self.goto.items.length; i++)
        {
            var item = self.goto.items[i];

            if(!item || !item.contains)
            {
                scene.buttons["slot_" + i] = new Button(186, 132 + i * 18, 140, 18, color(28, 28, 28, 100), " - ");
            }else{
                scene.buttons["slot_" + i] = new Button(186, 132 + i * 18, 140, 18, color(12, 60, 160, 100), " - ");
                scene.buttons["slot_" + i].message = self.goto.items[i].displayName || 
                (usableItems[self.goto.items[i].contains] ? 
                usableItems[self.goto.items[i].contains].displayName : false) || self.goto.items[i].contains;
            }
            scene.buttons["slot_" + i].textSize = 10;
            scene.buttons["slot_" + i].textColor = color(240, 240, 240, 200);
            scene.buttons["slot_" + i].hover = self.goto.items[i].description || 
                (usableItems[self.goto.items[i].contains] ? 
                usableItems[self.goto.items[i].contains].description : false) || 
                scene.buttons["slot_" + i].hover;

            if(scene.buttons["slot_" + i].message !== " - ")
            {
                scene.buttons["slot_" + i].extra = (self.goto.items[i].amount ? " x " + self.goto.items[i].amount : "");
            }else{
                delete scene.buttons["slot_" + i].extra;
            }
        }
    };

    this.onOpen = function(object)
    {
        if(this.goto.locked)
        {
            return;
        }

        inventoryMenu.open("chest", {
            init : function(scene)
            {
                scene.remoteMode = true;

                try{
                    object.onOpenItems(scene);
                }
                catch(e)
                {
                    console.log(e);
                }

                try{
                    //Create swapping buttons
                    for(var i = 0; i < min(object.inventory.slots, self.goto.items.length); i++)
                    {
                        scene.buttons["swap_" + i] = new Button(150, 132 + i * 18, 36, 18, color(28, 180, 48, 100), "< >");
                        scene.buttons["swap_" + i].textSize = 10;

                        scene.buttons["swap_" + i].lastHitTime = millis();

                        scene.buttons["swap_" + i].index = i;
                        scene.buttons["swap_" + i].onClick = function(override, override2)
                        {
                            if(!override2)
                            {
                                if(!mouseIsPressed)
                                {
                                    this.lastHitTime = 0;
                                    return;
                                }

                                if(millis() - this.lastHitTime < 1000)
                                {
                                    return;
                                }
                            }

                            var i = this.index;
                            var temp = object.inventory.items[i];
                            object.inventory.items[i] = self.goto.items[i];
                            self.goto.items[i] = temp;

                            var player_btn = scene.buttons["player_" + i];
                            var slot_btn = scene.buttons["slot_" + i];

                            var player_item = object.inventory.items[i];
                            var slot_item = self.goto.items[i];

                            player_btn.message = object.inventory.items[i].displayName || object.inventory.items[i].contains || " - ";
                            slot_btn.message = self.goto.items[i].displayName || self.goto.items[i].contains || " - ";

                            if(player_btn.message !== " - ")
                            {
                                player_btn.extra = (player_item.amount ? " x " + player_item.amount : "")
                            }else{
                                delete player_btn.extra;
                            }

                            if(slot_btn.message !== " - ")
                            {
                                slot_btn.extra = (slot_item.amount ? " x " + slot_item.amount : "");
                            }else{
                                delete slot_btn.extra;
                            }

                            var swap = player_btn.hover;
                            player_btn.hover = slot_btn.hover;
                            slot_btn.hover = swap;

                            player_btn.firstColor = player_btn.color = (player_btn.message === " - ") ? color(28, 28, 28, 100) : color(12, 60, 160, 100);
                            slot_btn.firstColor = slot_btn.color = (slot_btn.message === " - ") ? color(28, 28, 28, 100) : color(12, 60, 160, 100);

                            player_btn.textSize = 10;
                            slot_btn.textSize = 10;

                            this.lastHitTime = millis();
                        };
                    }
                }
                catch(e)
                {
                    console.log(e);
                }

                self.updateItemsOrder(scene);

                scene.buttons["change_all"] = new Button(150, 312, 36, 18, color(28, 180, 48, 100), "< >", undefined, 11);
                scene.buttons["change_all"].lastHitTime = 0;
                scene.buttons["change_all"].onClick = function()
                {
                    if(!mouseIsPressed)
                    {
                        this.lastHitTime = 0;
                        return;
                    }

                    if(millis() - this.lastHitTime < 300)
                    {
                        return;
                    }

                    for(var i = 0; i <  min(object.inventory.slots, self.goto.items.length); i++)
                    {
                        scene.buttons["swap_" + i].onClick(false, true);
                    }

                    this.lastHitTime = millis();
                };

                scene.buttons["slot_up"] = new Button(186, 312, 70, 18, color(28, 180, 48, 100), "^", undefined, 11);
                scene.buttons["slot_up"].lastHitTime = 0;
                scene.buttons["slot_up"].onClick = function()
                {
                    if(!mouseIsPressed)
                    {
                        this.lastHitTime = 0;
                        return;
                    }

                    if(millis() - this.lastHitTime < 140)
                    {
                        return;
                    }

                    self.goto.items.push(self.goto.items.shift());
                    self.updateItemsOrder(scene);

                    this.lastHitTime = millis();
                };

                scene.buttons["slot_down"] = new Button(256, 312, 70, 18, color(28, 180, 48, 100), "v", undefined, 11);
                scene.buttons["slot_down"].lastHitTime = 0;
                scene.buttons["slot_down"].onClick = function()
                {
                    if(!mouseIsPressed)
                    {
                        this.lastHitTime = 0;
                        return;
                    }

                    if(millis() - this.lastHitTime < 140)
                    {
                        return;
                    }

                    self.goto.items.unshift(self.goto.items.pop());
                    self.updateItemsOrder(scene);

                    this.lastHitTime = millis();
                };
            },
            close : function()
            {     
                if(object.openChest(true) || keys.e)
                {
                    self.goto.isOpen = false;
                    inventoryMenu.scenes[inventoryMenu.scene].remoteMode = false;

                    return ["chest", function()
                    {
                        game.switchGameState(true, "play", true); 
                    }];
                }
            },
        });
        game.switchGameState(true, "inventoryMenu", true); 
    };

    this.lastToggleTime = 0;

    var _lastUpdate = this.update;
    this.update = function()
    {
        if(this.goto.unHideTime && (millis() - this.goto.unHideTimer >= this.goto.unHideTime))
        {
            this.goto.hidden = false;
        }

        this.goto.items.length = min(this.goto.items.length, this.maxItems);

        return _lastUpdate.apply(this, arguments);
    };

    this.onCollide = function(object)
    {
        if(object.coins && this.goto.locked && typeof this.goto.costToUnlock === "number" && object.openChest !== undefined && object.openChest())
        {
            if(object.coins >= this.goto.costToUnlock)
            {
                object.coins -= this.goto.costToUnlock;
                this.goto.locked = false;

                // Yeah this is a "bad" fix, generally you'd want to avoid doing something like this!
                // Just so if the player presses 'r' they don't gain back those coins.
                // But then again almost no-one would know...
                game.save();
                return;
            }
        }

        if(this.goto.hidden || this.goto.locked)
        {
            return;
        }

        if(!keyIsPressed)
        {
            this.lastToggleTime = 0;
        }

        if(object.openChest !== undefined && object.openChest() && millis() - this.lastToggleTime > 500)
        {
            object.xVel = 0;
            object.yVel = 0;

            if(!this.goto.isOpen)
            {
                this.goto.isOpen = true;
                this.onOpen(object);
            }else{
                this.goto.isOpen = false;
            }

            this.lastToggleTime = millis();
        } 
    };
};
gameObjects.addObject("itemChest", createArray(ItemChest));

//Cloud mines, they hide in the clouds
var CloudMine = function(xPos, yPos, diameter)
{
    Circle.call(this, xPos, yPos, diameter);

    this.damage = 3.5;
    this.activated = false;
    this.timer = 1;

    this.ex = {
        diameter : this.diameter * 1,
    };
    this.color = color(255, 255, 255, 100);

    this.lastDiameter = this.diameter;
    this.maxDiameter = this.lastDiameter * 3.5;

    this.physics.movement = "dynamic";

    this.idInput = Math.round(random(0, 100));

    this.updateBoundingBox = function()
    {
        this.boundingBox.xPos = this.xPos - this.radius;
        this.boundingBox.yPos = this.yPos - this.radius;
        this.boundingBox.width = this.diameter;
        this.boundingBox.height = this.diameter;
    };

    var self = this;
    var particles = [];
    particles.create = function(amt, gravity)
    {
        this.gravity = gravity;
        for(var i = 0; i < amt; i++)
        {
            this.push({
                xPos : self.xPos,
                yPos : self.yPos,
                yVel : Math.round(random(-5, 5)),
                xVel : Math.round(random(-5, 5)), 
                diameter : random(2, 7),
                color : color(0, random(100, 200), 0, random(50, 150)),
            });
        }
    };
    particles.update = function(selfRadius, bounce)
    {
        for(var i = 0; i < this.length; i++)
        {
            this[i].yVel += this.gravity;
            this[i].xPos += this[i].xVel;
            this[i].yPos += this[i].yVel;

            if(bounce && !this[i].out && dist(this[i].xPos, this[i].yPos, self.xPos, self.yPos) >= selfRadius - this[i].diameter / 2)
            {
                this[i].xVel = -this[i].xVel;
                this[i].yVel = -this[i].yVel;
                this[i].out = true;
            }else{
                this[i].out = false;
            }
        }
    };
    particles.draw = function()
    {
        for(var i = 0; i < this.length; i++)
        {
            fill(this[i].color);
            circle(this[i].xPos, this[i].yPos, this[i].diameter);
        }
    };

    this.particles = particles;
    this.particles.create(random(25, 125), 0.3);

    this.explode = function()
    {
        //The explosion rendering code
        fill(200, 0, 0, 100);
        circle(this.xPos, this.yPos, this.ex.diameter);

        noStroke();
        fill(200, 0, 0, 100);
        circle(this.xPos, this.yPos, this.ex.diameter * 0.7);

        fill(200, 210, 0, 100);
        circle(this.xPos, this.yPos, this.ex.diameter * 0.2);

        if(this.ex.diameter < this.maxDiameter)
        {
            this.ex.diameter += 6;
        }
    };

    this.toSetAfter = true;
    this.setAfter = function()
    {
        this.fixturePlace = (this.arrayName + this.index);

        this.getPlace = cameraGrid.getPlace(this.boundingBox.xPos, this.boundingBox.yPos);
        
        lighting.fixtures[this.fixturePlace] = {
            xPos : this.xPos,
            yPos : this.yPos,
            range : 110,
            brightness : 60, //0-100
            centeredLighting : 90,
            state : this.physics.movement,
        };

        lighting.fixtures[this.fixturePlace].place = this.getPlace;

        var place = cameraGrid.getPlace(this.xPos, this.yPos);
        cameraGrid[place.col][place.row]._lights[this.fixturePlace] = this.fixturePlace;
    };

    this.lastUpdate = this.update;
    this.update = function()
    {
        this.lastUpdate();
        /*if(this.inWater)
        {
            return;
        }*/

        if(this.activated)
        {
            this.timer--;
            if(!this.blasted)
            {
                sounds.mplaySound("explosion.mp3");
                this.blasted = true;
            }
        }

        if(this.timer < 0)
        {
            this.diameter = this.ex.diameter;
            this.radius = this.diameter / 2;
            this.physics.solidObject = false;
            this.physics.movement = "dynamic";
            this.updateBoundingBox();
        }

        if(this.timer < -120)
        {
            this.remove();
        } 

        if(this.ex.diameter > this.lastDiameter * 1.5)
        {
            this.particles.update(this.ex.diameter / 2, this.ex.diameter < this.maxDiameter);
        }
    };

    this.lastDraw = this.draw;
    this.draw = function()
    {
        if(this.timer >= 0)
        {
            this.lastDraw();
        }

        if(this.timer < 0 && this.ex.diameter < this.maxDiameter)
        {
            this.explode();
        }
        if(this.timer < 0)
        {
            particles.draw(); 
        } 

        this.silentTimer--;
    };

    this.onCollide = function(object)
    {
        /*if(object.arrayName === "water" && this.diameter <= this.lastDiameter)
        {
            this.timer = 0;
            this.activated = false;
            this.physics.solidObject = true;
            this.physics.movement = "static";
            this.inWater = true;
            this.onCollide = function() {};
        }
        else*/ 
        if(!this.activated)
        {
            this.physics.movement = "static";
        }

        if(object.type === "block" && object.arrayName !== "block" && object.imageName !== "cathodes2" && object.imageName !== "up" && 
           object.arrayName !== "oneWay" && object.arrayName !== "movingPlatform" && 
           object.arrayName !== "cloud" && object.arrayName !== "crate" && object.arrayName !== "hardCaseBlock" && !object.explosive)
        {
            object.remove();
        }
        else if(object.arrayName === this.arrayName)
        {
            if(this.timer < -17.5)
            {
                object.activated = true;
            }
        }
        else if((object.type === "lifeform" && object.arrayName !== "waterBeaker") || object.explosive)
        {
            this.activated = true;
            if(object.physics.shape === "rect" && this.ex.diameter < this.maxDiameter)
            {
                this.inputAngle = atan2((object.yPos + object.halfHeight) - this.yPos, (object.xPos + object.halfWidth) - this.xPos);
                if(this.inputAngle !== undefined)
                {
                    object.xVel += cos(this.inputAngle) * 4;
                    object.yVel += sin(this.inputAngle) * 4;
                }
            }
            if(!object["damagedByMine" + this.idInput] && this.ex.diameter < this.maxDiameter)
            {
                if(object.takeDamage !== undefined)
                {
                    object.takeDamage(this);
                }else{
                    object.hp -= this.damage;
                }
                object["damagedByMine" + this.idInput] = true;
            }

            if(object.arrayName === "crate")
            {
                object.remove();
            }
        }
        else if(object.arrayName === "waterBeaker")
        {
            object.xDir = (object.xDir === "left") ? "right" : "left";
        }
    };
};
gameObjects.addObject("cloudMine", createArray(CloudMine));

var addParticleRules = function(object)
{
    object.physics.solidObject = false;
    object.physics.shape = "point";
    object.boundingBox = {};
    object.boundingBox.off = true;
    object.physics.movement = "dynamic";
};

var Spike = function(xPos, yPos, width, height, colorValue, upSideDown)
{
    Rect.call(this, xPos, yPos, width, height);
    this.color = colorValue || color(155, 155, 155);
    this.physics.solidObject = false;

    var slopes = gameObjects.getObject("slope");
    var halfWidth = this.halfWidth;
    var fourthWidth = this.width / 4;
    var halfHeight = this.halfHeight;

    this.slopes = [];
    this.rects = [];

    this.updateBoundingBox = function()
    {
        this.boundingBox.xPos = this.xPos;
        this.boundingBox.yPos = this.yPos;
    };

    if(!upSideDown)
    {
        slopes.add(this.xPos, this.yPos + 1, halfWidth, this.height, this.color);
        slopes.getLast().direction = "rightup";
        slopes.getLast().fromSpike = true;
        this.slopes.push(slopes.length - 1);

        slopes.add(this.xPos + halfWidth, this.yPos + 1, halfWidth, this.height, this.color);
        slopes.getLast().direction = "leftup";
        slopes.getLast().fromSpike = true;
        this.slopes.push(slopes.length - 1);

        var rects = gameObjects.getObject("rect");
        this.rects.push(rects.add(this.xPos, this.yPos + this.height, this.width, 5));
        rects.getLast().color = this.color;
    }else{
        slopes.add(this.xPos, this.yPos, halfWidth, this.height - 1, this.color).draw = function() {};
        slopes.getLast().direction = "rightdown";
        this.slopes.push(slopes.length - 1);

        slopes.add(this.xPos + fourthWidth, this.yPos, fourthWidth, halfHeight, this.color).draw = function() {};
        slopes.getLast().direction = "rightdown";
        this.slopes.push(slopes.length - 1);

        slopes.add(this.xPos + halfWidth, this.yPos, halfWidth, this.height - 1, this.color).draw = function() {};
        slopes.getLast().direction = "leftdown";
        this.slopes.push(slopes.length - 1);

        slopes.add(this.xPos + halfWidth, this.yPos, fourthWidth, halfHeight, this.color).draw = function() {};
        slopes.getLast().direction = "leftdown";
        this.slopes.push(slopes.length - 1);
    }

    this.pOffset = floor(random(-30, 20));

    this.hp = 70;
    this.maxHp = 70;


    this.shakePos = 0;
    this.shakeVel = 2;

    this.shake = function()
    {
        if(abs(this.shakePos) > 3.5)
        {
            this.shakeVel = -this.shakeVel;
        }

        this.shakePos += this.shakeVel;
    };

    this.draw = ((upSideDown) ? function()
    {
        fill(red(this.color), green(this.color), blue(this.color), this.hp * 255 / this.maxHp);
        triangle(this.xPos + this.halfWidth + this.shakePos, this.yPos + this.height, this.xPos + this.shakePos, 
                 this.yPos, this.xPos + this.width + this.shakePos, this.yPos);

        if(!this.winter)
        {
            fill(70, 200, 80, 120 + this.pOffset);
            fastRect(this.xPos + 5, yPos, this.width - 10, this.yPos - yPos);
        }
    }
    : function()
    {
        fill(this.color);
        triangle(this.xPos + this.halfWidth, this.yPos, this.xPos, this.yPos + this.height, this.xPos + this.width, this.yPos + this.height);
    });

    this.damage = 1.5;

    this.updatePoint = function()
    {
        this.point = {
            physics : {
                shape : "point",
            },
            xPos : this.xPos + this.halfWidth,
            yPos : this.yPos + ((upSideDown) ? this.height : 0),
        };
    };

    this.updatePoint();

    var lastRemove = this.remove;
    this.remove = function()
    {
        this.move(this.xPos, -Infinity, true);

        return lastRemove.apply(this, arguments);
    };

    this.startedShakeAndFall = false;
    this.shatter = function() {};

    this.fallSpeed = 4;
    this.incrementFallSpeed = 0.33;

    this.shakeTime = 0;
    this.shakeAndFall = function()
    {
        if(this.shakeTime < 40)
        {
            this.shake();
            this.shakeTime++;

            this.damage = 2;
        }else{
            this.shakePos = 0;

            var slopes = gameObjects.getObject("slope");
            this.slopes.forEach(function(element, index, array) 
            {
                var slope = slopes[element];

                slope.physics.solidObject = false;
            });

            var ice = new Ice(this.xPos, this.yPos, this.width, this.height, this.color);
            this.shatter = ice.shatter;
            this.shapes = ice.shapes;

            this.physics.movement = "dynamic";
            this.move(this.xPos, this.yPos + this.fallSpeed, true);

            this.fallSpeed += this.incrementFallSpeed;
            this.fallSpeed = min(this.fallSpeed, 12.2);
        }
    };

    var self = this;
    this.addCast = function(onTarget)
    {
        gameObjects.getObject("cast").add(
            this.xPos + this.halfWidth, this.yPos + this.height * 2, 3, this.arrayName, function(object)
        {
            if(object.physics === undefined)
            {
                return;
            }

            if(object.arrayName === "player")
            {
                self.startedShakeAndFall = true;
            }
        },
        function(cast)
        {
            cast.xPos = self.xPos + self.halfWidth;  
            cast.yPos = self.yPos + self.halfHeight * 2;
        }, false, 400);

        this.cast = gameObjects.getObject("cast").getLast();
        this.cast.ignore.push("slope");
        this.cast.yVel = 12;

        cameraGrid.addReference(this.cast);
    };

    this.lastAddCastTime = millis();

    this.update = function()
    {
        this.makeBlink = (this.updateMe && !this.dead);

        if(this.shattered)
        {
            this.remove();
        }

        if(this.falls)
        {
            if(levelInfo.level === "IceDragon" && !this.dragonHit)
            {
                var iceDragon = gameObjects.getObject("iceDragon")[0];

                if(observer.collisionTypes.rectrect.colliding(this.boundingBox, iceDragon.boundingBox))
                {
                    iceDragon.hp -= (this.damage || 2);

                    this.dragonHit = true;
                    return this.remove();
                }
            }

            if(this.startedShakeAndFall)
            {
                this.shakeAndFall();
            }
            else if(!this.cast)
            {
                this.addCast();
            }
        }

        if(!this.updateMe)
        {
            return;
        }

        if(this.hp < 20)
        {
            this.dead = true;
            this.move(0, this.yPos + 10, true);
        }

        if(!this.spittedOut && this.hp < 20)
        {
            physics.getMiddleXPos(this);

            var hpCoins = gameObjects.getObject("hpCoin");
            for(var i = 0; i < Math.round(random(2, 5)); i++)
            {
                hpCoins.add(this.middleXPos + Math.round(random(-this.halfWidth + 10, this.halfWidth - 10)), yPos + 100 + random(-30, 300), 10, 0, 1);
                cameraGrid.addReference(hpCoins.getLast());
            }

            this.spittedOut = true;
        }
    };

    this.move = function(x, y, override)
    {
        if(!this.updateMe && !this.falls || this.hp < 20 && !override)
        {
            return;
        }

        cameraGrid.removeReference(this);

        this.xPos = x || this.xPos;
        this.yPos = y || this.yPos;

        this.updatePoint();
        this.updateBoundingBox();

        cameraGrid.addReference(this);

        this.slopes.forEach(function(element, index, array) 
        {
            var slope = slopes[element];
            cameraGrid.removeReference(slope);

            slope.xPos = x || this.xPos;
            slope.yPos = y || this.yPos;

            slope.updateBoundingBox();
            cameraGrid.addReference(slope);
        });
    };

    this.avoidCollision = function(object)
    {
        return (this.makeBlink && object.invincibleToLifeForm || object.arrayName === "voxelizer");
    };

    this.lastPlay = 0;

    this.onCollide = function(object)
    {
        if(this.falls)
        {
            if(this.startedShakeAndFall && object.arrayName !== "slope" && object.arrayName !== "fallingBlock" && 
              (object.physics.solidObject && object.physics.movement === "static") || object.arrayName === "player")
            {
                this.shatter(4, 4, 300);

                if(object.isLifeForm && !object.invincibleToLifeForm && !this.doneDamage)
                {
                    object.takeDamage(this);

                    this.doneDamage = true;
                }

                return;
            }
        }

        if(object.type === "lifeform" && object.arrayName !== "ninja" && object.arrayName !== "voxelizer" && 
            object.arrayName !== "skyViper" && !object.isBoss)
        {
            if(observer.colliding(object, this.point))
            {
                if(!upSideDown)
                {
                    object.yVel -= 4;
                }else{
                    object.yVel += 4;

                    if(object.inAir && !object.invincibleToLifeForm)
                    {
                        object.yPos = this.point.yPos;
                    }
                }

                if(!this.makeBlink || !object.invincibleToLifeForm)
                {
                    object.takeDamage(this);
                }
            }
            else if(this.updateMe && object.yVel > 0 && object.inAir)
            {
                object.inAir = false;
                object.yVel = -5;
                object.yPos = this.yPos - object.height;

                this.move(0, this.yPos + 5);

                this.hp -= object.damage * 5;
            }
        }
    };
};
gameObjects.addObject("spike", createArray(Spike));

var Bullet = function(xPos, yPos, diameter, colorValue, blastAngle, damage, homing)
{
    Circle.call(this, xPos, yPos, diameter);
    
    this.physics.solidObject = false;
    this.physics.shape = "point";
     
    this.boundingBox = {};
    this.boundingBox.off = true;
    this.physics.movement = "dynamic";
    
    this.color = colorValue || color(255, 255, 255);
    
    this.blastAngle = blastAngle + ((MODE === "ka") ? 90 : 0) || 0;
    this.xVel = 0;
    this.yVel = 0;
    this.maxVel = 1;
    this.acl = 1;
  
    this.maxLife = 350;
    this.life = this.maxLife;
    this.homing = homing;
    
    this.getTarget = function()
    {
        // var player = gameObjects.getObject("player").getLast();
        return {
            xPos : player.xPos + player.halfWidth,
            yPos : player.yPos + player.halfHeight,
        };
    };
    
    this.changeAngleSpeed = 30;
    
    this.draw = function()
    {
        fill(red(this.color), green(this.color), blue(this.color), this.life * 215 / this.maxLife + 30);
        circle(this.xPos, this.yPos, this.diameter);  
    };
    
    this.lastUpdate = this.update;
    this.update = function()
    {
        this.lastUpdate();
        
        this.life--;
        if(this.life < 0)
        {
            this.remove();
        }
        
        if(this.homing)
        {
            var target = this.getTarget();
            var angle = atan2(target.yPos - this.yPos, target.xPos - this.xPos);
            if(this.blastAngle < angle)
            {
                this.blastAngle += min(this.changeAngleSpeed, abs(angle - this.blastAngle));
            }
            else if(this.blastAngle > angle)
            {
                this.blastAngle -= min(this.changeAngleSpeed, abs(angle - this.blastAngle));
            }
        }
        
        this.acl = this.maxVel;
        this.xVel = this.acl * cos(this.blastAngle);
        this.xVel = constrain(this.xVel, -this.maxVel, this.maxVel);
        this.xPos += this.xVel;
        
        this.yVel = this.acl * sin(this.blastAngle);
        this.yVel = constrain(this.yVel, -this.maxVel, this.maxVel);
        this.yPos += this.yVel;
    };
    
    this.damage = damage || 1;
    this.onCollide = function(object)
    {
        if(object.type === "lifeform" && !object.fromEnemy)
        {
            object.takeDamage(this);
            this.remove();
            this.onCollide = function() {};
        }
        else if(object.physics.solidObject && 
        object.arrayName !== this.arrayName && 
        object.arrayName !== "shooter")
        {
            this.remove();
            this.onCollide = function() {};
        }
    };
};
gameObjects.addObject("bullet", createArray(Bullet));

//A shooter is a factory that creates bullets!
var Shooter = function(xPos, yPos, diameter, colorValue)
{
    Circle.call(this, xPos, yPos, diameter);
    this.color = colorValue || color(125, 125, 255);
    
    this.shootSpeed = 1;
    this.shootTimer = 0;
    this.shootAngle = 0;
    
    this.hp = 75;
    this.maxHp = 75;
    this.hpBar = new Bar(this.xPos - this.radius, this.yPos - this.radius * 1.5, this.diameter, 5, color(34, 190, 51, 130), 10); 

    this.draw = function()
    {
        noStroke();
        fill(this.color);
        circle(this.xPos, this.yPos, this.diameter);

        $pjs.pushMatrix();
        translate(this.xPos, this.yPos);
        if(MODE === "pjs")
        {
            rotate((this.shootAngle * 57.29578) - 90);
        }else{
            rotate(this.shootAngle);  
        }
        $pjs.rect(-this.diameter * 0.15, 0, this.diameter * 0.3, this.diameter, 2);
        $pjs.popMatrix();
        
        fill(0, 0, 90, 50);
        circle(this.xPos, this.yPos, this.diameter * 0.8);

        this.hpBar.draw();
        this.hpBar.set(max(this.hp, 0), this.maxHp);
        
        if(this.hp <= this.maxHp * 0.4)
        {
            this.hpBar.color = color(190, 34, 51, 130);
        }
    };
    
    this.createBullet = function(self)
    {
        var homing = (random(0, 100) < 12.4);
        
        var colorValue;
        if(homing)
        {
            colorValue = color(0, 240, 20);  
        }
        gameObjects.getObject("bullet").add(self.xPos, self.yPos, self.diameter * 0.2, colorValue, this.shootAngle, 0.75, homing);
        
        var lastBullet = gameObjects.getObject("bullet").getLast();
        if(homing)
        {
            lastBullet.maxVel = 1.55;
            lastBullet.life = 200;
            lastBullet.damage = 2;
            sounds.mplaySound("laser3.mp3");
        }else{
            sounds.mplaySound("laser3.mp3", 0.012);
            lastBullet.damage = (this.minDamage || lastBullet.damage);
        }

        lastBullet.maxVel *= (this.upSpeed || 1);

        cameraGrid.addReference(lastBullet);
    };
    
    this.getTarget = function()
    {
        // var player = gameObjects.getObject("player").getLast();
        return {
            xPos : player.xPos + player.halfWidth,
            yPos : player.yPos + player.halfHeight,
        };
    };
    
    this.update = function()
    {
        var target = this.getTarget();
        if(MODE === "pjs")
        {
            this.shootAngle = atan2(this.yPos - target.yPos, this.xPos - target.xPos) - PI;
        }else{
            this.shootAngle = atan2(target.yPos - this.yPos, target.xPos - this.xPos) - 90;
        }
        
        this.shootTimer += this.shootSpeed;
        if(this.shootTimer >= 33)
        {
            this.shootTimer = 0;  
            this.createBullet(this);
        }
        
        if(this.hp <= 0)
        {
            this.shootTimer = 0;
            this.color = color(red(this.color), green(this.color), blue(this.color), alpha(this.color) - 2);
        }
        
        if(alpha(this.color) < 10)
        {
            this.remove();
        }
    };
    
    this.takeDamage = function(object, amt)
    {
        this.hp -= amt || object.damage;
    };

    this.onCollide = function(object)
    {
        if(object.arrayName === "player" && object.yPos + object.height < this.yPos)
        {
            this.takeDamage(object);
        }
    };
};
gameObjects.addObject("shooter", createArray(Shooter));

var Cast = function(xPos, yPos, diameter, objectArrayName, inform, setPos, oneTime, time)
{
    Circle.call(this, xPos, yPos, diameter);

    this.physics.solidObject = false;
    this.physics.shape = "point";
    
    this.xVel = 0;
    this.yVel = 0;
    
    this.boundingBox.off = true;
    this.physics.movement = "dynamic";
    
    this.timer = 0;
    this.time = time || 50;
    
    this.objectArrayName = objectArrayName;
    this.inform = inform;
    this.setPos = setPos;
    
    this.oneTime = oneTime;

    this.onKill = function()
    {
        if(this.setPos === undefined || this.oneTime)
        {
            this.remove();
        }else{
            this.setPos(this); 
            this.timer = 0;
        }
    };
     
    this.draw = function() {};
     
    this.signal = function()
    {
        return (this.timer === this.lastTimer);
    };
     
    this.update = function()
    {
        if(this.xVel !== 0)
        {
            this.xPos += this.xVel;
            if(constrain(this.xPos, cam.focusXPos - cam.halfWidth, cam.focusXPos + cam.halfWidth) !== this.xPos)
            {
                this.timer = this.time + 1;
            }
        }
        if(this.yVel !== 0)
        {
            this.yPos += this.yVel;
            if(constrain(this.yPos, cam.focusYPos - cam.halfHeight, cam.focusYPos + cam.halfHeight) !== this.yPos)
            {
                this.timer = this.time + 1;
            }
        }
        this.timer++;
        if(this.timer > this.time)
        {
            if(this.inform !== undefined)
            {
                this.inform({}, this);
            }
            this.onKill();  
        }
        this.lastTimer = this.timer;
    };

    this.ignore = [];

    this.onCollide = function(object)
    {    
        if(object.arrayName !== this.objectArrayName && (object.physics.solidObject || this.noSolid) && 
            this.ignore.indexOf(object.arrayName) === -1)
        {
            if(this.inform !== undefined)
            {
                this.inform(object, this);
            }
            this.onKill();
        }
    };
};
gameObjects.addObject("cast", createArray(Cast));

var Enemy = function(xPos, yPos, width, height, colorValue, props, complexDraw, hp, damage)
{
    DynamicRect.call(this, xPos, yPos, width, height);
    LifeForm.call(this, hp || 2); //Inherit from life form width LifeForm.call(this, hp, notNormalDeath);
    this.color = colorValue || color(red(-166344), green(-166344), blue(-166344), 150);
    this.damage = damage || 1.0;
    
    this.scoreValue = 200;

    this.addCast = function(self, arrayName)
    {
        gameObjects.getObject("cast").add(self.xPos + self.halfWidth, self.yPos + self.halfHeight, 3, arrayName, function(object)
        {
            if(object.physics === undefined)
            {
                return;
            }

            if(!gameObjects[gameObjects.references[object.name]])
            {
                self.hitObjectArrayName = object.arrayName;
            }else{
                self.hitObjectArrayName = object.name;   
            }

            self.castHitObject = object;
            if(object.type === "lifeform" && object.arrayName !== self.arrayName)
            {
                self.castHit = true;
            }
        },
        function(cast)
        {
            cast.xPos = self.xPos + self.halfWidth;  
            cast.yPos = self.yPos + self.halfHeight;
        }, false);
        self.cast = gameObjects.getObject("cast").getLast();
    };

    this.props = props || {
        charging : true,
        handleEdge : true,
    };
    
    this.trigHeight = this.halfHeight;
    this.origHeight = this.height;
    
    this.xDir = (random(0, 100) > 50) ? "left" : "right";
    this.yDir = "";
    
    this.task = "patrol";
    this.fromEnemy = true;
    
    this.maxXVel = 1;
    
    this.complexDraw = complexDraw;
    
    var self = this;
    this.controls = {
        left : function() 
        {
            return (self.xDir === "left" || self.keyLeft);
        },
        right : function() 
        {
            return (self.xDir === "right" || self.keyRight);
        },
        up : function() 
        {  
            return (self.yDir === "up" || self.keyUp);
        },
        down : function()
        {
            return (self.yDir === "down" || self.keyDown);
        },
    };
    
    this.handlePlayer = function(object, info)
    {
        //Can't get this logic right
        if(object.yPos < this.yPos + this.height &&
           object.xPos + object.width >= this.xPos + this.width * 0.1 && 
           object.xPos <= this.xPos + this.width * 0.9)
        {
            if(!this.lastHit)
            {
                //Damage enemy
                this.takeDamage(object, object.damage || 0.1);
                object.yVel = -(object.jumpHeight || 1) / 2;
            }
            this.lastHit = true;
        }else{
            //Damage player
            object.takeDamage(this);
            this.lastHit = false;
        }
    };
    this.handleEnemy = function(object, info)
    {
        if((info.side === "left" || info.side === "right") && 
        this.xDir === "left" && object.xDir === "right")
        {
            this.xDir = "right";
            this.xVel = 0;
            object.xDir = "left";
            object.xVel = 0;
        }
    };

    this.onHandleBlock = function(object, info) {};

    this.marginRight = 0;

    this.handleBlock = function(object, info)
    {
        if(this.onHandleBlock(object, info))
        {
            return;
        }

        if(info.side === "left" || info.side === "right")
        {
            this.xDir = info.side; //If this ran into a block, go the other way

            this.xVel = {"left" : this.xAcl, "right" : -this.xAcl}[this.xDir];
        }
        else if(info.side === "up")
        {
            if(this.block && this.marginRight <= this.block.xPos)
            {
                this.marginRight = this.block.xPos;
            }
            this.block = object;
        }
    };

    this.handleLeft = function()
    {
        this.xDir = "right";
    };
    this.handleRight = function()
    {
        this.xDir = "left";
    };

    this.onHandleEdges = function() {};

    this.addEdgeDetector = function()
    {
        var w = 5;
        this.detector = gameObjects.getObject("dynamicRect").add(this.xPos + this.halfWidth - w / 2, this.yPos + this.height, w, 2, color(0, 0, 0, 100));
        cameraGrid.addReference(this.detector);

        this.detector.physics.solidObject = false;
        this.detector.physics.movement = "dynamic";
        this.detector.onCollide = function(object)
        {
            if(object.type !== "lifeform" && object.arrayName !== self.arrayName && 
                object.arrayName !== "slope" && object.physics.solidObject)
            {               
                self.hasObjectBelow = true;
            }
        };

        this.detector.draw = function() {};
    };

    this.handleEdges = function()
    {
        if(!this.props.handleEdge)
        {
            return;
        }

        if(!this.hasObjectBelow && this.lastHasObjectBelow)
        {
            if(this.xDir === "left")
            {
                this.xDir = "right";
            }
            else if(this.xDir === "right")
            {
                this.xDir = "left";
            }
        }

        this.lastHasObjectBelow = this.hasObjectBelow;
        this.hasObjectBelow = false;

        if(!this.detector)
        {
            return this.addEdgeDetector();
        }

        this.detector.xPos = this.xPos + this.halfWidth - this.detector.halfWidth;
        this.detector.yPos = this.yPos + this.height;

        this.detector.updateBoundingBox();
        
        cameraGrid.removeReference(this.detector);
        cameraGrid.addReference(this.detector);

        gameObjects.applyCollision(this.detector);
    };
    this.handleBorders = function()
    {
        if(this.xPos <= levelInfo.xPos)
        {
            this.xDir = "right";
        }
        else if(this.xPos + this.width >= levelInfo.xPos + levelInfo.width)
        {
            this.xDir = "left";  
        }
    };
    this.chargeTimer = 0;
    this.chargeTime = 100;
    
    this.lastRemove = this.remove;
    this.remove = function()
    {
        if(this.cast !== undefined)
        {
            this.cast.remove();
        }

        if(this.detector !== undefined)
        {
            this.detector.remove();
        }

        this.lastRemove();
    };
          
    this.draw = function()
    {
        fill(this.color);
        $pjs.rect(this.xPos, this.yPos, this.width, this.height, 5);
    };   
    
    if(this.complexDraw)
    {
        this.eyeAngle = 180;
        this.hide = 0;
        this.hideVel = 1.5;
        this.eyes = 2;
        this.eyeSwitch = Math.round(random(1, 2));
        
        this.draw = function() 
        {
            noStroke();
            fill(this.color);
            $pjs.rect(this.xPos, this.yPos, this.width, this.height, 5);
            
            fill(255, 255, 255, 200);
            var _x = this.xPos + ((this.eyeSwitch === 1) ? this.width * 0.25 : this.width * 0.75);
            var _y = this.yPos + this.height * 0.3;
            var _radius = this.width * 0.15;
            var _diameter = _radius * 2;
            var _x2 = this.xPos + ((this.eyeSwitch === 1) ? this.width * 0.75 : this.width * 0.25);
            var _y2 = this.yPos + this.height * 0.7;
            if(this.eyes === 1 || this.eyes === 2)
            {
                circle(_x, _y, _diameter);
            }
            if(this.eyes === 2)
            {
                circle(_x2, _y2, _diameter);
            }
            
            // var player = gameObjects.getObject("player").getLast();
            if(player !== undefined)
            {
                this.eyeAngle = atan2(player.yPos - this.yPos, player.xPos - this.xPos);
            }else{
                this.eyeAngle = atan2((mouseY + cam.focusYPos - cam.halfHeight) - this.yPos, (mouseX + cam.focusXPos - cam.halfWidth) - this.xPos);
            }
            var x = cos(this.eyeAngle) * this.width * 0.1;
            var y = sin(this.eyeAngle) * this.width * 0.1;
            fill(0, 0, 0, 200);
            if(this.eyes === 1 || this.eyes === 2)
            {
                circle(_x + x, _y + y, _radius);
            }
            if(this.eyes === 2)
            {
                circle(_x2 + x, _y2 + y, _radius);
            }
            
            fill(red(this.color), green(this.color), blue(this.color), this.hide);
            $pjs.rect(this.xPos, this.yPos, this.width, this.height, 5);
            
            if(this.hide < 0 || this.hide > (this.maxHide || 255))
            {
                this.hideVel = -this.hideVel; 
                if(this.hide > (this.maxHide || 255))
                {
                    this.eyes--;
                    if(this.eyes <= 0)
                    {
                        this.eyeSwitch++;
                        if(this.eyeSwitch > 2)
                        {
                            this.eyeSwitch = 1;
                        }
                        this.eyes = 2;  
                    }
                }
            }
            this.hide += this.hideVel;
        };
    }    
    
    this.lastUpdate = this.update;
    this.simpleUpdate = function()
    {
        if(!this.noHeightChanges)
        {
            this.height = max((this.origHeight - this.trigHeight) + (this.hp * this.trigHeight / this.maxHp), 0);
            this.boundingBox.height = this.height;
            this.halfHeight = this.height / 2;
        }

        this.lastUpdate();
    };

    this.update = function()
    {
        this.handleEdges();
        this.handleBorders();

        if(!this.preventDefaultAI)
        {
            if(this.hitObjectArrayName === "player" && this.task !== "kill")
            {
                this.task = "charge";
                this.chargeTimer = this.chargeTime;
            }

            if(this.task === "charge")
            {
                this.chargeTimer--;
                if(this.chargeTimer < 0)
                {
                    this.task = "patrol";
                }
            }

            if(this.fastSpeed)
            {
                this.maxXVel = this.fastSpeed;
            }else{
                switch(this.task)
                {
                    case "patrol" :
                        this.maxXVel = 1;
                        break;

                    case "kill" :
                        this.maxXVel = 2;
                        break;

                    case "charge" :
                        this.maxXVel = 3;
                        break;
                }
            }
        }

        if(this.cast !== undefined)
        {
            var speed = this.maxXVel + 10;
            this.cast.xVel = (this.xDir === "left") ? -speed : speed;
            if(!this.cast.signal())
            {
                this.cast.setPos(this.cast);
                cameraGrid.addReference(this.cast);
            }
        }

        this.hitObjectArrayName = undefined;

        this.lastHit = false;
        this.castHit = false;

        this.simpleUpdate();
    };
    
    this.onCollide = function(object, info)
    {
        switch(true)
        {
            case (object.arrayName === "player") :
                this.handlePlayer(object, info);

                if(player.slowMe && !this.noHeightChanges)
                {
                    this.height = max((this.origHeight - this.trigHeight) + (this.hp * this.trigHeight / this.maxHp), 0);
                    this.boundingBox.height = this.height;
                    this.halfHeight = this.height / 2;
                }
                break;
                
            case (object.type === "block" && object.arrayName !== "snowLayer") :
                this.handleBlock(object, info);
                break;
                
            case (object.arrayName === "slope") :
                break;
            
            case (this.arrayName === object.arrayName || object.fromEnemy) :
                this.handleEnemy(object, info);
                break;
        }

    };
};
gameObjects.addObject("enemy", createArray(Enemy));

var FireBeaker = function(xPos, yPos, width, height, colorValue)
{
    Enemy.call(this, xPos, yPos, width, height, colorValue || color(166, 110, 49), {
        handleEdge : true,
    }, true);

    this.scoreValue = 250;

    this.damage = 1;

    if(levelInfo.theme === "surface")
    {
        this.scoreValue = 2000;
        this.damage = 4;
    }

    this.particles = [];
    this.particleColor = this.color;

    this.addParticle = function()
    {
        this.particles.push({
            color : this.particleColor,
            xPos : this.xPos + floor(random(0, this.width)),
            yPos : this.yPos + floor(random(0, this.height)),
            yVel : -random(0.5, 2.2)/2,
            xVel : this.xVel * -round(random(1.5, 3))/2.3,
            diameter : 7,
            shrink : 0.1,
            life : 100,
            maxLife : 100,
        });
    };
    this.updateParticles = function()
    {
        for(var i = 0; i < this.particles.length; i++)
        {
            var p = this.particles[i];

            p.xPos += p.xVel;
            p.yPos += p.yVel;
            p.life--;
            p.diameter -= p.shrink;

            if(p.life < 0 || p.diameter < 0)
            {
                this.particles.splice(i, 1);
            }
        }
    };
    this.drawParticles = function()
    {
        for(var i = 0; i < this.particles.length; i++)
        {
            var p = this.particles[i];

            fill(red(p.color), green(p.color), blue(p.color), 255 * p.life / p.maxLife);
            circle(p.xPos, p.yPos, p.diameter, p.diameter);
        }
    };

    this.lastDrawB = this.draw;
    this.draw = function()
    {
        this.drawParticles();
        this.lastDrawB();
    };

    this.lastUpdateB = this.update;
    this.update = function()
    {
        this.lastUpdateB();

        if(millis() % 15 >= 10)
        {
            this.addParticle();
        }

        this.updateParticles();
    };

    this.lavaImmune = true;
    this.lastOnCollide = this.onCollide;
    this.onCollide = function(object, info)
    {
        if(object.arrayName === "water")
        {
            this.hp -= object.damage * 0.23;
        }
        this.lastOnCollide(object, info);
    };

    var _lastRemove = this.remove;
    this.remove = function()
    {
        if(!this.addedDrops)
        {
            for(var i = 2; i > 0; i--)
            {
                var object = gameObjects.getObject(Math.random() < 0.5 ? "coin" : "hpCoin").add(
                this.xPos + this.halfWidth + random(-20, 20), this.yPos + this.halfHeight + random(-20, 20), levelInfo.unitWidth / 2);
                object.doNotSave = true;
                cameraGrid.addReference(object);
            }

            this.addedDrops = true;
        }

        return _lastRemove.apply(this, arguments);
    };
};
gameObjects.addObject("fireBeaker", createArray(FireBeaker));

var LavaBeaker = function(xPos, yPos, width, height, colorValue)
{
    Enemy.call(this, xPos, yPos, width, height, colorValue || color(211, 33, 0, 200), {
        handleEdge : true,
        charging : true
    }, true, 6);

    this.addCast(this, "lavaBeaker");

    this.scoreValue = 1000;

    this.damage = 2;

    this.particles = [];
    this.particleColor = this.color;

    this.addParticle = function()
    {
        this.particles.push({
            color : this.particleColor,
            xPos : this.xPos + floor(random(0, this.width)),
            yPos : this.yPos + floor(random(0, this.height)),
            yVel : -random(0.5, 2.2)/2,
            xVel : this.xVel * -round(random(1.5, 3))/2.3,
            diameter : 7,
            shrink : 0.1,
            life : 100,
            maxLife : 100,
        });
    };
    this.updateParticles = function()
    {
        for(var i = 0; i < this.particles.length; i++)
        {
            var p = this.particles[i];

            p.xPos += p.xVel;
            p.yPos += p.yVel;
            p.life--;
            p.diameter -= p.shrink;

            if(p.life < 0 || p.diameter < 0)
            {
                this.particles.splice(i, 1);
            }
        }
    };
    this.drawParticles = function()
    {
        for(var i = 0; i < this.particles.length; i++)
        {
            var p = this.particles[i];

            fill(red(p.color), green(p.color), blue(p.color), 255 * p.life / p.maxLife);
            circle(p.xPos, p.yPos, p.diameter, p.diameter);
        }
    };

    this.lastDrawB = this.draw;
    this.draw = function()
    {
        this.drawParticles();
        this.lastDrawB();
    };

    this.lastUpdateB = this.update;
    this.update = function()
    {
        this.lastUpdateB();

        if(millis() % 15 >= 10)
        {
            this.addParticle();
        }

        this.updateParticles();
    };

    this.lavaImmune = true;
    this.lastOnCollide = this.onCollide;
    this.onCollide = function(object, info)
    {
        if(object.redHurtTime <= 0 && object.arrayName === "player" && (info.side === "left" || info.side === "right"))
        {
            object.redHurtTime = object.maxRedHurtTime;
        }

        this.lastOnCollide(object, info);
    };
};
gameObjects.addObject("lavaBeaker", createArray(LavaBeaker));

var WaterBeaker = function(xPos, yPos, width, height, colorValue)
{
    Enemy.call(this, xPos, yPos, width, height, colorValue || color(56, 137, 161), {
        charging : true,
    }, true);    
    this.addCast(this, "waterBeaker");
    this.lastGravity = this.gravity;
    this.lastUpdate1 = this.update;

    this.damage = 1;

    this.update = function()
    {
        this.gravity = (this.inLiquid) ? 0 : this.lastGravity;
        this.lastUpdate1();
    };

    var _lastRemove = this.remove;
    this.remove = function()
    {
        if(!this.addedDrops)
        {
            for(var i = 2; i > 0; i--)
            {
                var object = gameObjects.getObject(Math.random() < 0.5 ? "coin" : "hpCoin").add(
                this.xPos + this.halfWidth + random(-20, 20), this.yPos + this.halfHeight + random(-20, 20), levelInfo.unitWidth / 2);
                object.doNotSave = true;
                cameraGrid.addReference(object);
            }

            this.addedDrops = true;
        }

        return _lastRemove.apply(this, arguments);
    };
};
gameObjects.addObject("waterBeaker", createArray(WaterBeaker));

var SlimeBeaker = function(xPos, yPos, width, height, colorValue)
{
    Enemy.call(this, xPos, yPos, width, height, colorValue || color(0, 123, 61), {
        charging : true,
        handleEdge : true
    }, true);    
    this.addCast(this, "slimeBeaker");
    this.lastGravity = this.gravity;
    this.lastUpdate1 = this.update;

    this.damage = 3;

    this.update = function()
    {
        this.gravity = (this.inLiquid) ? 0 : this.lastGravity;
        this.lastUpdate1();
    };

    var _lastRemove = this.remove;
    this.remove = function()
    {
        if(!this.addedDrops)
        {
            for(var i = 2; i > 0; i--)
            {
                var hpCoin = gameObjects.getObject("hpCoin").add(
                this.xPos + this.halfWidth + random(-20, 20), this.yPos + this.halfHeight + random(-20, 20), levelInfo.unitWidth / 2);
                hpCoin.doNotSave = true;
                cameraGrid.addReference(hpCoin);
            }

            this.addedDrops = true;
        }

        return _lastRemove.apply(this, arguments);
    };
};
gameObjects.addObject("slimeBeaker", createArray(SlimeBeaker));

var PoisonousSlimeBeaker = function(xPos, yPos, width, height, colorValue)
{
    SlimeBeaker.call(this, xPos, yPos, width, height, colorValue || color(0, 163, 61));

    this.addedDrops = true;
    this.fastSpeed = 2.5;

    var _lastOnCollide = this.onCollide;

    this.onCollide = function(object, info)
    {
        if(info.side !== "up" && object.arrayName === "player")
        {
            object.gooedTimer = 60 * 7;
        }
        return _lastOnCollide.apply(this, arguments);
    };
};

gameObjects.addObject("poisonousSlimeBeaker", createArray(PoisonousSlimeBeaker));

var IceBeaker = function(xPos, yPos, width, height, colorValue)
{
    Enemy.call(this, xPos, yPos, width, height, colorValue || color(56, 187, 181, 160), {
        charging : true,
        handleEdge : true,
    }, true, 4);    
    this.addCast(this, "iceBeaker");
    this.lastGravity = this.gravity;
    this.lastUpdate1 = this.update;

    this.scoreValue = 400;

    this.damage = 2;

    this.angle = 0;
    this.angleVel = 2;

    this.maxHide = 230;
    this.hideVel = 1;

    this.kArray = [];

    for(var i = 0; i < 4; i++)
    {
        this.kArray.push([round(random(-5, 5)), Math.round(random(-5, 5))]);
    }

    this.update = function()
    {
        this.gravity = (this.inLiquid) ? 0 : this.lastGravity;
        this.lastUpdate1();

        if(millis() % 1000 >= 890)
        {
            for(var i = 0; i < 4; i++)
            {
                this.kArray[i] = [round(random(-5, 5)), Math.round(random(-5, 5))];
            }
        }
    };

    this.custHeight = this.height * 0.1;
    this.custWidth = this.height * 0.1;

    this.lastDraw = this.draw;
    this.draw = function()
    {
        noStroke();
        fill(23, 140, 187); 

        physics.getMiddleXPos(this);
        physics.getMiddleYPos(this);

        this.angle += this.angleVel;

        for(i = 0; i < 4; i++)
        {
            $pjs.pushMatrix();
                translate(this.middleXPos, this.middleYPos);
                rotate(this.angle);
                ellipse(0, 0, this.halfWidth - this.kArray[i][0], this.halfHeight - this.kArray[i][1]);
            $pjs.popMatrix();
        }

        this.lastDraw();

        fill(240, 240, 240, 200);
        $pjs.rect(this.xPos, this.yPos + this.height - this.custHeight, this.width, this.custHeight, 5);
    };

    this._lastOnCollide1 = this.onCollide;
    this.onCollide = function(object, info)
    {
        this._lastOnCollide1(object, info);
        if(object.arrayName === "water")
        {
            object.temp -= 1.5;
            object.freezing = true;
        }
        else if(typeof object.snowflakes !== "undefined" && object.physics.shape === "rect" && 
            this.yPos + this.height <= object.yPos + 1 && !object.snowLayered)
        {
            object._lastDraw = object.draw;
            object.draw = function()
            {
                this._lastDraw();
                noStroke();
                fill(250, 250, 250, 215);
                fastRect(this.xPos, this.yPos, this.width, this.height * 0.15);
            };

            object.snowLayered = true;
            return;
        }
    };

    var _lastRemove = this.remove;
    this.remove = function()
    {
        if(!this.addedDrops)
        {
            for(var i = 2; i > 0; i--)
            {
                var object = gameObjects.getObject(Math.random() < 0.5 ? "coin" : "hpCoin").add(
                this.xPos + this.halfWidth + random(-20, 20), this.yPos + this.halfHeight + random(-20, 20), levelInfo.unitWidth / 2);
                object.doNotSave = true;
                cameraGrid.addReference(object);
            }

            this.addedDrops = true;
        }

        return _lastRemove.apply(this, arguments);
    };
};
gameObjects.addObject("iceBeaker", createArray(IceBeaker));

var SkyViper = function(xPos, yPos, width, height, colorValue)
{
    Enemy.call(this, xPos, yPos, width, height, colorValue || color(30, 67, 117), {
        charging : true,
    }, false, 4);
    this.addCast(this, "skyViper");
    this.lastGravity = this.gravity;
    this.gravity = 0;

    this.damage = 2;
    this.scoreValue = 500;

    this.turnTimer = 0;
    this.turnTime = 100;

    this.imageTimer = 0;
    this.addOn = "";
    this.draw = function()
    {
        this.imageName = this.arrayName;
        this.imageTimer++;
        if(this.imageTimer >= 40)
        {
            this.addOn = (this.addOn === "2") ? "" : "2";
            this.imageTimer = 0;
        }
        if(this.xDir === "right")
        {
            this.imageName = this.arrayName + this.addOn;
        }
        else if(this.xDir === "left")
        {
            this.imageName = this.arrayName + "Left" + this.addOn;
        }
        image(storedImages[this.imageName], this.xPos, this.yPos);
    };

    this.lastUpdate1 = this.update;
    this.flying = true;
    this.yFlySpeed = 2;
    this.killTimer = 0;
    this.killTime = 300;
    this.noHeightChanges = true;

    this.update = function()
    {
        if(this.yDir === "")
        {
            this.yVel = 0;
        }
        if(this.xDir === "right")
        {
            this.turnTimer++;
        }
        else if(this.xDir === "left")
        {
            this.turnTimer--;
        }

        if(this.task === "patrol")
        {
            if(this.turnTimer > this.turnTime)
            {
                this.xDir = "left";
            }
            else if(this.turnTimer < -this.turnTime)
            {
                this.xDir = "right";
            }
            if(this.yPos <= yPos - 300)
            {
                this.yDir = "down";
            }else{
                this.yDir = "";
            }
        }

        if(this.task === "kill" && (this.killObject === undefined || !this.killObject.invincibleToLifeForm))
        {
            this.killTimer++;
            if(this.killTimer > this.killTime)
            {
                this.task = "patrol";
                this.killTimer = 0;
                this.yDir = "";
            }
            if(this.killObject !== undefined)
            {
                switch(true)
                {
                    case (this.killObject.boundingBox.xPos + this.killObject.boundingBox.width <= this.xPos) :
                        this.xDir = "left";
                        break;

                    case (this.killObject.boundingBox.xPos >= this.xPos + this.width) :
                        this.xDir = "right";
                        break;
                }
                switch(true)
                {
                    case (this.killObject.boundingBox.yPos + this.killObject.boundingBox.height <= this.yPos) :
                        if(this.killObject.boundingBox.xPos + this.killObject.boundingBox.width <= this.xPos ||
                           this.killObject.boundingBox.xPos >= this.xPos + this.width)
                        {
                            this.yDir = "up";
                        }
                        break;

                    case (this.killObject.boundingBox.yPos >= this.yPos + this.height) :
                        this.yDir = "down";
                        break;
                }
            }
        }

        if(this.killObject !== undefined && this.killObject.invincibleToLifeForm && this.yDir === "up")
        {
            this.yDir = "";
        }

        this.lastUpdate1();
    };

    this.lastOnCollide = this.onCollide;
    this.onCollide = function(object, info)
    {
        this.lastOnCollide(object, info);
        if(object.arrayName === "player")
        {
            this.killObject = object;
            this.task = "kill";

            if(object.yPos + object.height * 0.7 > this.yPos)
            {
                if(object.xPos < this.xPos)
                {
                    object.xVel = -abs(this.xVel) - 5;
                }else{
                    object.xVel = abs(this.xVel) + 5;
                }

                object.maxXVel = 10;
            }
            else if(object.yVel > 0)
            {
                object.yVel = Math.min(object.yVel, -6);
            }
        }
    };
};
gameObjects.addObject("skyViper", createArray(SkyViper));

var DirtyCat = function(xPos, yPos, width, height)
{
    this.imageName = "dirtyCat";

    var of = storedImages[this.imageName].height / 3;
    height -= of;

    Enemy.call(this, xPos, yPos, width, height, color(0, 0, 0, 0), {
        charging : true,
    }, false, 10);
    this.addCast(this, "dirtyCat");

    this.scoreValue = 600;

    this.damage = 2.5;

    this.lastChangeTime = millis();

    this.draw = function()
    {
        $pjs.pushMatrix();
        translate(this.xPos, this.yPos - of);

        if(this.controls.right() && !this.controls.left())
        {
            translate(this.width, 0.0);
            scale(-1.0, 1.0);
        }

        if(this.task === "charging")
        {
            if(millis() - this.lastChangeTime > 150)
            {
                this.imageName = (this.imageName === "dirtyCat") ? "dirtyCat2" : "dirtyCat";
                this.lastChangeTime = millis();
            }
        }else{
             if(millis() - this.lastChangeTime > 300)
            {
                this.imageName = (this.imageName === "dirtyCat") ? "dirtyCat2" : "dirtyCat";
                this.lastChangeTime = millis();
            }
        }

        image(storedImages[this.imageName], 0, 0, this.width, this.height + of);
        $pjs.popMatrix();
    };

    this.lastJumpTime = millis();

    var _lastUpdate = this.update;
    this.update = function()
    {
        _lastUpdate.apply(this, arguments);
        this.yDir = "";

        if(Math.random() <= 0.005 && millis() - this.lastJumpTime >= 2334)
        {
            this.yDir = "up";

            this.lastJumpTime = millis();
        }
    };

    var _lastAvoidCollision

    var _lastOnCollide = this.onCollide;
    this.onCollide = function(object, info)
    {
        this.hitDirtyBlock = false;

        if(object.arrayName === "ice" && object.freezing)
        {
            return;
        }

        if(object.arrayName === "dirtyBlock")
        {
            this.yVel = min(-2, this.yVel);

            this.hitDirtyBlock = true;
        }
        
        if((this.task === "charge" || this.hitDirtyBlock) && info && (info.side === "left" || info.side === "right") && this._side !== "down")
        {
            return this.yDir = "up";
        }

        _lastOnCollide.apply(this, arguments);
    };
};
gameObjects.addObject("dirtyCat", createArray(DirtyCat));

var CatDogStatue = function(xPos, yPos, width, height)
{
    DynamicRect.call(this, xPos, yPos, width, height);
    this.likeLifeForm = true;
    this.scoreValue = 800;

    this.physics.sides = {};

    this.physics.movement = "dynamic";
    
    var offSet = (Math.random() < 0.5 ? -3 : 3);

    this.laser = {
        xPos : this.xPos + this.halfWidth + offSet,
        yPos : this.yPos + this.height * 0.2,
        xPos2 : this.xPos + this.halfWidth,
        yPos2 : this.yPos + this.height,

        length : 0,
        lengthVel : 0,
        active : false,

        damage : 1,
        lastDamageTime : 0,
        damageInterval : 250,
    };

    var self = this;

    this.hp = 16;
    this.maxHp = 16;
    this.defense = 0.5;

    this.autoHp = 0.005;
    this.lastAutoHpTime = 0;
    this.autoHpTimeInterval = 200;

    this.useLaser = true;

    this.laser.draw = function(xPos2, yPos2)
    {
        if(!this.active)
        {
            return;
        }

        this.xPos = self.xPos + self.halfWidth + offSet;
        this.yPos = self.yPos + self.height * 0.2;
        this.xPos2 = xPos2 ? xPos2 : self.xPos + self.halfWidth;
        this.yPos2 = yPos2 ? yPos2 : self.yPos + self.height;

        this.length += this.lengthVel;
        this.length = constrain(this.length, 0, 1);

        if(this.length <= 0 && this.active)
        {
            this.active = false;
        }

        var xDiff = this.xPos2 - this.xPos;
        var yDiff = this.yPos2 - this.yPos;

        var l = dist(0, 0, abs(xDiff), abs(yDiff)) * this.length;
        var a = atan2(xDiff, yDiff);

        strokeWeight(1.2);
        stroke(41, 47, 200, 189);
        line(this.xPos, this.yPos, this.xPos + sin(a) * l, this.yPos + cos(a) * l);
        noStroke();
    };

    this.laser.colliding = function(object)
    {
        if(!this.active)
        {
            return false;
        }

        if(object.xPos > max(this.xPos, this.xPos2) || 
           object.xPos + object.width < min(this.xPos, this.xPos2) || 
           object.yPos > max(this.yPos, this.yPos2) || 
           object.yPos + object.height < min(this.yPos, this.yPos2))
        {
            return false;
        }

        var xDiff = this.xPos2 - this.xPos;
        var yDiff = this.yPos2 - this.yPos;

        var hyp = dist(0, 0, abs(xDiff), abs(yDiff));
        var a = atan2(xDiff, yDiff);

        for(var i = 0; i < hyp * this.length; i += 4)
        {
            if(observer.collisionTypes.pointrect.colliding({
                xPos : this.xPos + sin(a) * i,
                yPos : this.yPos + cos(a) * i
            }, object))
            {
                return true;
            }
        }

        return false;
    };

    var spys = [];
    spys.add = function(xPos, yPos, width, height, color, other)
    {
        var toSet = {
            xPos : xPos, 
            yPos : yPos, 
            width : width, 
            height : height, 
            color : color,

            maxLife : 100,
            life : 100,

            angle : random(0, TWO_PI),
            angleVel : random(-0.1, 0.1),
            speed : random(1, 2),
        };

        if(other)
        {
            for(var i in other)
            {
                toSet[i] = other[i];
            }
        }

        this.push(toSet);
    };
    spys.draw = function()
    {   
        noStroke();

        for(var i = this.length - 1; i >= 0; i--)
        {
            var spy = this[i];

            spy.angle += spy.angleVel;
            spy.xPos += cos(spy.angle) * spy.speed;
            spy.yPos += sin(spy.angle) * spy.speed;

            fill(red(spy.color), green(spy.color), blue(spy.color), spy.life * alpha(spy.color) / spy.maxLife);
            fastRect(spy.xPos, spy.yPos, spy.width, spy.height);

            spy.life--;

            if(spy.life < 0)
            {
                this.splice(i, 1);
            }
        }
    };

    this.drawEffect = function()
    {
        if(!spys.started)
        {
            for(var i = 0; i < random(1, 6) * 10; i++)
            {
                spys.add(this.xPos + Math.random() * this.width, 
                         this.yPos + Math.random() * this.height, 
                         random(3, 6), random(3, 6), color(random(0, 200), 50, random(0, 200), 200)); 
            }

            spys.started = true;
        }

        spys.draw();

        if(spys.length <= 0)
        {
            this.feelingSaucy = false;
            spys.started = false;
        }
    };

    var hpBarYDiv = this.halfWidth * 0.5;
    this.hpBar = new Bar(this.xPos, this.yPos - hpBarYDiv, this.width, 4, color(34, 176, 111, 200), 3); 

    this.draw = function()
    {
        image(loadedImages[this.arrayName], this.xPos + 3, this.yPos, loadedImages[this.arrayName].width * 0.5, loadedImages[this.arrayName].height * 0.5);

        if(this.feelingSaucy)
        {
            this.drawEffect();
        }

        this.hpBar.xPos = this.xPos;
        this.hpBar.yPos = this.yPos - hpBarYDiv;

        this.laser.draw(this.laser.xPos2, this.yPos + this.height);

        if(this.hp < this.maxHp)
        {
            if(this.hp <= this.maxHp * 0.4)
            {
                this.hpBar.color = color(190, 34, 51, 130);
            }

            this.hpBar.set(max(this.hp, 0), this.maxHp);
            this.hpBar.draw();
        }
    };

    this.activate = function()
    {
        this.laser.active = true;
        this.laser.lengthVel = 0.05;
        this.feelingSaucy = true;

        sounds.mplaySound("lasered.mp3");
    };

    this.deactivate = function()
    {
        this.laser.lengthVel = -0.05;
    };

    var _lastUpdate = this.update;
    this.update = function()
    {
        if(millis() - this.lastAutoHpTime > this.autoHpTimeInterval)
        {
            this.hp += this.autoHp;
            this.hp = min(this.hp, this.maxHp);

            this.lastAutoHpTime = millis();
        }

        if(!observer.boundingBoxesColliding(this.boundingBox, cam.boundingBox))
        {
            if(!this.pickedVel)
            {
                this.pickVel = random(-2, 2);
                this.pickedVel = true;
            }

            this.feelingSaucy = true;
        }else{
            this.pickedVel = false;
        }

        if(this.useLaser)
        {
            if(Math.pow(Math.abs(physics.getMiddleXPos(player) - physics.getMiddleXPos(this)), 2) + 
               Math.pow(Math.abs(physics.getMiddleYPos(player) - physics.getMiddleYPos(this)), 2) < 150 * 150)
            {
                if(!this.laser.active)
                {
                    this.activate();
                }
            }
            else if(this.laser.active)
            {
                this.deactivate();
            }
        }

        if(this.laser.active)
        {
            if(this.laser.xPos2 < player.middleXPos)
            {
                this.laser.xPos2 += 2.5;
            }else{
                this.laser.xPos2 -= 2.5;
            }

            this.laser.xPos2 = constrain(this.laser.xPos2, this.middleXPos - this.width * 3, this.middleXPos + this.width * 3);
        }

        if(millis() - this.laser.lastDamageTime > this.laser.damageInterval && this.laser.colliding(player))
        {
            player.takeDamage(this, this.laser.damage);

            this.laser.lastDamageTime = millis();
        }

        if(this.hp <= 0)
        {
            this.dead = true;
            this.remove();
        }

        return _lastUpdate.apply(this, arguments);
    };

    this.avoidCollision = function(object)
    {
        if(!(object.arrayName !== "player" || object.yPos + object.height - object.yVel > this.yPos))
        {
            this.jumpedOn = true;
        }

        return object.physics.movement === "dynamic" && !this.jumpedOn;
    };

    this.takeDamage = function(amt)
    {
        this.hp -= Math.max(0, amt - this.defense);
    };

    this.onCollide = function(object, info)
    {
        if(this.jumpedOn || object.arrayName === "xStar")
        {
            if(!this.jumpedOn)
            {
                this.takeDamage(object.damage ? object.damage : 0);
                object.draw = function() {};
                object.onCollide = function() {};
                object.remove(this);
            }else{
                object.yVel = abs(object.yVel);
            }

            this.useLaser = true;
            this.jumpedOn = false;
        }
    };
};
gameObjects.addObject("catDogStatue", createArray(CatDogStatue));

var SonicBoomer = function(xPos, yPos, diameter, colorValue)
{
    DynamicCircle.call(this, xPos, yPos, diameter)
    this.physics.solidObject = false;

    this.gravity = 0;

    this.color = colorValue || color(152, 0, 30, 120);

    this.booming = false;
    this.boomCounter = 0;

    this.explosion = {
        diameter : 0,
        diameter2 : 0,
    };

    var sz = 0.6;

    var self = this;

    this.darkThings = [];
    this.darkThings.add = function(xPos, yPos, diameter, xVel, yVel)
    {
        this.push({
            xPos : xPos,
            yPos : yPos,
            diameter : diameter,
            xVel : xVel,
            yVel : yVel
        });
    };
    this.darkThings.draw = function()
    {
        for(var i = this.length - 1; i >= 0; i--)
        {
            var darkThing = this[i];

            fill(0, 0, 0, 30);
            circle(darkThing.xPos, darkThing.yPos, darkThing.diameter);

            darkThing.xPos += darkThing.xVel;
            darkThing.yPos += darkThing.yVel;
        }
    };

    this.draw = function()
    {
        noStroke();

        if(!this.booming)
        {
            fill(this.color);
            circle(this.xPos, this.yPos, this.diameter);
            return;
        }

        fill(this.color);
        circle(this.xPos, this.yPos, this.diameter * 0.4);

        fill(132, 4, 100, 120);
        circle(xPos, yPos, this.explosion.diameter);

        fill(132, 4, 100, 120);
        circle(xPos, yPos, this.explosion.diameter * 1.2);

        this.explosion.diameter += 45 * sz;

        if(this.explosion.diameter > 1200 * sz)
        {
            this.explosion.diameter = -Infinity;
        }

        fill(50, 4, 200, 123);
        circle(xPos, yPos, this.explosion.diameter2);

        this.explosion.diameter2 += 20 * sz;

        if(this.explosion.diameter2 > 1200 * sz)
        {
            this.explosion.diameter2 = -Infinity;
        }

        this.diameter = this.explosion.diameter2 / 4;
        this.radius = this.diameter / 2;

        this.darkThings.draw();
    };

    this.startBoom = function(object)
    {
        screenUtils.newShakeScreen(600, 7, 7);

        this.boomCounter = 30;
        sounds.mplaySound("whoo.wav");
        sounds.mplaySound("explosion.mp3");

        this.gravity = 4;
        this.hitObject = object;

        this.yVel = -10;

        this.booming = true;

        this.diameter = 60;

        var a, i;
        for(i = 0; i < 120; i++)
        {
            a = radians(random(0, 360));
            this.darkThings.add(this.xPos, this.yPos, random(2, 7), cos(a) * random(4, 5) * 4, sin(a) * random(4, 5) * 4);
        }
    };

    var lastUpdate = this.update;
    this.update = function()
    {
        this.boomCounter--;

        if(this.booming && this.boomCounter <= 14)
        {
            var exploder = gameObjects.getObject("dynamicCircle").add(xPos, yPos, this.diameter * 2.2);
            cameraGrid.addReference(exploder);
            exploder.draw = function() {};
            exploder.physics.solidObject = false;
            exploder.update = function() {};
            exploder.onCollide = function(object)
            {
                if(object.physics.movement === "static" && object.physics.shape === "rect" && object.arrayName !== "dynamicCircle")
                {
                    if(!object.notExplosive)
                    {
                        object.remove();
                        return;
                    }
                }
            };
        }

        if(this.hitObject && this.boomCounter < 0)
        {
            this.booming = false;

            var flypis = gameObjects.getObject("flypi");
            for(var i = 0; i < 56; i++)
            {
                cameraGrid.addReference(flypis.add(xPos, yPos, Math.round(random(4, 8)), color(0, 0, 200, 100)));
            }

            this.onCollide = function() {};
            this.draw = function() {};
            this.remove();

            this.update = function() {};
        }

        return lastUpdate.apply(this, arguments);
    };

    this.damage = 5;

    this.onCollide = function(object)
    {
        if(object.arrayName === "snow" || object.arrayName === "rain")
        {
            return;
        }

        if(object.arrayName === this.arrayName)
        {
            object.hitObject = this.hitObject;
        }

        if(object.physics.movement === "static" && object.physics.shape === "rect")
        {
            if(!object.notExplosive)
            {
                object.remove();
                return;
            }
        }

        if(object.physics.movement === "dynamic")
        {
            if(!this.exploding)
            {
                if(object.hp)
                {
                    object.hp -= this.damage;
                    var angle = atan2(object.xVel, object.yVel);
                    object.yVel = -sin(angle) * 30 || object.yVel;
                    object.xVel = -cos(angle) * 30 || object.xVel;
                }

                this.startBoom(object);

                this.exploding = true;
            }
        }
    };
};
gameObjects.addObject("sonicBoomer", createArray(SonicBoomer));

//Ninja Star, specific to the Ninja.
var NinjaStar = function(xPos, yPos, diameter, colorValue)
{
    Circle.call(this, xPos, yPos, diameter);
    this.colorValue = colorValue;
    this.physics.movement = "dynamic";
    this.physics.solidObject = false;
    this.outerXVel = 0;
    this.outerYVel = 0;

    this.damage = 1.5;

    this.life = random(150, 400);

    this.blocked = false;

    this.imageName = "ninjaStar";
    this.setAngle = 0;
    this.draw = function()
    {
        $pjs.pushMatrix();
        translate(this.xPos, this.yPos);
        rotate(this.setAngle);
        image(storedImages[this.imageName], -this.radius, -this.radius, this.diameter, this.diameter);
        $pjs.popMatrix();
        this.setAngle += 3;

        //It's been gooed by the player's shield.
        if(this.blockedByPlayer)
        {
            noStroke();
            fill(31, 89, 235, 170);
            circle(this.xPos, this.yPos, this.radius * 1.2);
        }
    };

    this.updateBoundingBox = function()
    {
        this.boundingBox.xPos = this.xPos - this.radius;
        this.boundingBox.yPos = this.yPos - this.radius;
    };

    this.lastUpdate1 = this.update;
    this.update = function()
    {
        this.lastUpdate1();
        this.xPos += this.outerXVel2;
        this.yPos += this.outerYVel2;  

        this.updateBoundingBox();   
        this.life--;
        if(this.life < 0)
        {
            this.remove();
        }       
    };

    this.hits = 0;
    this.onCollide = function(object)
    {
        var ignorePlayerDamage = this.blockedByPlayer;

        if((object.arrayName === "player" && !ignorePlayerDamage) || (this.blocked && (object.arrayName === "ninja" || object.arrayName === "ninjaBoss")))
        {
            var blocked = object.takeDamage(this);
            if(!blocked)
            {
                this.onCollide = function(){};
                this.remove();
            }else{
                var d = Math.sqrt(Math.pow(this.outerYVel2, 2) + Math.pow(this.outerXVel2, 2));
                var a = atan2(this.outerYVel2, 
                              this.outerXVel2);

                a += PI;
                d *= 1.1;

                this.outerXVel2 = cos(a) * d;
                this.outerYVel2 = sin(a) * d;

                if(object.arrayName === "player")
                {
                    this.blockedByPlayer = true;
                    this.life += 200;
                    this.damage = 2;
                }
            }

            this.blocked = blocked;
        }
        if(object.physics.solidObject && object.arrayName !== this.arrayName && !object.isBoss &&
        object.arrayName !== "ninja" && object.arrayName !== "fallingBlock" &&
        object.arrayName !== "movingPlatform" && object.arrayName !== "pillar")
        {
            this.hits++;
            if(this.hits >= 3)
            {
                this.remove();
                this.onCollide = function(){};
            }
        }
    };
};
gameObjects.addObject("ninjaStar", createArray(NinjaStar));

var Slasher = function(xPos, yPos, width, height)
{
    DynamicRect.call(this, xPos, yPos, width, height);
    LifeForm.call(this, 10);
    this.damage = 1;
    this.lavaImmune = true;

    this.boundingBox.overSized = true;
    this.updateVel = function() {};
    this.gravity = 0;

    this.draw = function()
    {
        image(loadedImages["slasher"], this.xPos, this.yPos, this.width, this.height);
    };

    this.axis = Math.random() < 0.5 ? "x" : "y";

    this.moveSpeedX = 3.4;
    this.moveSpeedY = 3.4;

    this.maxLeaveX = 600;
    this.maxLeaveY = 600;

    var preXPos = this.xPos, preYPos = this.yPos;
    var postXPos = this.xPos, postYPos = this.yPos;

    var _lastUpdate = this.update;
    this.update = function()
    {
        this.xVel = 0;
        this.yVel = 0;

        _lastUpdate.apply(this, arguments);

        if(this.axis === "x")
        {
            // Move
            this.xPos += this.moveSpeedX;
            this.yPos = preYPos;
            preXPos = this.xPos;

            // Turn around if we are too far away
            if(Math.abs(postXPos - this.xPos) > this.maxLeaveX)
            {
                this.moveSpeedX = -this.moveSpeedX;
            }

            // Set boundingBox to make this object always update...
            this.boundingBox.xPos = this.xPos - 200;
            this.boundingBox.width = 400;
            this.boundingBox.yPos = this.yPos;
            this.boundingBox.height = this.height;

            if(this.xPos < levelInfo.xPos || this.xPos + this.width > levelInfo.xPos + levelInfo.width)
            {
                this.moveSpeedX = -this.moveSpeedX;
            }
        }
        else if(this.axis === "y")
        {
            // Move
            this.yPos += this.moveSpeedY;
            this.xPos = preXPos;
            preYPos = this.yPos;

            // Turn around if we are too far away
            if(Math.abs(postYPos - this.yPos) > this.maxLeaveY)
            {
                this.moveSpeedY = -this.moveSpeedY;
            }

            // Set boundingBox to make this object always update...
            this.boundingBox.yPos = this.yPos - 200;
            this.boundingBox.height = 400;
            this.boundingBox.xPos = this.xPos;
            this.boundingBox.width = this.width;

            if(this.yPos < levelInfo.yPos || this.yPos + this.height > levelInfo.yPos + levelInfo.height)
            {
                this.moveSpeedY = -this.moveSpeedY;
            }
        }
    };

    this.lastHittingFilter = millis();

    this.onCollide = function(object, info)
    {
        // If this is close enough to a filter block switch direction
        if(millis() - this.lastHittingFilter > 300 && object.arrayName === "filterBlock" && 
            (Math.abs((this.xPos + this.halfWidth) - (object.xPos + object.halfWidth)) <= Math.abs(this.moveSpeedX)) &&
            (Math.abs((this.yPos + this.halfHeight) - (object.yPos + object.halfHeight)) <= Math.abs(this.moveSpeedY)))
        {
            this.axis = (this.axis === "y") ? "x" : "y";

            this.xPos = object.xPos;
            this.yPos = object.yPos;
            this.lastHittingFilter = millis();
        }

        if(object.arrayName === "player")
        {
            object.takeDamage(this);
        }

        if(object.physics.solidObject && !object.sides)
        {
            switch(info.side)
            {
                case "left" : case "right" :
                    if(this.axis === "x")
                    {
                        // Turn around if we hit something
                        this.moveSpeedX = -this.moveSpeedX;

                        // Switch axis sometimes if we hit something
                        if(object.physics.movement === "static" && Math.random() < 0.1)
                        {
                            preXPos = this.xPos;
                            postYPos = this.yPos;
                            this.axis = "y";
                        }
                    }
                    break;

                case "up" : case "down" :
                    if(this.axis === "y")
                    {
                        // Turn around if we hit something
                        this.moveSpeedY = -this.moveSpeedY;

                        // Switch axis sometimes if we hit something
                        if(object.physics.movement === "static" && Math.random() < 0.1)
                        {
                            preYPos = this.yPos;
                            postXPos = this.xPos;
                            this.axis = "x";
                        }
                    }
                    break;
            }
        }
    };
};
gameObjects.addObject("slasher", createArray(Slasher));

var Bat = function(xPos, yPos, width, height)
{
    DynamicRect.call(this, xPos, yPos, width, height);
    LifeForm.call(this, 2);

    this.score = 8000;

    this.damage = 4;

    this.gravity = 0;
    this.inAir = true;

    this.imgNum = 1; 
    this.lastBatTime = millis();
    this.imgName = "batRoosting";

    this.draw = function()
    {
        // Draw state(s)
        switch(this.state)
        {
            case "flying" :
                if(millis() - this.lastBatTime > 150)
                {
                    this.imgNum++;
                    if(this.imgNum > 2)
                    {
                        this.imgNum = 1;
                    }
                    this.lastBatTime = millis();
                }

                this.imgName = "bat" + this.imgNum;
                break;

            case "roosting" :
                this.imgName = "batRoosting";
                break;
        }

        fastImage(loadedImages[this.imgName], this.xPos, this.yPos - 4, this.width, this.height);
    };

    this.state = "roosting";

    this.fallAmount = 100;
    this.swoopXSpeed = 4;
    this.swoopDirection = (Math.random() < 0.5) ? "left" : "right";
    this.lastSwoopTime = millis();

    this.roostingPlace = {
        xPos : xPos,
        yPos : yPos
    };

    var _lastUpdate = this.update;
    this.update = function()
    {
        _lastUpdate.apply(this, arguments);

        // Update state(s)
        switch(this.state)
        {
            case "flying" :
                this.physics.solidObject = true;
                this.inAir = true;

                this.released = false;
                this.gravity = 0;

                if(this.swoopDirection === "right")
                {
                    this.xVel = this.swoopXSpeed;
                }
                else if(this.swoopDirection === "left")
                {
                    this.xVel = -this.swoopXSpeed;
                }

                this.yVel = min(0, this.yVel);
                this.yVel -= 0.05;
                break;

            case "roosting" :
                this.physics.solidObject = false;
                this.inAir = false;

                if(this.released)
                {
                    this.gravity = 0.32;

                    if(this.roostingPlace.yPos + this.fallAmount < this.yPos)
                    {
                        this.switchState("flying");
                    }
                }
                break;
        }

        // Just in case things go wrong
        if(!this.cast.signal())
        {
            this.cast.setPos(this.cast);
            cameraGrid.addReference(this.cast);
        }
    };

    this.onCollide = function(object, info)
    {   
        if(this.state !== "roosting")
        {
            if(object.arrayName === "player")
            {
                if(info.side === "up")
                {
                    this.takeDamage(object);
                    object.yVel -= 3;
                }else{
                    object.takeDamage(this);
                }
            }
            else if(object.physics.solidObject && object.physics.shape === "rect" && info.side === "down" && object.physics.movement === "static")
            {
                this.xVel = 0;
                this.switchState("roosting");
                this.roostingPlace.yPos = object.yPos + object.height;
                this.roostingPlace.xPos = this.xPos;
            }
        }
    };

    var _lastTakeDamage = this.takeDamage;
    this.takeDamage = function(object, amt)
    {
        if(this.state === "flying")
        {
            return _lastTakeDamage.apply(this, arguments);
        }else{
            this.awake();
        }
    };

    this.switchState = function(state)
    {
        this.state = state;
        // Might add a switch(...)
        switch(state)
        {
            case "flying" :
                this.swoopXSpeed = random(2, 5);

                if(this.xPos + this.halfWidth < levelInfo.xPos + 200)
                {
                    this.swoopDirection = "right";
                }
                else if(this.xPos + this.halfWidth > levelInfo.xPos + levelInfo.width - 200)
                {
                    this.swoopDirection = "left";
                }else{
                    this.swoopDirection = (Math.random() < 0.5) ? "left" : "right";
                }
                break;
        }
    };

    this.awake = function()
    {
        if(this.state === "roosting")
        {
            this.released = true;
            this.fallAmount = 200;
        }
    };

    var _this = this;
    this.addCast = function()
    {
        //xPos, yPos, diameter, objectArrayName, inform, setPos, oneTime, time
        gameObjects.getObject("cast").add(this.xPos + this.halfWidth, this.yPos + this.halfHeight, 3, "", function(object)
        {
            if(_this.state === "roosting" && object.arrayName === "player")
            {
                _this.fallAmount = max(0, (object.yPos - _this.roostingPlace.yPos) + random(-10, 20)) || _this.fallAmount;
                _this.released = true;
            }
        },
        function(cast)
        {
            cast.xPos = _this.xPos + _this.halfWidth;  
            cast.yPos = _this.yPos + _this.halfHeight;
        }, false);

        this.cast = gameObjects.getObject("cast").getLast();
        this.cast.ignore.push("bat");
        this.cast.yVel = 12.4;
    };

    this.addCast();
};
gameObjects.addObject("bat", createArray(Bat));

var Ninja = function(xPos, yPos, width, height, colorValue)
{
    Enemy.call(this, xPos, yPos, width, height, colorValue || color(30, 67, 117), {
        handleEdge : true,
    }, false, 4);

    this.addCast(this, "ninja");
    this.scoreValue = 350;

    this.damage = 1;

    this.enterFunc = function(name, begin, end)
    {
        var suffix = name + millis() + Math.round(random(100, 0));

        var lastBeginKey = "begin" + suffix;
        this[lastBeginKey] = begin || function() {};

        var lastEndKey = "end" + suffix;
        this[lastEndKey] = end || function() {};

        var lastNameKey = "last" + suffix;
        this[lastNameKey] = this[name];

        var self = this;

        this[name] = function()
        {
            var r = this[lastBeginKey].apply(this, arguments);

            if(r === undefined || r > 0)
            {
                r = this[lastNameKey].apply(this, arguments) || r;
            }

            if(r === undefined || r > 1)
            {
                this[lastEndKey].apply(this, arguments);
            }
        };
    };

    this.getStarThrowTime = function()
    {
        return Math.round(random(1000, 2000)) * 1.5;
    };
    this.getStarSpeed = function()
    {
        return Math.round(random(2, 5));
    };

    this.lastThrowTimer = millis();

    this.createNinjaStar = function(amt, func)
    {
        sounds.mplaySound("swoosh.mp3");

        for(var i = 0; i < (amt || 1); i++)
        {
            gameObjects.getObject("ninjaStar").add(this.middleXPos, this.middleYPos, 15, this.color);
            this.ninjaStar = gameObjects.getObject("ninjaStar").getLast();          
            cameraGrid.addReference(this.ninjaStar);

            this.ninjaStar.damage = 0.75;

            if(typeof func !== "undefined")
            {
                func(this.ninjaStar, i);
            }else{
                this.ninjaStar.outerXVel2 = (this.xVel >= 0) ? this.getStarSpeed() : -this.getStarSpeed();
                this.ninjaStar.outerYVel2 = 0;
            }
        }   
    };
    this.updateNinjaStars = function()
    {
        if(millis() - this.lastThrowTimer >= this.getStarThrowTime())
        {
            physics.getMiddleXPos(this);
            physics.getMiddleYPos(this);

            this.createNinjaStar((random(0, 1) > 0.15) ? 1 : 2);
            this.lastThrowTimer = millis();
        }
    };

    var self = this;

    this.tasks = [];
    this.tasks.addTask = function(name, start, run, end)
    {
        this.push(name);
        
        this[name] = (typeof start === "object") ? start : {};
        this[name].name = name;
        this[name].start = (typeof start === "function") ? start : this[name].start || function() {};

        this[name].run = this[name].run || run || function() {};
        this[name].end = this[name].end || end || function() {};
    };
    this.tasks.startTask = function(taskName)
    {
        var task = this.indexOf(taskName);

        if(task !== -1)
        {
            if(typeof this.currentTask === "object")
            {
                this.currentTask.end.apply(self, arguments);
            }

            this[taskName].start.apply(self, arguments);
            this.currentTask = this[taskName];
        }
    };
    this.tasks.runTask = function()
    {
        this.currentTask.run.apply(self, arguments);
    };

    this.defaultMaxXVel = 2;

    this.tasks.addTask("default", {
        run : function()
        {
            if(random(0, 1) < 0.35 && millis() % 4000 >= 2500)
            {
                this.yDir = "up";
            }else{
                this.yDir = "";
            }
        },
    });

    this.taskEndTime = millis();

    this.hitObjectDist = function(d)
    {
        return Math.pow(Math.abs(this.middleXPos - this.hitObject.middleXPos), 2) + 
               Math.pow(Math.abs(this.middleYPos - this.hitObject.middleYPos), 2) < Math.pow(d, 2);
    };

    this.tasks.addTask("follow", {
        start : function()
        {
            this.lastHandleLeft = this.handleLeft;
            this.handleLeft = function()
            {
                if(!this.inAir)
                {
                    this.yDir = "up";
                }
            };
            this.lastHandleRight = this.handleRight;
            this.handleRight = function()
            {
                if(!this.inAir)
                {
                    this.yDir = "up";
                }
            };

            this.lastHandleBlock = this.handleBlock;
            this.handleBlock = function(object, info)
            {
                if(info.side === "left" || info.side === "right")
                {
                    if(!this.inAir)
                    {
                        this.yDir = "up";
                    }
                }
            };

            this.startTaskTime = millis();
        },
        run : function()
        {
            physics.getMiddleXPos(this.hitObject);
            physics.getMiddleXPos(this);

            physics.getMiddleYPos(this.hitObject);
            physics.getMiddleYPos(this);

            this.xDir = (this.hitObject.middleXPos < this.middleXPos) ? "left" : "right";
            this.yDir = "";

            if(millis() - this.playerLastHitTime > 6000 && 
                !this.hitObjectDist(70))
            {
                this.tasks.startTask("default");
                return;
            }
            else if(millis() - this.startTaskTime > 3000 && 
                this.hitObjectDist(150))
            {
                this.tasks.startTask("default");
                return;
            }

            if(this.yPos > this.hitObject.yPos + this.hitObject.height &&
               (abs(this.middleXPos - this.hitObject.middleXPos) > (this.width + this.hitObject.width) / 2))
            {
                this.yDir = "up";
            }

            if(millis() - this.startTaskTime > 15000)
            {
                this.tasks.startTask("default");
                return;
            }
        },
        end : function()
        {
            this.props.handleEdge = true;
            this.handleLeft = this.lastHandleLeft;
            this.handleRight = this.lastHandleRight;
            this.handleBlock = this.lastHandleBlock;
            this.maxXVel = this.defaultMaxXVel;

            this.taskEndTime = millis();
        },
    });

    this.draw = function()
    {   
        image(storedImages[this.arrayName], this.xPos, this.yPos, this.width, this.height);
    };

    this.enterFunc("update", function()
    {
        if(!this._setup_)
        {
            this.tasks.startTask("default");
            this._setup_ = true;
        }

        this.updateNinjaStars();
        this.task = "";

        if(!this.wwwSounds && game.gameState !== "credits")
        {
            sounds.mplaySound("whistle1.mp3");
            this.wwwSounds = true;
        }
    }, 
    function()
    {   
        this.tasks.runTask();
    });

    this.enterFunc("onCollide", function(object, info)
    {
        if(object.arrayName === "player")
        {
            this.playerLastHitTime = millis();
            if(millis() - this.taskEndTime > 3000)
            {
                this.tasks.startTask("follow");
            }
            this.hitObject = object;
        }
        else if(object.arrayName === "pillar" || object.arrayName === "pillarBlock")
        {
            return 0;
        }
    });
};
gameObjects.addObject("ninja", createArray(Ninja));

var LaunchBall = function(xPos, yPos, diameter, colorValue, damage, speed)
{
    DynamicCircle.call(this, xPos, yPos, diameter);
    this.color = colorValue || color(0, 0, 0, 100);
    this.damage = damage || 1;
    this.hp = 3;

    this.physics.solidObject = false;
    this.gravity = 0;

    this.mode = "rotate";

    this.speed = speed || 4;

    this.maxFadeLife = 80;
    this.fadeLife = this.maxFadeLife;

    this.draw = function()
    {
        fill(red(this.color), green(this.color), blue(this.color), this.fadeLife * 255 / this.maxFadeLife);
        stroke(11, 93, 140);
        circle(this.xPos, this.yPos, this.diameter);
        noStroke();
    };

    this.primeMode = function()
    {
        switch(this.mode)
        {
            case "fade" :
                this.yVel = -8;
                this.gravity = 0.3;
                break;

            case "life" :
                this.life = 100;
                break;
        }
    };

    this.maxGrowth = 200;
    this.growth = 0;

    this.maxDiameter = diameter;

    this.useRemote = false;

    this.corrections = 0;
    this.maxCorrections = Infinity;
    this.lastCorrectionTime = millis();

    this.lastUpdate = this.update;
    this.update = function(remote)
    {
        if(!remote && this.useRemote)
        {
            return;
        }

        if(this.mode !== "rotate" &&
        (this.xPos < levelInfo.xPos + this.radius ||
        this.xPos > levelInfo.xPos + levelInfo.width - this.radius || 
        this.yPos < levelInfo.yPos + this.radius ||
        this.yPos > levelInfo.yPos + levelInfo.height - this.radius))
        {
            this.remove();
        }

        cameraGrid.removeReference(this);
        cameraGrid.addReference(this);

        this.growth = this.growth || 0;

        switch(this.mode)
        {
            case "rotate" :
                this.growth++;
                if(this.growth >= this.maxGrowth)
                {
                    this.growth = this.maxGrowth;
                }
                this.diameter = (this.growth * this.maxDiameter / this.maxGrowth);
                this.radius = this.diameter / 2;
                break;

            case "fade" : 
                this.fadeLife--;
                if(this.fadeLife < 0)
                {
                    this.remove();
                }
                break;

            case "launch" :
                this.xVel = this.setXVel || this.xVel || 0;
                this.yVel = this.setYVel || this.yVel || 0;

                if(this.homing && this.corrections <= this.maxCorrections && (!this.correctionInterval || millis() - this.lastCorrectionTime > this.correctionInterval))
                {
                    var target = player;
                    if(this.homingTarget)
                    {
                        target = this.homingTarget;
                    }

                    var a = atan2(target.yPos + target.halfHeight - this.yPos, target.xPos + target.halfWidth - this.xPos);

                    this.setXVel = cos(a) * (this.speed || 3);
                    this.setYVel = sin(a) * (this.speed || 3);

                    this.corrections++;
                    this.lastCorrectionTime = millis();
                }
                break;
        }

        this.lastUpdate();
    };

    this.noDamageTo = [];

    this.onCollide = function(object)
    {
        if(this.mode === "launch")
        {
            if(object.arrayName !== this.hostObject.arrayName && object.arrayName !== "ninja")
            {
                if(object.type === "lifeform" && this.noDamageTo.indexOf(object.arrayName + object.index) === -1)
                {
                    var countered = object.takeDamage(this);

                    if(!countered)
                    {
                        this.remove();
                        this.onCollide = function() {};

                        if(this.addEffect)
                        {
                            this.addEffect(object);
                        }
                    }else{
                        var d = Math.sqrt(Math.pow(this.outerYVel2, 2) + Math.pow(this.outerXVel2, 2));
                        var a = atan2(this.outerYVel2, 
                                      this.outerXVel2);

                        a += PI;
                        d *= 1.1;

                        this.outerXVel2 = cos(a) * d;
                        this.outerYVel2 = sin(a) * d;

                        this.noDamageTo.push(object.arrayName + object.index);
                    }
                }
                else if(object.physics.solidObject)
                {
                    this.remove();
                }
            }
        }
    };
};
gameObjects.addObject("launchBall", createArray(LaunchBall));

var SpaceBreaker = function(xPos, yPos, diameter, colorValue, amt)
{
    DynamicCircle.call(this, xPos, yPos, diameter);
    LifeForm.call(this, 50);
    this.scoreValue = 700;

    this.color = colorValue || color(0, 200, 0);

    this.damage = 0.5;

    this.lastRemove = this.remove;
    this.remove = function()
    {
        this.lastRemove();

        for(var i = 0; i < this.launchBalls.length; i++)
        {
            this.launchBalls[i].mode = "fade";
            this.launchBalls[i].primeMode();
        }
    };

    //Make the enemy "floaty"
    this.gravity = 0.0;
    this.posRadius = this.diameter;
    
    this.posAngle = 0;
    this.posAngleVel = 0.03 * ((random(0, 100) >= 50) ? -1 : 1);
    this.posMode = "rotate";
    this.posAmt = 8;

    this.launchBalls = [];
    this.toLaunchIndex = 0;

    this.nextHitTimeMultiplier = 3;
    this.launchBallSpeedMultiplier = 1.6;

    this.primePositions = function(growth)
    {
        var self = this;
        var launchBalls = gameObjects.getObject("launchBall");
        this.launchBalls = [];

        for(var i = 0; i < this.posAmt; i++)
        {
            launchBalls.add(this.xPos - 200, this.yPos, this.radius, this.color, 2, Math.round(random(2.5, 5)) * this.launchBallSpeedMultiplier);

            var launchBall = launchBalls.getLast();
            launchBall.hostObject = this;
            launchBall.growth = ((growth === "full") ? launchBall.maxGrowth : growth) || launchBall.growth;

            cameraGrid.addReference(launchBall);
            this.launchBalls.push(launchBall);
        }
    };

    this.casts = [];
    this.maxCasts = 100;
    this.castShootAngle = 0;
    this.hits = [];

    this.openCasts = 0;

    this.hitLimiter = 60;
    this.getNextHitTime = function()
    {
        return Math.round(random(20, 30)) / this.nextHitTimeMultiplier;
    };

    this.nextHitTime = this.getNextHitTime();

    this.addCast = function(self)
    {
        if(this.casts.length > this.maxCasts)
        {
            return;
        }

        this.openCasts++;
        gameObjects.getObject("cast").add(self.xPos, self.yPos, 3, self.arrayName, function(object, cast)
        {
            if(object.type === "lifeform" && object.arrayName !== self.arrayName)
            {
                self.hits.push({
                    object : object,
                    xVel : cast.xVel,
                    yVel : cast.yVel,
                    indie : cast.indie,
                    hitMillis : millis(),
                });
            }

            self.openCasts--;
        },
        function(cast)
        {
            cast.xPos = self.xPos;  
            cast.yPos = self.yPos;
        }, true);

        this.castShootAngle += ((MODE === "pjs") ? 0.1 : 3) * 17;

        var lastCast = gameObjects.getObject("cast").getLast();
        lastCast.setPos(lastCast);
        lastCast.time = 100;
        lastCast.xVel = sin(this.castShootAngle) * 7;
        lastCast.yVel = cos(this.castShootAngle) * 7;

        lastCast.lastRemove = lastCast.remove;
        lastCast.remove = function()
        {
            this.lastRemove();
            self.casts.splice(this.indie, 1);
        };

        cameraGrid.addReference(lastCast);
        lastCast.indie = self.casts.length;
        self.casts.push(lastCast);
    };

    this.aDiameter = this.diameter / 4;
    this.dDiameter = this.diameter * 0.2;
    this.pDiameter = this.diameter * 3;

    this.draw = function()
    {
        noStroke();
        fill(this.color);
        circle(this.xPos, this.yPos, this.diameter);

        fill(0, 60, 120, 140);
        circle(this.xPos - this.dDiameter, this.yPos - this.dDiameter, this.aDiameter);
        circle(this.xPos + this.dDiameter, this.yPos - this.dDiameter, this.aDiameter);

        stroke(11, 93, 140);

        noFill();
        strokeWeight(3);
        arc(this.xPos, this.yPos, this.pDiameter, this.pDiameter, 0, ((MODE === "pjs") ? 
        (this.hp * TWO_PI / this.maxHp) : (this.hp * 360 / this.maxHp)));
        strokeWeight(1);
        noStroke();
    };

    this.mode = "fire";
    this.regenChangeTime = millis();
    this.travelMode = "idle";

    this.setXVel = 0;
    this.setYVel = 0;
    this.setAngle = 0;
    this.setAngleVel = 6;
    this.normSpeed = 5;

    this.setVelAngle = function(angle, speed)
    {
        var sp = dist(0, 0, this.setXVel || this.xVel, this.setYVel || this.yVel);
        this.setXVel = sin(angle) * (speed || sp);
        this.setYVel = cos(angle) * (speed || sp);
    };

    this.isEnemy = function(str)
    {
        return (str === "player");
    };

    this.loadUpTime = millis();

    this.riseLoops = 0;
    this.sinkLoops = 0;

    this.delag = true;

    this.delagSoft = false;

    this.lastUpdate = this.update;
    this.update = function()
    {
        this.lastUpdate();

        if(!this.zoomed && millis() - this.loadUpTime > 1000 && game.gameState !== "credits")
        {
            sounds.mplaySound("zoom1.wav");
            this.zoomed = true;
        }

        if(!this.primed)
        {
            this.primePositions("full");
            this.primed = true;
        }

        if(this.openCasts < 100 && millis() % (!this.delagSoft ? 600 : 900) >= (!this.delagSoft ? 80 : 400) && !this.delag)
        {
            this.addCast(this);
        }

        if(abs(this.posAngle) > ((MODE === "pjs") ? TWO_PI : 360))
        {
            this.posAngleVel = -this.posAngleVel;
        }

        this.posAngle += this.posAngleVel;

        switch(this.travelMode)
        {
            case "figure8" :
                this.setAngle += this.setAngleVel;
                if(this.setAngle >= 360 || this.setAngle <= 0)
                {
                    this.setAngleVel = -this.setAngleVel;
                }
                this.setVelAngle(this.setAngle * TWO_PI / 360, this.normSpeed);
                if(this.mode === "fire")
                {
                    this.travelMode = "idle";
                }
                break;

            case "idle" :
                this.setXVel = 0;
                this.setYVel = 0;
                break;

            case "run" :
                if(this.mode === "fire")
                {
                    this.travelMode = "idle";
                }

                if(this.hits.length > 0 && this.isEnemy(this.hits[0].object.arrayName) &&
                  dist(this.hits[0].object.xPos, this.hits[0].object.yPos, this.xPos, this.yPos) < 155)
                {
                    var a = atan2(this.hits[0].yVel, this.hits[0].xVel);
                    this.setVelAngle(a/* + ((MODE === "pjs") ? PI : 360)*/, 4);
                    this.setYVel -= 2;
                }else{
                    this.setXVel = 0;
                    this.setYVel = 0;
                }
                break;

            case "sink" :
                this.setXVel = 0;
                this.setYVel = 0.4;

                this.sinkLoops++;
                break;

            case "rise" :
                this.setXVel = 0;
                this.setYVel = -0.4;

                this.riseLoops++;
                break;
        }

        if(this.travelMode !== "rise")
        {
            this.riseLoops = 0;
        }
        else if(this.riseLoops >= 120)
        {
            this.travelMode = "sink";

            this.yVel = -10;
        }
        if(this.travelMode !== "sink")
        {
            this.sinkLoops = 0;
        }
        else if(this.sinkLoops >= 30)
        {
            this.travelMode = "rise";

            if(random(0, 1) > 0.7)
            {
                this.travelMode = "figure8";
            }

            this.yVel = 10;
        }

        this.xVel = this.setXVel;
        this.yVel = this.setYVel;

        if(this.mode === "regen" && this.chooseTravel)
        {
            this.travelMode = (round(random(0, 100)) >= 50) ? "figure8" : "run";
            this.chooseTravel = false;
        }

        if(random(0, 100) > 80 && this.takenDamage)
        {
            this.travelMode = "figure8";
            this.takenDamage = false;
        }

        if(this.hp < this.maxHp * 0.25)
        {
            this.travelMode = "run";
        }

        if(this.launchBalls[0].growth < this.launchBalls[0].maxGrowth * 0.4)
        {
            this.travelMode = (round(random(0, 100)) >= 50) ? "figure8" : "run";
        }

        this.upTime--;
        this.downTime--;

        if(this.upTime > 0)
        {
            this.travelMode = "rise";
        }
        else if(this.yPos + 150 < yPos || this.downTime > 0)
        {
            this.travelMode = "sink";
        }

        switch(this.mode)
        {
            case "fire" :
                var i = min(this.toLaunchIndex, this.launchBalls.length - 1);
                if((this.delag && random(0, 1) > 0.5 || this.hits.length > 0 && this.isEnemy(this.hits[0].object.arrayName)) && 
                (millis() % this.nextHitTime >= this.nextHitTime - 1 || this.unLaunchedBalls <= 1))
                {
                    if(!this.launchBalls[i].used &&
                    /* this.launchBalls[i].mode !== "launch" &&*/
                     this.launchBalls[i].growth >= this.launchBalls[i].maxGrowth)
                    {
                        this.launchBalls[i].mode = "launch";
                        this.launchBalls[i].used = true;

                        var a = 0;
                        if(this.delag)
                        {
                            
                            a = atan2(player.yPos - this.yPos, player.xPos - this.xPos) + Math.round(random(-0.12, 0.12));
                        }else{
                            var a = atan2(this.hits[0].yVel, this.hits[0].xVel);
                        }

                        this.launchBalls[i].setXVel = cos(a) * (this.launchBalls[i].speed) * (this.delag ? 0.7 : 1);
                        this.launchBalls[i].setYVel = sin(a) * (this.launchBalls[i].speed) * (this.delag ? 0.7 : 1);

                        this.nextHitTime = this.getNextHitTime();

                        if(!this.delag)
                        {
                            this.hits.shift();
                        }
                    }
                }

                if(this.hits.length > 0 && abs(this.hits[0].hitMillis - millis()) >= this.hitLimiter)
                {
                    this.hits.shift();
                }

                this.toLaunchIndex = ceil(random(0, this.launchBalls.length)) - 1;

                this.usedLaunchBalls = 0;
                for(var i = 0; i < this.launchBalls.length; i++)
                {
                    if(this.launchBalls[i].used)
                    {
                        this.usedLaunchBalls++;
                    }
                }

                if(this.usedLaunchBalls >= this.launchBalls.length)
                {
                    this.mode = "regen";
                    this.regenChangeTime = millis();
                    this.usedLaunchBalls = 0;
                    this.chooseTravel = true;
                }

                this.unLaunchedBalls = (this.launchBalls.length - this.usedLaunchBalls);
            break;

            case "regen" :
                if(abs(millis() - this.regenChangeTime) >= 3000)
                {
                    this.primePositions(0);
                    this.mode = "fire";
                    this.override = true;
                }
                break;
        }

        switch(this.posMode)
        {
            case "rotate" :
                var angle = 0;
                var addAngle = ((MODE === "pjs") ? TWO_PI : 360) / this.launchBalls.length;
                for(var i = 0; i < this.launchBalls.length; i++)
                {
                    if(this.launchBalls[i].mode === "rotate")
                    {
                        this.launchBalls[i].xPos = this.xPos + sin(angle + this.posAngle) * this.posRadius;
                        this.launchBalls[i].yPos = this.yPos + cos(angle + this.posAngle) * this.posRadius;
                    }
                    angle += addAngle;
                }
                break;
        }

        this.maxCasts += 1;

        if(this.hp <= this.maxHp * 0.25)
        {
            this.gravity = ((100 - this.hp * 100 / this.maxHp * 4) / 30);
        }
    };

    this.onCollide = function(object)
    {
        this.lastColliderType = object.type;
        if(this.lastColliderType === "block" && object.physics.solidObject)
        {
            if(object.yPos > this.yPos)
            {
                this.upTime = 150;
            }else{
                this.downTime = 150;
            }
        }
        if(this.isEnemy(object.arrayName))
        {
            this.takenDamage = true;
            this.takeDamage(object);
        }
    };
};
gameObjects.addObject("spaceBreaker", createArray(SpaceBreaker));

var Boss = function(xPos, yPos, width, height, colorValue, props, what, hp)
{
    Enemy.call(this, xPos, yPos, width, height, colorValue, props, what, hp);
    this.scoreValue = 2600;
    this.isBoss = true;
};

var NinjaBoss = function(xPos, yPos, width, height)
{
    Boss.call(this, xPos, yPos, width, height, color(150, 20, 220, 240), {
        charging : true,
    }, false, 10);

    this.damage = 0.5;

    this.preventDefaultAI = true;

    this.addCast(this, "ninjaBoss");
    this.addCast(this, "ninjaBoss");

    this.draw = function()
    {   
        image(storedImages[this.arrayName], this.xPos, this.yPos, this.width, this.height);
    };

    this.createNinjaStar = function(amt, func)
    {
        sounds.mplaySound("swoosh.mp3");

        for(var i = 0; i < (amt || 1); i++)
        {
            gameObjects.getObject("ninjaStar").add(this.middleXPos, this.middleYPos, 15, this.color);
            this.ninjaStar = gameObjects.getObject("ninjaStar").getLast();          
            cameraGrid.addReference(this.ninjaStar);

            if(typeof func !== "undefined")
            {
                func(this.ninjaStar, i);
            }else{
                var speed = Math.round(random(2, 5));

                this.ninjaStar.outerXVel2 = ((random(0, 100) >= 50) ? speed : -speed);
                this.ninjaStar.outerYVel2 = 0;

                physics.getMiddleXPos(this);

                if(this.hitObject !== undefined)
                {
                    if(this.middleXPos > this.hitObject.xPos + this.hitObject.halfWidth)
                    {
                        this.ninjaStar.outerXVel2 = -speed;
                    }else{
                        this.ninjaStar.outerXVel2 = speed;
                    }
                }
            }
        }   
    };

    this.tasks = ["charge", "run", "tired"];
    this.task = "";

    this.results = [];

    this.setTask = function(task)
    {
        var valid = this.tasks.indexOf(task) !== -1;

        if(valid)
        {
            this.endTask(this.task);
            this.task = task;
            this.startTask(this.task);
        }

        return valid;
    };
    this.clearTask = function()
    {
        this.endTask(this.task);
        this.task = "";
    };

    this.autoMaxXVel = this.maxXVel;
    this.fastMaxXVel = 3.5;
    this.slowMaxXVel = 1.5;

    this.slowDown = 0.7;

    this.jumpInterval = 1200;
    this.jumpAboveObjectNext = millis();

    this.maxEnergy = 45;
    this.energy = 45;

    this.startTask = function()
    {
        switch(this.task)
        {
            case "charge" :
                this.maxXVel = this.fastMaxXVel - 0.5;
                this.lastComeBackTime = millis() - 1000;
                break;

            case "tired" :
                this.maxXVel = this.slowMaxXVel;
                break;

            case "run" :
                this.maxXVel = this.fastMaxXVel;
                this.jumpAboveObjectNext = millis() - this.jumpInterval;
                this.startRunTime = millis();

                if(this.xDir !== "left" || this.xDir !== "right")
                {
                    this.setXDir((random(0, 1) < 0.5) ? "left" : "right");
                }
                break;
        }
    };
    this.endTask = function()
    {
        switch(this.task)
        {
            case "charge" : case "run" : case "tired" :
                this.maxXVel = this.autoMaxXVel;
                break;
        }
    };
    this.updateTask = function()
    {
        this.task = "run";

        switch(this.task)
        {
            case "charge" :
                if(millis() - this.lastComeBackTime > 1000)
                {
                    this.setXDir((this.middleXPos > this.hitObject.middleXPos) ? "left" : "right");

                    this.lastComeBackTime = millis();
                }

                this.setYDir("");

                if(this.hitObject.yPos < this.yPos && this.hitObject.yVel < 0 && 
                    this.hitObject.yPos > this.yPos - this.hitObject.height * 1.5 && 
                   (this.hitObject.xVel !== 0 || random(0, 1) < 0.05) && 
                   millis() - this.jumpAboveObjectNext > this.jumpInterval &&
                   abs(this.middleXPos - this.hitObject.middleXPos) > ((this.width + this.hitObject.width) / 2) && 
                   abs(this.xPos - this.hitObject.xPos) < levelInfo.unitWidth * 2)
                {
                    this.setYDir("up");

                    this.jumpAboveObjectNext = millis();
                    this.lastComeBackTime = millis();

                    this.energy -= 5 / fpsCatcher.actualFps;
                }

                if(this.hitObject.yPos < this.yPos && millis() - this.startRunTime > 2000 && 
                   random(0, 1) < 0.1 && millis() % 1000 >= 900 && 
                   abs(this.middleXPos - this.hitObject.middleXPos) < (this.width + this.hitObject.width) / 2)
                {
                    this.setTask("run");
                }

                this.energy -= 1 / fpsCatcher.actualFps;

                if(this.energy < 15)
                {
                    this.maxXVel = this.fastMaxXVel - 0.5 - this.slowDown;
                }

                if(this.energy < 0)
                {
                    this.energy = 0;
                    this.setTask("tired");
                }
                break;

            case "run" :
                this.setYDir("");

                if(this.hitObject.yPos >= this.yPos && 
                   millis() - this.jumpAboveObjectNext > this.jumpInterval &&
                   abs(this.xPos - this.hitObject.xPos) < levelInfo.unitWidth * 2.5)
                {
                    this.setYDir("up");

                    this.energy -= 9 / fpsCatcher.actualFps;

                    this.jumpAboveObjectNext = millis();
                }

                if(this.hitObject.yPos < this.yPos && abs(this.middleXPos - this.hitObject.middleXPos) < (this.width + this.hitObject.width) / 2)
                {
                    if(this.xPos + this.width >= levelInfo.xPos + levelInfo.width - this.width * 2.5)
                    {
                        this.setXDir("left");
                    }
                    else if(this.xPos < levelInfo.xPos + this.width * 2.5)
                    {
                        this.setXDir("right");
                    }else{
                        this.setXDir((this.hitObject.xVel > 0 && this.xVel !== 0) ? "left" : "right");
                    }
                }

                if(millis() - this.jumpAboveObjectNext < this.jumpInterval)
                {
                    this.maxXVel = this.fastMaxXVel + 2;
                }else{
                    this.maxXVel = this.fastMaxXVel;
                }

                this.energy -= 2 / fpsCatcher.actualFps;

                if(this.energy < 15)
                {
                    this.maxXVel = this.fastMaxXVel - this.slowDown;
                }
                else if(millis() - this.startRunTime > 5000)
                {
                    this.setTask("charge");
                }

                if(this.energy < 0)
                {
                    this.energy = 0;
                    this.setTask("tired");
                }
                break;

            case "tired" :
                this.setYDir("");

                if(this.hitObject.yPos < this.yPos && abs(this.middleXPos - this.hitObject.middleXPos) < (this.width + this.hitObject.width) / 2)
                {
                    this.setXDir((this.hitObject.xVel > 0) ? "left" : "right");
                }

                this.energy += 10 / fpsCatcher.actualFps;

                if(this.energy > this.maxEnergy)
                {
                    this.energy = this.maxEnergy;
                    this.setTask("charge");
                }
                break;
        }
    };

    this.setXDir = function(input)
    {
        this.xDir = input;
    };
    this.setYDir = function(input)
    {
        this.yDir = input;
    };
    this.clearXDir = function()
    {
        this.xDir = "";
    };
    this.clearYDir = function()
    {
        this.yDir = "";
    };
    this.clearDir = function()
    {
        this.clearXDir();
        this.clearYDir();
    };

    this.lastThrowTimer = millis();
    this.throwTime = 1200;

    this.updateNinjaStars = function()
    {
        if(millis() - this.lastThrowTimer >= this.throwTime)
        {
            var self = this;

            var amount = (random(0, 1) > 0.15) ? 1 : 2;

            this.createNinjaStar(amount, function(ninjaStar, i)
            {
                var a = atan2(self.middleYPos - self.hitObject.middleYPos, 
                              self.middleXPos - self.hitObject.middleXPos) - PI / 2;

                var speed = self.maxXVel + Number(random(0, 0.5).toFixed(1));

                ninjaStar.outerXVel2 = sin(a) * speed;
                ninjaStar.outerYVel2 = max(-5, -abs(cos(a) * speed));

                ninjaStar.damage = 0.2;
            });

            this.lastThrowTimer = millis();
        }
    };

    this.setTask("charge");

    this._lastUpdate = this.update;
    this.update = function()
    {
        physics.getMiddleXPos(this);
        physics.getMiddleYPos(this);

        this.hitObject = player;  

        if(this.hitObject !== undefined)
        {
            physics.getMiddleXPos(this.hitObject);
            physics.getMiddleYPos(this.hitObject);

            this.updateTask();
            this.updateNinjaStars();
        }

        this._lastUpdate();
    };

    this.avoidCollision = function(object)
    {
        return (object.arrayName === "spike" || object.arrayName === "slope");
    };

    this.blowsToTheHead = 0;

    var _lastRemove = this.remove;

    this.remove = function()
    { 
        if(player.maxHp < 15)
        {
            gameObjects.getObject("heart").add(
                levelInfo.xPos + levelInfo.width / 2,
                levelInfo.yPos + levelInfo.unitHeight, 
                levelInfo.unitWidth, 5);

            var heart = gameObjects.getObject("heart").getLast();

            heart.falling = true;
            heart.gravity = 5;

            heart.minimumYPos = levelInfo.yPos + levelInfo.unitHeight * 11;

            cameraGrid.addReference(heart);
        }

        _lastRemove.apply(this, arguments);

        this.remove = function() {};
        this.onCollide = function() {};
        this.draw = function() {};
        this.update = function() {};
    };

    this._lastOnCollide = this.onCollide;
    this.onCollide = function(object, info)
    {
        if(object.arrayName === "lever")
        {
            if(!object.set)
            {
                object.set = true;
            }
            return;
        }

        if(this.hitObject !== undefined)
        {
            if(object.arrayName === this.hitObject.arrayName)
            {
                switch(info.side)
                {
                    case "up" :
                        this.blowsToTheHead++;

                        this.energy -= 2.5;

                        if(this.blowsToTheHead % 3 >= 2)
                        {
                            this.setTask("run");
                        }

                        if(this.yVel < 0)
                        {
                            this.hitObject.yVel = -14;
                        }
                        break;
                }
            }
        }

        this._lastOnCollide(object, info);
    };
};
gameObjects.addObject("ninjaBoss", createArray(NinjaBoss));

function createTrack()
{
    var track = [];
    track.perimeter = 0;

    // Pretty self-explanatory
    track.getPerimeter = function()
    {
        this.perimeter = 0;

        for(var i = 1; i < this.length; i++)
        {
            this.perimeter += Math.sqrt(Math.pow(this[i - 1].xPos - this[i].xPos, 2) + Math.pow(this[i - 1].yPos - this[i].yPos, 2));
        }

        var l = this.length - 1;
        this.perimeter += Math.sqrt(Math.pow(this[l].xPos - this[0].xPos, 2) + Math.pow(this[l].yPos - this[0].yPos, 2));

        return this.perimeter;
    };
    track.getDistAlong = function(point, index)
    {
        var dist = 0;

        for(var i = 0; i < index; i++)
        {
            dx = this[i + 1].xPos - this[i].xPos;
            dy = this[i + 1].yPos - this[i].yPos;
            dist += Math.sqrt(dx * dx + dy * dy);
        }

        dx = point.xPos - this[index].xPos;
        dy = point.yPos - this[index].yPos;
        dist += Math.sqrt(dx * dx + dy * dy);

        return dist;
    };
    track.putPointAlong = function(length)
    {
        var point = {};

        var i = 0;
        var dist = 0;

        var lastDist;
        var dx, dy, l;

        while(dist < length && i < this.length)
        {
            if(i + 1 >= this.length)
            {
                var l = this.length - 1;
                dx = this[0].xPos - this[l].xPos;
                dy = this[0].yPos - this[l].yPos;
            }else{
                dx = this[i + 1].xPos - this[i].xPos;
                dy = this[i + 1].yPos - this[i].yPos;
            }

            dist += (lastDist = Math.sqrt(dx * dx + dy * dy));

            i++;
        }

        var a;

        if(i >= this.length)
        {
            var l = this.length - 1;
            a = atan2(this[0].yPos - this[l].yPos, 
                      this[0].xPos - this[l].xPos);
        }else{
            a = atan2(this[i].yPos - this[i - 1].yPos, 
                      this[i].xPos - this[i - 1].xPos);
        }

        var offset = lastDist - (dist - length);
        point.xPos = this[i - 1].xPos + cos(a) * offset;
        point.yPos = this[i - 1].yPos + sin(a) * offset;

        return point;
    };
    track.add = function(xPos, yPos)
    {
        this.push({
            xPos : xPos,
            yPos : yPos,
        });
    };
    track.draw = function()
    {
        stroke(0, 0, 0, 100);
        strokeWeight(1.6);
        for(var i = 1; i < this.length; i++)
        {
            line(this[i].xPos, this[i].yPos, this[i - 1].xPos, this[i - 1].yPos);
        }

        if(this.length > 1)
        {
            line(this[0].xPos, this[0].yPos, this[this.length - 1].xPos, this[this.length - 1].yPos);
        }
    };
    track.stepPoint = function(point)
    {
        var line0 = this[point.index];
        var line1 = this[point.index + 1];

        if(!line0)
        {
            line0 = this[this.length - 1];
        }
        if(!line1)
        {
            line1 = this[0];
        }

        var lineHeight = line1.yPos - line0.yPos,
            lineWidth = line1.xPos - line0.xPos;

        var a = atan2(lineHeight, lineWidth);

        point.xVel = cos(a) * point.speed
        point.yVel = sin(a) * point.speed;

        point.xPos += point.xVel;
        point.yPos += point.yVel;

        if(Math.pow(point.xPos - line0.xPos, 2) + Math.pow(point.yPos - line0.yPos, 2) > 
            lineWidth * lineWidth + lineHeight * lineHeight)
        {
            point.index += point.heading;
            point.index %= this.length;
        }
    };

    return track;
}

var IceDragon = function(xPos, yPos, width, height)
{
    Boss.call(this, xPos, yPos, width, height, color(15, 120, 220, 220), {
        charging : true,
        handleEdge : true
    }, false, 32);

    this.physics.solidObject = true;

    this.noHeightChanges = true;

    this.physics.movement = "static";
    // this.physics.changes = true;

    var self = this;

    this.apart = 90;
    this.separation = this.apart * this.apart;
    this.dragonLength = 14;
    this.gravity = 0;

    this.createTracks = function()
    {
        this.track = createTrack(true);
        this.track2 = createTrack(true);
    };

    this.setupPoints = function()
    {
        this.points = [];
        this.points.add = function(xPos, yPos, speed)
        {
            this.push({
                xPos : xPos,
                yPos : yPos,
                speed : speed || 0.65,

                heading : 1,
                index : 0,

                xVel : 0,
                yVel : 0
            });
        };
        this.points.draw = function()
        {
            noFill();
            strokeWeight(0.8)
            stroke(230, 230, 230, 160);
            for(var i = this.length - 1; i >= 0; i--)
            {
                circle(this[i].xPos, this[i].yPos, 6);
            }
            noStroke();
        };
        this.points.update = function(track)
        {
            if(this[0])
            {
                track.stepPoint(this[0]);
            }

            for(var i = 1; i < this.length; i++)
            {
                track.stepPoint(this[i]);

                // Keep points from becoming too far apart.
                if(Math.pow(this[i].xPos - this[i - 1].xPos, 2) + Math.pow(this[i].yPos - this[i - 1].yPos, 2) > self.separation)
                {
                    this[i].xPos += this[i].xVel;
                    this[i].yPos += this[i].yVel;
                }
            }
        };

        this.points2 = [];
        this.points2.add = this.points.add;
        this.points2.draw = this.points.draw;
        this.points2.update = function(track)
        {
            if(this[0])
            {
                track.stepPoint(this[0]);
            }

            for(var i = 1; i < this.length; i++)
            {
                track.stepPoint(this[i]);

                // Keep points from becoming too far apart.
                if(Math.pow(this[i].xPos - this[i - 1].xPos, 2) + Math.pow(this[i].yPos - this[i - 1].yPos, 2) > self.separation2)
                {
                    this[i].xPos += this[i].xVel;
                    this[i].yPos += this[i].yVel;
                }
            }
        };
    };

    this.setTracksToLoad = function()
    {
        this.setTrack1 = [{"xPos":852.8068647221817,"yPos":812.6325423367903},{"xPos":886.2713980086756,"yPos":813.0697113666338},{"xPos":919.6151086973339,"yPos":813.0515590848212},{"xPos":956.2825961684364,"yPos":813.0501233169432},{"xPos":974.6637868021165,"yPos":792.6762994697699},{"xPos":1032.0302668025543,"yPos":789.3368247831376},{"xPos":1096.2330981112354,"yPos":789.0726866139732},{"xPos":1160.9766555783012,"yPos":789.0517944141645},{"xPos":1225.7629821725209,"yPos":789.0501419304882},{"xPos":1290.5526916218319,"yPos":773.0582136757089},{"xPos":1355.342668640516,"yPos":768.4461282881948},{"xPos":1420.1326668227935,"yPos":749.4943359447054},{"xPos":1484.9226666790205,"yPos":744.4806236949503},{"xPos":1549.7126666676504,"yPos":744.0840604930585},{"xPos":1614.5026666667522,"yPos":744.0526940393689},{"xPos":1679.292666666683,"yPos":744.0502130869952},{"xPos":1744.082666666679,"yPos":744.0500168542703},{"xPos":1808.8726666666807,"yPos":744.0500013331007},{"xPos":1872.997066212351,"yPos":744.0500001054426},{"xPos":1987.9280266245262,"yPos":758},{"xPos":1994.7133057269089,"yPos":758},{"xPos":2003.2621900981064,"yPos":758},{"xPos":2025.0200635499023,"yPos":758},{"xPos":2082.389972309239,"yPos":758},
        {"xPos":2146.593074818091,"yPos":758},{"xPos":2211.3366537359307,"yPos":758},{"xPos":2276.1229820268113,"yPos":758},{"xPos":2340.9126916103164,"yPos":758},{"xPos":2405.7026686396107,"yPos":758},{"xPos":2470.492666822723,"yPos":758},{"xPos":2535.2826666790133,"yPos":758},{"xPos":2600.0726666676437,"yPos":758},{"xPos":2664.862666666742,"yPos":758},{"xPos":2729.652666666668,"yPos":758},{"xPos":2794.442666666661,"yPos":758},{"xPos":2859.232666666658,"yPos":758},{"xPos":2924.0226666666554,"yPos":758},{"xPos":2988.8126666666526,"yPos":758},{"xPos":3053.60266666665,"yPos":758},{"xPos":3118.392666666647,"yPos":758},{"xPos":3183.1826666666443,"yPos":758},{"xPos":3247.9726666666415,"yPos":758},{"xPos":3310.0959999999723,"yPos":744},{"xPos":3382.219333333303,"yPos":758},{"xPos":3447.0093333333,"yPos":760.6666666666666},{"xPos":3505.1326666666305,"yPos":749.3333333333333},{"xPos":3575.255999999961,"yPos":754.6666666666666},
        {"xPos":3640.712666666625,"yPos":754.6666666666666},{"xPos":3705.502666666622,"yPos":752},{"xPos":3772.2926666666194,"yPos":753.3333333333333},{"xPos":3848.41599999995,"yPos":756.6666666666666},{"xPos":3907.2059999999474,"yPos":752.6666666666666},{"xPos":3982,"yPos":724},{"xPos":4033.3333333333335,"yPos":693.7166666680288},{"xPos":4060.6666666666665,"yPos":661.716666666667},{"xPos":4063.3333333333335,"yPos":621.0500000000004},{"xPos":4063.3333333333335,"yPos":543.1356880107536},{"xPos":4063.3333333333335,"yPos":479.2179440808018},{"xPos":4006,"yPos":392.54513202563487},{"xPos":3975.3333333333335,"yPos":350.71645051704036},{"xPos":3933.3333333333335,"yPos":303.3833310264359},{"xPos":3880.6666666666665,"yPos":262.7166666451236},{"xPos":3790.3024153611937,"yPos":266.0730993146895},{"xPos":3710.8451278137914,"yPos":263.3833528329425},{"xPos":3583.8295670323014,"yPos":264.7166666716158},{"xPos":3497.8880139926882,"yPos":264.71666666670717},{"xPos":3389.9981777137577,"yPos":263.38333333333355},{"xPos":3237.8306583662466,"yPos":266.05000000000024},{"xPos":3082.892583481355,"yPos":267.38333333333355},{"xPos":2920.086915843062,"yPos":272.7166666666669},{"xPos":2812.8771040515276,"yPos":273.38333333333355},
        {"xPos":2665.6646961309175,"yPos":281.38333333333355},{"xPos":2534.776166371423,"yPos":286.7166666666669},{"xPos":2389.9586813461456,"yPos":275.38333333333355},{"xPos":2254.974481465487,"yPos":275.38333333333355},{"xPos":2085.6619119367233,"yPos":281.38333333333355},{"xPos":1938.8818755104453,"yPos":288.05000000000024},{"xPos":1760.0756912510974,"yPos":298.05000000000024},{"xPos":1240.349553837066,"yPos":265.05000000000024},{"xPos":1183.3283125645912,"yPos":242.38333333333355},{"xPos":1085.6731129783814,"yPos":245.05000000000024},
        {"xPos":1003.7978200724177,"yPos":275.05000000000024},{"xPos":951.0377865437742,"yPos":261.71666680629795},{"xPos":875.978193149433,"yPos":243.05000000030023},{"xPos":766.3905522909068,"yPos":259.0500000000022},{"xPos":665.8429512558963,"yPos":274.38333333333344},{"xPos":579.3525024135563,"yPos":344.38333333333344},{"xPos":452.2408574005513,"yPos":415.95507819639244},{"xPos":373.928283403028,"yPos":523.4245453778697},{"xPos":372.7878952859347,"yPos":609.2456391540254},{"xPos":373.45267361714866,"yPos":735.0507174539042},{"xPos":398.1193335222641,"yPos":815.3833528322928},{"xPos":449.92466666669293,"yPos":842.0000000000005},{"xPos":507.25800000002624,"yPos":846.6666666666671}];
        this.setTrack2 = [{"xPos":852.1537378319043,"yPos":862.6282764074607},{"xPos":885.9584300488362,"yPos":863.0698891553247},{"xPos":919.6296975812608,"yPos":863.0515585519032},{"xPos":978.5151968710644,"yPos":863.049252806018},{"xPos":998.0473269017698,"yPos":841.3997207089777},{"xPos":1033.587120295757,"yPos":839.3308428484839},{"xPos":1096.3440179346367,"yPos":839.0726534243281},{"xPos":1160.985360534176,"yPos":839.0517942083949},{"xPos":1231.8430879319926,"yPos":839.0499868634809},{"xPos":1298.3757366377872,"yPos":822.6278520252945},{"xPos":1364.237459794662,"yPos":817.9394742090666},{"xPos":1429.177030215504,"yPos":798.943930328532},{"xPos":1487.0071509855093,"yPos":794.4688016736038},{"xPos":1549.877786911019,"yPos":794.0839864136567},{"xPos":1614.5157270942273,"yPos":794.0526935759136},{"xPos":1679.2936996910153,"yPos":794.0502130840957},{"xPos":1744.082748384813,"yPos":794.0500168542521},{"xPos":1808.8726727514006,"yPos":794.0500013331006},{"xPos":1869.9737308702188,"yPos":794.0500001633242},{"xPos":1984.9046908055202,"yPos":808},{"xPos":2044.7133057269089,"yPos":808},{"xPos":2053.2621900981067,"yPos":808},{"xPos":2075.0200635499023,"yPos":808},{"xPos":2132.389972309239,"yPos":808},
        {"xPos":2196.593074818091,"yPos":808},{"xPos":2261.3366537359307,"yPos":808},{"xPos":2326.1229820268113,"yPos":808},{"xPos":2390.9126916103164,"yPos":808},{"xPos":2455.7026686396107,"yPos":808},{"xPos":2520.492666822723,"yPos":808},{"xPos":2585.2826666790133,"yPos":808},{"xPos":2650.0726666676437,"yPos":808},{"xPos":2714.862666666742,"yPos":808},{"xPos":2779.652666666668,"yPos":808},
        {"xPos":2844.442666666661,"yPos":808},{"xPos":2909.232666666658,"yPos":808},{"xPos":2974.0226666666554,"yPos":808},{"xPos":3038.8126666666526,"yPos":808},{"xPos":3103.60266666665,"yPos":808},{"xPos":3168.392666666647,"yPos":808},{"xPos":3233.1826666666443,"yPos":808},{"xPos":3253.5368494502404,"yPos":808},{"xPos":3310.8604357009067,"yPos":795.0816621638243},{"xPos":3376.3943980996296,"yPos":807.8025866022698},{"xPos":3450.817587594216,"yPos":810.8657420066877},{"xPos":3508.0740024122874,"yPos":799.7014470946356},{"xPos":3573.357329997795,"yPos":804.6666666666666},{"xPos":3641.7411966356954,"yPos":804.6666666666666},{"xPos":3706.0322783735164,"yPos":802.0205347846756},{"xPos":3770.6997971170777,"yPos":803.3114968796712},{"xPos":3849.021265158182,"yPos":806.7410834296168},{"xPos":3918.0902302061268,"yPos":802.0417151664464},{"xPos":4003.801513383262,"yPos":769.190727327723},{"xPos":4065.929538798416,"yPos":732.5392266217953},{"xPos":4109.472726773275,"yPos":681.5618358197918},{"xPos":4113.333333333334,"yPos":622.687585778899},
        {"xPos":4113.333333333334,"yPos":493.1356880107536},{"xPos":4113.333333333334,"yPos":464.177123032028},{"xPos":4047.0366680807388,"yPos":363.9541275554738},{"xPos":4014.279352452673,"yPos":319.273845300597},{"xPos":3967.6125054722106,"yPos":266.68128710116935},{"xPos":3896.8984335798887,"yPos":212.07928529077037},{"xPos":3790.2201699714024,"yPos":216.04167532815012},{"xPos":3711.428800278833,"yPos":213.3744711488458},{"xPos":3583.567143063332,"yPos":214.71666667160085},{"xPos":3498.196959320705,"yPos":214.71666666672482},{"xPos":3389.8690360353103,"yPos":213.3779193293191},{"xPos":3237.177467244573,"yPos":216.05376972447087},{"xPos":3081.8587678821546,"yPos":217.39037855547477},{"xPos":2919.1127558280286,"yPos":222.72175763795084},{"xPos":2811.364195287829,"yPos":223.39177442552938},{"xPos":2663.290173505368,"yPos":231.43859731900804},{"xPos":2535.7121542321484,"yPos":236.63703681588956},{"xPos":2391.9121805059167,"yPos":225.38333333333355},{"xPos":2254.0888240268714,"yPos":225.38333333333355},{"xPos":2083.64216561295,"yPos":231.423522513203},{"xPos":1936.351509019083,"yPos":238.1133812605741},{"xPos":1760.2645660356598,"yPos":247.96130367516014},
        {"xPos":1251.441465113462,"yPos":215.6535917444513},{"xPos":1192.2425552311029,"yPos":192.12127418367572},{"xPos":1076.1417825932356,"yPos":195.29163338297604},{"xPos":1001.0862322772803,"yPos":222.79280534293184},{"xPos":963.1966743151803,"yPos":213.21748730230732},{"xPos":878.493781310744,"yPos":192.15261591523307},{"xPos":759.0098391127294,"yPos":209.59749437192528},{"xPos":644.9156345872816,"yPos":226.99666104901792},{"xPos":551.1614082077006,"yPos":302.875511655213},{"xPos":418.23481101580455,"yPos":377.7214354787905},{"xPos":324.1442000519296,"yPos":506.84332882106656},{"xPos":322.7861399398643,"yPos":609.0455549616613},{"xPos":323.49230773338,"yPos":742.6833262077067},{"xPos":356.51199275224775,"yPos":850.219503668841},{"xPos":435.93742477579747,"yPos":891.026860209138},{"xPos":503.20164745488796,"yPos":896.5018550783662}];
    
        for(var i = 10; i >= 0; i--)
        {
            var a = this.setTrack1.pop();
            this.setTrack1.unshift(a);

            var a = this.setTrack2.pop();
            this.setTrack2.unshift(a);
        }
    };

    this.loadTracks = function()
    {
        this.setTracksToLoad();
        for(var i = 0; i < this.setTrack1.length; i++)
        {
            this.track.push(this.setTrack1[i]);
        }

        for(var i = 0; i < this.setTrack2.length; i++)
        {
            this.track2.push(this.setTrack2[i]);
        }

        this.track.getPerimeter();
        this.track2.getPerimeter();
    };

    this.addPoint = function()
    {
        this.points.add(this.track[0].xPos, this.track[0].yPos);

        this.track.getPerimeter();
        this.track2.getPerimeter();

        var minimum = Math.min(this.track.perimeter, this.track2.perimeter);
        var maximum = Math.max(this.track2.perimeter, this.track.perimeter);
        self.separation2 = maximum * self.separation / minimum;

        if(this.track2[0])
        {
            this.points2.add(this.track2[0].xPos, this.track2[0].yPos, maximum * this.points[0].speed / minimum);
        }
    };

    this.setupNodes = function()
    {
        this.nodes = [];
        this.nodes.draw = function()
        {
            noStroke();
            fill(255, 255, 255, 80);
            beginShape();
                for(var i = this.length - 1; i >= 0; i--)
                {
                    vertex(this[i].xPos, this[i].yPos);

                    fastRect(this[i].xPos - 4, this[i].yPos - 4, 8, 8);
                }
            endShape(CLOSE);


            noFill();
            strokeWeight(1);
            stroke(255, 255, 255, 200);
            beginShape();
                for(var i = this.length - 1; i >= 0; i-=4)
                {
                    vertex(this[i].xPos, this[i].yPos);
                }
            endShape(CLOSE);

            beginShape();
                for(var i = this.length - 1; i >= 0; i-=2)
                {
                    vertex(this[i].xPos, this[i].yPos);
                }
            endShape(CLOSE);
        };

        this.nodes.getSides = function(pointer)
        {
            var sides = [];
            var ra = physics.formulas.resolveAngle;

            for(var i = 0; i < this.length - 1; i++)
            {
                var point0 = this[i + 1], point1 = this[i];

                var s = physics.formulas.crossProduct(pointer, point1, point0);

                var side = physics.formulas.sign(s);

                var a = degrees(atan2(point1.yPos - point0.yPos, point1.xPos - point0.xPos));

                var n1 = ra(a - ra(degrees(atan2(point0.yPos - pointer.yPos, point0.xPos - pointer.xPos))));
                var n2 = ra(a - ra(degrees(atan2(point1.yPos - pointer.yPos, point1.xPos - pointer.xPos))));
        
                sides[i] = 0;

                if(side > 0)
                {
                    if(n1 < 270 && n2 > 270)
                    {
                        sides[i] = side + 10;
                    }
                }else{
                    if(n1 > 90 && n2 < 90)
                    {
                        sides[i] = side + 10;
                    }
                }
            }

            return sides;
        };
        this.nodes.applyCollision = function(object)
        {
            // Top

            var pointerLeftDown = {
                xPos : object.xPos,
                yPos : object.yPos,
            };

            var pointerRightDown = {
                xPos : object.xPos + object.width,
                yPos : object.yPos,
            };

            var iSides = this.getSides(pointerLeftDown);
            var jSides = this.getSides(pointerRightDown);

            var i = iSides.indexOf(-1 + 10);
            var j = jSides.indexOf(-1 + 10);

            if(i !== -1 && !observer.collisionTypes.rectrect.colliding(object, physics.formulas.createBoundingBoxForLine(this[i + 1], this[i])))
            {
                i = -1;
            }

            if(j !== -1 && !observer.collisionTypes.rectrect.colliding(object, physics.formulas.createBoundingBoxForLine(this[j + 1], this[j])))
            {
                j = -1;
            }

            if(i !== -1 || j !== -1)
            {
                var newPointerLeft = (i === -1) ? false : physics.formulas.closestPointOnLine(pointerLeftDown, this[i], this[i + 1]);
                var newPointerRight = (j === -1) ? false : physics.formulas.closestPointOnLine(pointerRightDown, this[j], this[j + 1]);

                var y1 = Math.max(newPointerLeft ? newPointerLeft.yPos : 0, 
                                  newPointerRight ? newPointerRight.yPos : 0);

                var nXPos = (y1 === newPointerLeft.yPos) ? newPointerLeft.xPos : newPointerRight.xPos - object.width;
                var nYPos = y1;

                var dx = object.xPos - nXPos;
                var dy = object.yPos - nYPos;

                if(dx * dx + dy * dy < self.separation * 0.4)
                {
                    object.xPos = nXPos;
                    object.yPos = max(nYPos, object.yPos);

                    object.yVel = 0;
                    object.inAir = true;

                    object.updateBoundingBox();

                    // return;
                }
            }

            // Bottom

            var pointerLeftDown = {
                xPos : object.xPos,
                yPos : object.yPos + object.height,
            };

            var pointerRightDown = {
                xPos : object.xPos + object.width,
                yPos : object.yPos + object.height,
            };

            var iSides = this.getSides(pointerLeftDown);
            var jSides = this.getSides(pointerRightDown);

            var i = iSides.indexOf(-1 + 10);
            var j = jSides.indexOf(-1 + 10);

            if(i !== -1 && !observer.collisionTypes.rectrect.colliding(object, physics.formulas.createBoundingBoxForLine(this[i], this[i + 1])))
            {
                i = -1;
            }

            if(j !== -1 && !observer.collisionTypes.rectrect.colliding(object, physics.formulas.createBoundingBoxForLine(this[j], this[j + 1])))
            {
                j = -1;
            }

            if(i !== -1 || j !== -1)
            {
                var newPointerLeft = (i === -1) ? false : physics.formulas.closestPointOnLine(pointerLeftDown, this[i], this[i + 1]);
                var newPointerRight = (j === -1) ? false : physics.formulas.closestPointOnLine(pointerRightDown, this[j], this[j + 1]);

                var y1 = Math.min(newPointerLeft ? newPointerLeft.yPos : Infinity, 
                                  newPointerRight ? newPointerRight.yPos : Infinity);

                var nXPos = (y1 === newPointerLeft.yPos) ? newPointerLeft.xPos : newPointerRight.xPos - object.width;
                var nYPos = min(y1 - object.height, object.yPos);

                var dx = object.xPos - nXPos;
                var dy = object.yPos - nYPos;

                if(dx * dx + dy * dy < self.separation * 0.4)
                {
                    object.xPos = nXPos;
                    object.yPos = min(nYPos, object.yPos);

                    object.yVel = Math.min(object.yVel, 1);
                    object.inAir = (object.yVel >= 2);

                    object.updateBoundingBox();
                }
            }
        };

        this.nodes2 = [];
        this.nodes2.getSides = function(pointer)
        {
            var sides = [];
            var ra = physics.formulas.resolveAngle;

            for(var i = 0; i < this.length - 1; i++)
            {
                var point0 = this[i], point1 = this[i + 1];

                var s = physics.formulas.crossProduct(pointer, point1, point0);

                var side = physics.formulas.sign(s);

                var a = degrees(atan2(point1.yPos - point0.yPos, point1.xPos - point0.xPos));

                var n1 = ra(a - ra(degrees(atan2(point0.yPos - pointer.yPos, point0.xPos - pointer.xPos))));
                var n2 = ra(a - ra(degrees(atan2(point1.yPos - pointer.yPos, point1.xPos - pointer.xPos))));
        
                sides[i] = 0;

                if(side > 0)
                {
                    if(n1 < 270 && n2 > 270)
                    {
                        sides[i] = side;
                    }
                }else{
                    if(n1 > 90 && n2 < 90)
                    {
                        sides[i] = side;
                    }
                }
            }

            return sides;
        };
        this.nodes2.applyCollision = function(object)
        {
            // Bottom

            var pointerLeftDown = {
                xPos : object.xPos,
                yPos : object.yPos + object.height,
            };

            var pointerRightDown = {
                xPos : object.xPos + object.width,
                yPos : object.yPos + object.height,
            };

            var iSides = this.getSides(pointerLeftDown);
            var jSides = this.getSides(pointerRightDown);

            var i = iSides.indexOf(1);
            var j = jSides.indexOf(1);

            if(i !== -1 && !observer.collisionTypes.rectrect.colliding(object, physics.formulas.createBoundingBoxForLine(this[i], this[i + 1])))
            {
                i = -1;
            }

            if(j !== -1 && !observer.collisionTypes.rectrect.colliding(object, physics.formulas.createBoundingBoxForLine(this[j], this[j + 1])))
            {
                j = -1;
            }

            if(i !== -1 || j !== -1)
            {
                var newPointerLeft = (i === -1) ? false : physics.formulas.closestPointOnLine(pointerLeftDown, this[i], this[i + 1]);
                var newPointerRight = (j === -1) ? false : physics.formulas.closestPointOnLine(pointerRightDown, this[j], this[j + 1]);

                var y1 = Math.min(newPointerLeft ? newPointerLeft.yPos : Infinity, 
                                  newPointerRight ? newPointerRight.yPos : Infinity);

                var nXPos = (y1 === newPointerLeft.yPos) ? newPointerLeft.xPos : newPointerRight.xPos - object.width;
                var nYPos = y1 - object.height;

                var dx = object.xPos - nXPos;
                var dy = object.yPos - nYPos;

                if(dx * dx + dy * dy < self.separation * 0.4)
                {
                    object.xPos = nXPos;
                    object.yPos = min(nYPos, object.yPos);

                    object.yVel = Math.min(object.yVel, 1);
                    object.inAir = (object.yVel >= 2);

                    object.updateBoundingBox();

                    return;
                }
            }

            // Top

            var pointerLeftDown = {
                xPos : object.xPos,
                yPos : object.yPos,
            };

            var pointerRightDown = {
                xPos : object.xPos + object.width,
                yPos : object.yPos,
            };

            var iSides = this.getSides(pointerLeftDown);
            var jSides = this.getSides(pointerRightDown);

            var i = iSides.indexOf(1);
            var j = jSides.indexOf(1);

            if(i !== -1 && !observer.collisionTypes.rectrect.colliding(object, physics.formulas.createBoundingBoxForLine(this[i + 1], this[i])))
            {
                i = -1;
            }

            if(j !== -1 && !observer.collisionTypes.rectrect.colliding(object, physics.formulas.createBoundingBoxForLine(this[j + 1], this[j])))
            {
                j = -1;
            }

            if(i !== -1 || j !== -1)
            {
                var newPointerLeft = (i === -1) ? false : physics.formulas.closestPointOnLine(pointerLeftDown, this[i], this[i + 1]);
                var newPointerRight = (j === -1) ? false : physics.formulas.closestPointOnLine(pointerRightDown, this[j], this[j + 1]);

                var y1 = Math.max(newPointerLeft ? newPointerLeft.yPos : 0, 
                                  newPointerRight ? newPointerRight.yPos : 0);

                var nXPos = (y1 === newPointerLeft.yPos) ? newPointerLeft.xPos : newPointerRight.xPos - object.width;
                var nYPos = y1;

                var dx = object.xPos - nXPos;
                var dy = object.yPos - nYPos;

                if(dx * dx + dy * dy < self.separation * 0.4)
                {
                    object.xPos = nXPos;
                    object.yPos = max(nYPos, object.yPos);

                    object.yVel = 0;
                    object.inAir = true;

                    object.updateBoundingBox();
                }
            }
        };
    };

    this.createNodes = function()
    {
        for(var i = 8 - 1; i >= 0; i--)
        {
            this.nodes.push({
                xPos : 800 + i * 60,
                yPos : 630 + random(-10, 10)
            });
        }

        this.nodes.push({
            xPos : 760,
            yPos : 645
        });

        this.nodes2.push({
            xPos : 760,
            yPos : 645
        });

        for(var i = 0; i < 8; i++)
        {
            this.nodes2.push({
                xPos : 800 + i * 60,
                yPos : 690 + random(-10, 10)
            });
        }
    };

    (() =>
    {
        this.createTracks();
        this.loadTracks();

        this.setupPoints();

        this.setupNodes();
        // this.createNodes();
    })();

    this.connectNodesToPoints = function()
    {
        this.nodes.length = 0;

        for(var i = this.points2.length - 1; i >= 0; i--)
        {
            this.nodes.push(this.points2[i]);
        }

        this.nodes2.length = 0;

        for(var i = 0; i < this.points.length; i++) 
        {
            this.nodes2.push(this.points[i]);
        }
    };

    var DEG_TO_RAD = (Math.PI / 180);

    this.connectHead = function()
    {
        var point0 = this.nodes[this.nodes.length - 1];
        var point1 = this.nodes2[0];

        if(!point0 || !point1)
        {
            return;
        }

        var angle = atan2(point1.yPos - point0.yPos, point1.xPos - point0.xPos);

        var angle_offset = 75 * DEG_TO_RAD;

        var a0 = angle - Math.PI / 2 - angle_offset, 
            a1 = angle - Math.PI / 2 + angle_offset;

        var s = 150;

        var point = o_intersect(point0.xPos, point0.yPos, 
                    point0.xPos - cos(a0) * s, point0.yPos - sin(a0) * s, 

                    point1.xPos, point1.yPos, 
                    point1.xPos - cos(a1) * s, point1.yPos - sin(a1) * s);

        try{
            this.xPos = point.x - this.halfWidth;
            this.yPos = point.y - this.halfHeight;
        }
        catch(e)
        {

        }

        // stroke(255, 255, 255, 100);
        // strokeWeight(2);

        // line(point0.xPos, point0.yPos, 
        //     point0.xPos - cos(a0) * s, point0.yPos - sin(a0) * s);

        // line(point1.xPos, point1.yPos, 
        //     point1.xPos - cos(a1) * s, point1.yPos - sin(a1) * s);

        this.updateBoundingBox();
    };

    this.drawTail = function()
    {
        if(this.points2.length === 0 || this.points2.length === 0)
        {
            return;
        }

        var point0, point1;

        if(this.toPoint1)
        {
            point0 = this.toPoint1;
        }
        if(this.toPoint2)
        {
            point1 = this.toPoint2;
        }

        if(!point0 || !point1)
        {
            return;
        }

        var angle = atan2(point1.yPos - point0.yPos, point1.xPos - point0.xPos);

        var angle_offset = 30 * DEG_TO_RAD;

        var a0 = angle - Math.PI / 2 - Math.PI + angle_offset, 
            a1 = angle - Math.PI / 2 - Math.PI - angle_offset;

        var s = 150;

        var point = o_intersect(point0.xPos, point0.yPos, 
                    point0.xPos - cos(a0) * s, point0.yPos - sin(a0) * s, 

                    point1.xPos, point1.yPos, 
                    point1.xPos - cos(a1) * s, point1.yPos - sin(a1) * s);

        point.xPos = point.x;
        point.yPos = point.y;

        stroke(255, 255, 255, 100);
        strokeWeight(2);

        line(point0.xPos, point0.yPos, 
            point0.xPos - cos(a0) * s, point0.yPos - sin(a0) * s);

        line(point1.xPos, point1.yPos, 
            point1.xPos - cos(a1) * s, point1.yPos - sin(a1) * s);

        noStroke();
        fill(255, 255, 255, 80);
        triangle(point0.xPos, point0.yPos, point1.xPos, point1.yPos, point.xPos, point.yPos);

        this.tailPoint = point;
    };

    this.allNodes = [];
    var option = observer.collisionTypes["pointpolygon"];

    this.colliding = function(object)
    {
        var oNodes = [{
            xPos : object.boundingBox.xPos,
            yPos : object.boundingBox.yPos
        }, {
            xPos : object.boundingBox.xPos + object.boundingBox.width,
            yPos : object.boundingBox.yPos
        }, {
            xPos : object.boundingBox.xPos,
            yPos : object.boundingBox.yPos + object.boundingBox.height
        }, {
            xPos : object.boundingBox.xPos + object.boundingBox.width,
            yPos : object.boundingBox.yPos + object.boundingBox.height
        }];

        var obj = { 
            points: this.allNodes 
        };
        return oNodes.some(function(element)
        {
            return option.colliding(element, obj);
        });
    };

    this.applyCollision = function(object)
    {
        if(this.colliding(object))
        {
            this.nodes.applyCollision(object);
            this.nodes2.applyCollision(object);
        }
    };

    var loops = 0;

    this.draw = function(isRemote)
    {
        if(!isRemote)
        {
            return;
        }

        var nodes = this.nodes.concat(this.nodes2);
        nodes.draw = this.nodes.draw;
        nodes.draw();

        this.allNodes = nodes;

        // this.track.draw();
        // this.track2.draw();

        this.points.draw();
        this.points2.draw();

        this.drawTail();

        stroke(0, 53, 186, 200);
        strokeWeight(0.1);

        var l = Math.min(this.points.length, this.points2.length);
        for(var i = 0; i < l; i++)
        {
            line(this.points[i].xPos, this.points[i].yPos, this.points2[i].xPos, this.points2[i].yPos);
        }

        noStroke();

        if(this.points.length < this.dragonLength && loops + this.time_offset - this.lastPointAddTime > 60)
        {
            this.addPoint();

            this.lastPointAddTime = loops + this.time_offset;
        }
        loops++;


        $pjs.pushMatrix();

        var right = this.xPos + this.width;

        if(this._lastXPos_ - this.xPos > 0)
        {
            translate(right, this.yPos);
            scale(-1, 1);
            translate(-this.xPos, -this.yPos);
        }

        this._lastXPos_ = this.xPos;

        // Ears

        fill(255, 255, 255, 240);
        noStroke();

        triangle(this.xPos, this.yPos + 5, this.xPos + 30 / 2, this.yPos - 18, this.xPos + 30, this.yPos + 5);

        /* Head */

         strokeWeight(2);
        fill(255, 255, 255, 240);
        stroke(255, 255, 255);

        $pjs.rect(this.xPos, this.yPos, this.width, this.height, 5);
        noStroke();

        // Eye
        this.eyeAngle = atan2((mouseY + cam.focusYPos - cam.halfHeight) - this.yPos, (mouseX + cam.focusXPos - cam.halfWidth) - this.xPos);

        var _size = 16;
        var _sub_size = 5;

        var _x = this.xPos + 23;
        var _y = this.yPos + 14;

        noStroke();
        fill(170, 170, 170, 200);
        circle(_x + cos(this.eyeAngle) * 4.4, 
                _y + sin(this.eyeAngle) * 4.4, _sub_size);

        strokeWeight(2);
        stroke(0, 0, 130, 100);
        noFill();
        circle(_x, _y, _size);

        // Mouth
        strokeWeight(0.1);
        stroke(0, 0, 0, 100);

        var _v = 10;
        var _v_half = _v * 0.5;
        var _h = 4;

        var int = 1;

        var y = this.yPos + this.halfHeight + 10;

        var i = 0;
        for(var x = this.xPos + 80; x < right; x += _v)
        {
            fill(20, 20 + (4 - (++i)) * 30, 123, 100 + loops % 60);

            if(int === 1)
            {
                triangle(x, y + _h, 
                        x + _v_half, y, 
                        x + _v, y + _h);
            }else{
                triangle(x, y, 
                        x + _v_half, y + _h, 
                        x + _v, y);
            }

            int = -int;
        }

        y += 2;

        var i = 0;
        for(var x = this.xPos + 80; x < right; x += _v)
        {
            fill(20, 20 + (4 - (++i)) * 30, 123, 100 + loops % 60);

            if(int === 1)
            {
                triangle(x, y + _h, 
                        x + _v_half, y, 
                        x + _v, y + _h);
            }else{
                triangle(x, y, 
                        x + _v_half, y + _h, 
                        x + _v, y);
            }

            int = -int;
        }


        // Nose
        stroke(128, 128, 128);

        var y = this.yPos;
        for(var x = this.xPos + 86; x < right; x += 14)
        {
            line(x, y, x, y + 10);
        }

        $pjs.popMatrix();
    };

    var last_loop = 0;

    var _lastUpdate = this.update;
    this.update = function(isRemote)
    {
        if(!isRemote)
        {
            return;
        }

        _lastUpdate.apply(this, arguments);

        this.connectNodesToPoints();

        this.toPoint1 = this.nodes[0];
        this.toPoint2 = this.nodes2[this.nodes.length - 1];

        if(this.tailPoint)
        {
            this.nodes.unshift(this.tailPoint);
            this.nodes2.push(this.tailPoint);
        }

        this.points.update(this.track);
        this.points2.update(this.track2);

        // if(this.points.length > 0 && this.points2.length > 0)
        // {
            // this.points2[this.points2.length - 1].xPos = this.points[this.points.length - 1].xPos;
            // this.points2[this.points2.length - 1].yPos = this.points[this.points.length - 1].yPos;
        // }

        // All this coding work for this?
        if(this.points[0] && this.points2[0] && loops - last_loop > 30)
        {
            var p1 = Math.min(this.track.perimeter, this.track2.perimeter);
            var p2 = Math.max(this.track2.perimeter, this.track.perimeter);

            for(var i = 0; i < this.points.length/* - 1*/; i++)
            {
                var point = this.track2.putPointAlong(this.track.getDistAlong(this.points[i], this.points[i].index) / p1 * p2 + 100);

                this.points2[i].xPos = point.xPos;
                this.points2[i].yPos = point.yPos;
            }

            last_loop = loops;
        }

        this.connectHead();

        this.updateBoundingBox();

        if(this.hp <= 0)
        {
            this.remove();
        }
    };

    this.time_offset = random(-500, 500);
    this.lastPointAddTime = 0;

    this.keepTrackofPoints2 = function(index)
    {
        var point = this.track2.putPointAlong(this.track.getDistAlong(this.points[index], this.points[index].index) / this.track.perimeter * this.track2.perimeter);

        this.points2[index].xPos = point.xPos;
        this.points2[index].yPos = point.yPos;
    };

    this.onCollide = function(object)
    {
        // Just an override, still this function is unused.

        if(object.arrayName === "spike")
        {
            this.hp -= 2;
        }
    };

    var _lastRemove = this.remove;
    this.remove = function()
    { 
        if(!this.addedHeart && player.maxHp < 20)
        {
            gameObjects.getObject("heart").add(
                this.xPos + this.halfWidth,
                levelInfo.yPos + levelInfo.height - 400, 
                levelInfo.unitWidth, 5);

            var heart = gameObjects.getObject("heart").getLast();

            heart.falling = true;
            heart.gravity = 5;

            heart.minimumYPos = levelInfo.yPos + levelInfo.height - 200;

            cameraGrid.addReference(heart);

            this.addedHeart = true;
        }

        _lastRemove.apply(this, arguments);

        this.draw = function() {};
        this.update = function() {};
        this.onCollide = function() {};
        this.remove = function() {};
    };
};
gameObjects.addObject("iceDragon", createArray(IceDragon));

// One of Talon's minions
var CaptainFleep = function(xPos, yPos, diameter)
{
    DynamicCircle.call(this, xPos, yPos, diameter);
    LifeForm.call(this, 36);
    this.scoreValue = 2600;
    this.isBoss = true;

    this.gravity = 0;

    this.messages = {
        up : true,
        "start" : {
            message : "What do think you're doing here boy?",
            choices : {
                "igetit" : "I have no Idea",
                "igetit2" : "nothing"
            }
        },
        "igetit" : {
            message : "I get it! you haven't seen a human in\na very long time.",
            choices : {
                "next" : "..."
            }
        },
        "igetit2" : {
            message : "I get it! you haven't seen a human in\na very long time.",
            choices : {
                "next" : "..."
            }
        },
        "next" : {
            message : "Well whatever, but I was sent by Talon to\nguard this location!",
            choices : {
                "here" : "..."
            }
        },
        "here" : {
            message : "You'll never be able to pass this location,\nunless you want to showdown you here?",
            choices : {
                "here2" : "..."
            }
        },
        "here2" : {
            message : "I will not let Talon down!",
            choices : {
                "exit" : "..."
            }
        }
    };

    var len, a;
    var pPoint = {
        x: 0,
        y: 0
    };

    len = this.diameter + 9;
    var l = len - 7;
    var bAngle;

    this.angles = [atan2(7, this.radius), atan2(4.4, l)];

    var third = 120 * DEG_TO_RAD;

    this.turn = 1;
    this.msTime = 0;

    this.draw = function()
    {
        a = (this.msTime * this.turn / 10) % 360;
        this.ang = a * DEG_TO_RAD;

        noStroke();

        // fill(23, 84, 146);
        fill(23, 40, 146);

        beginShape();
            vertex(this.xPos + cos(this.ang - this.angles[0]) * this.radius, this.yPos + sin(this.ang - this.angles[0]) * this.radius);
            vertex(this.xPos + cos(this.ang + this.angles[0]) * this.radius, this.yPos + sin(this.ang + this.angles[0]) * this.radius);
            vertex(this.xPos + cos(this.ang + this.angles[1]) * l, this.yPos + sin(this.ang + this.angles[1]) * l);
            vertex(this.xPos + cos(this.ang - this.angles[1]) * l, this.yPos + sin(this.ang - this.angles[1]) * l);
        endShape(CLOSE);

        this.ang += third;
        beginShape();
            vertex(this.xPos + cos(this.ang - this.angles[0]) * this.radius, this.yPos + sin(this.ang - this.angles[0]) * this.radius);
            vertex(this.xPos + cos(this.ang + this.angles[0]) * this.radius, this.yPos + sin(this.ang + this.angles[0]) * this.radius);
            vertex(this.xPos + cos(this.ang + this.angles[1]) * l, this.yPos + sin(this.ang + this.angles[1]) * l);
            vertex(this.xPos + cos(this.ang - this.angles[1]) * l, this.yPos + sin(this.ang - this.angles[1]) * l);
        endShape(CLOSE);

        this.ang += third;
        beginShape();
            vertex(this.xPos + cos(this.ang - this.angles[0]) * this.radius, this.yPos + sin(this.ang - this.angles[0]) * this.radius);
            vertex(this.xPos + cos(this.ang + this.angles[0]) * this.radius, this.yPos + sin(this.ang + this.angles[0]) * this.radius);
            vertex(this.xPos + cos(this.ang + this.angles[1]) * l, this.yPos + sin(this.ang + this.angles[1]) * l);
            vertex(this.xPos + cos(this.ang - this.angles[1]) * l, this.yPos + sin(this.ang - this.angles[1]) * l);
        endShape(CLOSE);

        // fill(23, 40, 146);
        // circle(this.xPos, this.yPos, this.diameter);

        // stroke(2, 93, 140);
        // fill(2, 102, 140);
        // circle(this.xPos - 4.4, this.yPos - 4, 4);
        // circle(this.xPos + 4.4, this.yPos - 4, 4);

        if(this.state === "circle")
        {
            this.imageName = "captainFleepAngryTeeth";
        }
        else if(this.state === "follow") 
        {
            this.imageName = "captainFleepTeeth";
        }else{
            this.imageName = "captainFleep";
        }

        if(this.overrideCircle)
        {
            this.imageName = "captainFleepAngryTeeth";
        }

        image(loadedImages[this.imageName], this.xPos - this.radius * 1.5, this.yPos - this.radius * 1.5 - 1, this.diameter * 1.5, this.diameter * 1.5);
    };

    this.lastTakeDamageTime = millis();

    var _lastTakeDamage = this.takeDamage;
    this.takeDamage = function()
    {
        _lastTakeDamage.apply(this, arguments);

        this.lastTakeDamageTime = millis();
    };

    this.lastFollowTime = millis();

    this.state = "move";
    this.lastYDir = "";

    this.dirUpTime = millis();

    var yLine = (levelInfo.yPos + levelInfo.height) * 0.54;
    var yLineMiddle = levelInfo.yPos + levelInfo.height / 2;

    this.actionAngle = 0;

    this.talked = false;

    var _lastUpdate = this.update;
    this.update = function(remote)
    {
        if(!remote)
        {
            return;
        }

        if(!this.talked)
        {
            talkHandler.start(this.messages, "start");
            this.talked = true;
        }

        if(!messageHandler.active)
        {
            _lastUpdate.apply(this, arguments);

            this.stepEmitters();
        }

        a = (this.msTime * this.turn / 10) % 360;

        for(var i = 0; i < this.launchBalls.length; i++)
        {
            // We wouldn't want to lose a launchBall
            cameraGrid.removeReference(this.launchBalls[i]);
            cameraGrid.addReference(this.launchBalls[i]);

            if(this.launchBalls[i].useRemote = (this.launchBalls[i].mode === "rotate"))
            {
                this.launchBalls[i].update(true);
            }

            a = (a + 120) % 360;
            this.ang = a * DEG_TO_RAD;
            if(this.launchBalls[i].mode === "rotate")
            {
                this.launchBalls[i].xPos = this.xPos + cos(this.ang) * len;
                this.launchBalls[i].yPos = this.yPos + sin(this.ang) * len;
            }
        }

        noStroke();

        if(messageHandler.active)
        {
            return;
        }

        this.msTime += 40 * this.turn;

        this.redHp = this.maxHp * 30 / 100;
        if(this.hp < this.redHp && !this.overrideCircle)
        {
            this.xSpeed = 4;
            this.ySpeed = 4;
            this.msTime += 40 * this.turn;
            this.forceShootInterval = 360;
            this.state = "circle";
        }

        switch(this.state)
        {
            case "move" :
                if(this.hs)
                {
                    var hookShot = this.hs;

                    if(!this.yDir && Math.pow(hookShot.ox - this.xPos, 2) + Math.pow(hookShot.oy - this.yPos, 2) < 100 * 100)
                    {
                        this.yDir = "up";
                        
                        this.emit([], 500, function()
                        {
                            this.yDir = "";
                        }); 

                        this.emit([], 8000, function()
                        {   
                            this.yDir = "down";
                        });
                    }
                }

                if(this.returnToYLine)
                {
                    this.yPos -= (this.yPos - yLine) * 0.225;

                    if(abs(this.yPos - yLine) < 2)
                    {
                        this.yPos = yLine;
                        this.returnToYLine = false;
                    }
                }
                else if(this.yPos > yLine)
                {
                    this.yPos = yLine;

                    if(this.yDir === "down")
                    {
                        this.yDir = "";
                    }
                }

                if(this.lastYDir !== this.yDir)
                {
                    if(this.yDir === "up")
                    {
                        this.dirUpTime = millis();

                        this.emit([], 15000, function()
                        { 
                            this.returnToYLine = true;
                        });
                    }
                }

                this.lastYDir = this.yDir;

                // this.keyUp = (player.yVel < 0 && player.controls.up() && player.yPos < this.yPos && this.yPos - player.yPos < 50);

                if(millis() - this.lastFollowTime > 20000 && millis() - this.lastTakeDamageTime > 2000)
                {
                    this.state = "follow";
                    this.shootInterval = 500;

                    this.emit([], 8000, function() 
                    {
                        this.returnToYLine = true;
                        this.state = "move";
                        this.shootInterval = 750;
                        this.yDir = "";
                    });

                    this.lastFollowTime = millis();
                }
                break;

            case "follow" :
                var dx = player.xPos - this.xPos;
                var dy = player.yPos - this.yPos;

                var angle = atan2(dy, dx);
                var speed = 7;

                this.xVel = cos(angle) * speed;
                this.yVel = sin(angle) * speed;
                return;

            case "circle" :
                this.actionAngle += 2.5 * DEG_TO_RAD;
                this.actionAngle %= TWO_PI;

                var speed = 5;

                // Go crazy
                var _angle = this.actionAngle + random(-1, 1) * DEG_TO_RAD;

                this.xPos += cos(_angle) * speed;
                this.yPos += sin(_angle) * speed;

                this.yPos -= (this.yPos - yLineMiddle) * 0.015;

                if(abs(this.yPos - yLineMiddle) < 2)
                {
                    this.yPos = yLineMiddle;
                    this.returnToYLine = false;
                }

                if(this.yPos < 400 && (!this.lastStayOffCeiling || millis() - this.lastStayOffCeiling > 3000))
                {
                    this.state = "follow";
                    this.overrideCircle = true;

                    this.emit([], 500, function()
                    {
                        this.state = "circle";
                        this.overrideCircle = false;
                    });

                    this.lastStayOffCeiling = millis();
                }
                return;
        }

        if(this.controls.left())
        {
            this.xVel = -this.xSpeed;
        }
        else if(this.controls.right())
        {
            this.xVel = this.xSpeed;
        }
        if(this.controls.up())
        {
            this.yVel = -this.ySpeed;
        }
        else if(this.controls.down())
        {
            this.yVel = this.ySpeed;
        }
    };

    this.xSpeed = 2;
    this.ySpeed = 2;

    this.xDir = random(0, 10) < 5 ? "left" : "right";
    this.yDir = "";

    var self = this;
    this.controls = {
        left : function() 
        {
            return (self.xDir === "left" || self.keyLeft);
        },
        right : function() 
        {
            return (self.xDir === "right" || self.keyRight);
        },
        up : function() 
        {  
            return (self.yDir === "up" || self.keyUp);
        },
        down : function()
        {
            return (self.yDir === "down" || self.keyDown);
        },
    };

    this.launchBalls = [];

    this.colors = [color(38, 140, 68, 100), color(34, 43, 146, 100), color(168, 45, 20, 100)];
    this.maxGrowth = 100;

    this.shootInterval = 750;

    this.toSetAfter = true;
    this.setAfter = function()
    {
        this.addLaunchBall(0);
        this.addLaunchBall(1);
        this.addLaunchBall(2);

        // You can really do a lot with emitters, including loops!
        this.emit([], this.shootInterval, function launch()
        {
            var closest = Infinity;
            var dist;
            var closestIndex = 0;

            var dx, dy;
            for(var i = 0; i < this.launchBalls.length; i++)
            {
                dx = player.xPos - this.launchBalls[i].xPos;
                dy = player.yPos - this.launchBalls[i].yPos;

                if(closest > (dist = dx * dx + dy * dy))
                {
                    closest = dist;
                    closestIndex = i;
                }
            }

            this.tryToLaunchBall(closestIndex, 1000, 14);

            this.emit([], this.forceShootInterval || this.shootInterval, launch);
        });

        this.emit([], 1500, function change()
        {
            if(random(0, 100) < 10)
            {
                this.turn = -this.turn;
            }

            this.emit([], 1500, change);
        });
    };

    this.tryToLaunchBall = function(index, regenTime, speed)
    {
        var ball = this.launchBalls[index];

        if(ball && ball.growth >= ball.maxGrowth && ball.mode === "rotate")
        {
            var angle = atan2(player.yPos + player.halfHeight - ball.yPos, player.xPos + player.halfWidth - ball.xPos);
            ball.setXVel = cos(angle) * speed;
            ball.setYVel = sin(angle) * speed;
            ball.mode = "launch";
            ball.maxGrowth = this.maxGrowth;
            ball.homing = true;
            ball.speed = speed;
            ball.maxCorrections = 2;
            ball.correctionInterval = 520;

            this.emit([index], regenTime, this.addLaunchBall);

            // Just a little bit of a course correction.
            // this.emit([], 140, function()
            // {
            //     if(ball.mode === "launch")
            //     {
            //         var angle = atan2(player.yPos + player.halfHeight - ball.yPos, player.xPos + player.halfWidth - ball.xPos);
            //         ball.setXVel = cos(angle) * speed;
            //         ball.setYVel = sin(angle) * speed;
            //     }
            // });

            // this.emit([], 230, function()
            // {
            //     if(ball.mode === "launch")
            //     {
            //         var angle = atan2(player.yPos + player.halfHeight - ball.yPos, player.xPos + player.halfWidth - ball.xPos);
            //         ball.setXVel = cos(angle) * speed;
            //         ball.setYVel = sin(angle) * speed;
            //     }
            // });

            // this.emit([], 350, function()
            // {
            //     if(ball.mode === "launch")
            //     {
            //         var angle = atan2(player.yPos + player.halfHeight - ball.yPos, player.xPos + player.halfWidth - ball.xPos);
            //         ball.setXVel = cos(angle) * speed;
            //         ball.setYVel = sin(angle) * speed;
            //     }
            // });

            // this.emit([], 500, function()
            // {
            //     if(ball.mode === "launch")
            //     {
            //         var angle = atan2(player.yPos + player.halfHeight - ball.yPos, player.xPos + player.halfWidth - ball.xPos);
            //         ball.setXVel = cos(angle) * speed;
            //         ball.setYVel = sin(angle) * speed;
            //     }
            // });

            return true;
        }

        return false;
    };

    this.addLaunchBall = function(index)
    {
        var item = gameObjects.getObject("launchBall").add(this.xPos, this.yPos, 10, this.colors[index % 3], 3);
        item.useRemote = true;

        if(!player.frozen && player.gooedTimer <= 0 && player.redHurtTime <= 0)
        {
            switch(index % 3)
            {
                // Green (goo)
                case 0 :
                    item.addEffect = function(object)
                    {
                        object.gooedTimer = 60 * 7;
                    };
                    break;

                // Blue (freeze)
                case 1 : 
                    item.addEffect = function(object)
                    {
                        object.accume = 1;
                    };
                    break;

                // Red (damage)
                case 2 :
                    item.addEffect = function(object)
                    {
                        object.redHurtTime = object.maxRedHurtTime;
                    };
                    break;
            }
        }

        item.maxGrowth = this.maxGrowth;
        cameraGrid.addReference(item);
        item.hostObject = this;

        this.launchBalls.splice(index, 1, item);
    };

    this.emitters = [];
    this.stepEmitters = function()
    {
        for(var i = this.emitters.length - 1; i >= 0; i--)
        {
            if(millis() - this.emitters[i].startTime > this.emitters[i].time)
            {
                this.emitters[i].func.apply(this, this.emitters[i].info);
                this.emitters.splice(i, 1);
            }
        }
    };
    this.emit = function(info, time, func)
    {
        this.emitters.push({
            info : info,
            time : time,
            func : func,
            startTime : millis()
        });
    };

    var _lastRemove = this.remove;
    this.remove = function()
    {
        for(var i = 0; i < this.launchBalls.length; i++)
        {
            this.launchBalls[i].remove();
        }

        _lastRemove.apply(this, arguments);
    };

    this.avoidCollision = function(object)
    {
        return object.arrayName === "launchBall";
    };

    var hitTimes = 0;
    var lastHitTime = millis();

    var lastDamageTime = millis();

    this.lastChoiceTime = millis();
    this.onCollide = function(object, info)
    {
        if(object.arrayName === "xStar" && millis() - lastHitTime > 350)
        {
            hitTimes++;

            if(hitTimes > 3)
            {
                this.yDir = "up";

                this.emit([], 500, function()
                {
                    this.yDir = "";
                }); 

                this.emit([], 5000, function()
                {   
                    this.yDir = "down";

                    this.emit([], 500, function()
                    {
                        this.yDir = "";
                    }); 
                });

                hitTimes = 0;
            }

            lastHitTime = millis();
        }   
        else if(object.physics.solidObject && object.physics.shape === "rect" && object.physics.movement === "static")
        {
            if(millis() - this.lastChoiceTime > 200 && this.yPos + this.radius - 3 > object.yPos && this.yPos - this.radius + 3 < object.yPos + object.height)
            {
                if(this.xDir === "left" && this.xVel < 0)
                {
                    this.xDir = "right";
                }
                else if(this.xDir === "right" && this.xVel > 0)
                {
                    this.xDir = "left";
                }

                this.lastChoiceTime = millis();
            }
        }
        else if(object.arrayName === "xStar")
        {
            this.takeDamage(object);
        }
        else if(object.arrayName === "player" && millis() - lastDamageTime > 1000 && object.yPos + object.height - object.yVel <= this.yPos - this.radius)
        {
            object.yVel = -8;
            this.takeDamage(object, object.damage * 2);

            lastDamageTime = millis();
        }   

        // We don't want to push the player into the ground!
        if(object.arrayName === "player" && this.state === "follow" && this.yPos < object.yPos)
        {
            this.emit([], 500, function()
            {
                this.returnToYLine = true;
                this.state = "move";
                this.shootInterval = 1000;
                this.yDir = "";
            });
        }
    };

    var _lastRemove2 = this.remove;
    this.remove = function()
    { 
        if(!this.addedHeart && player.maxHp < 25)
        {
            gameObjects.getObject("heart").add(
                levelInfo.xPos + levelInfo.width * 0.5,
                levelInfo.yPos + levelInfo.height * 0.5, 
                levelInfo.unitWidth, 5);

            var heart = gameObjects.getObject("heart").getLast();

            heart.falling = true;
            heart.gravity = 5;

            heart.minimumYPos = levelInfo.yPos + levelInfo.height - 200;

            cameraGrid.addReference(heart);

            this.addedHeart = true;
        }

        _lastRemove2.apply(this, arguments);

        this.draw = function() {};
        this.update = function() {};
        this.onCollide = function() {};
        this.remove = function() {};
    };
};
gameObjects.addObject("captainFleep", createArray(CaptainFleep));

var XStar = function(xPos, yPos, diameter, colorValue)
{
    Circle.call(this, xPos, yPos, diameter);
    this.colorValue = colorValue;

    this.physics.movement = "dynamic";
    this.physics.solidObject = false;

    this.outerXVel = 0;
    this.outerYVel = 0;

    this.damage = 1;

    this.life = 200;

    this.blocked = false;

    this.imageName = "ninjaStar";
    this.setAngle = 0;
    this.setAngleVel = 3;

    this.explosive = true;

    this.draw = function()
    {
        $pjs.pushMatrix();
        translate(this.xPos, this.yPos);
        rotate(this.setAngle);
        image(storedImages[this.imageName], -this.radius, -this.radius, this.diameter, this.diameter);
        $pjs.popMatrix();

        this.setAngle += 3;

        noStroke();
        fill(31, 89, 235, 170);
        circle(this.xPos, this.yPos, this.radius * 1.1);
    };

    this.updateBoundingBox = function()
    {
        this.boundingBox.xPos = this.xPos - this.radius;
        this.boundingBox.yPos = this.yPos - this.radius;
    };

    this.lastUpdate1 = this.update;
    this.update = function()
    {
        this.lastUpdate1();
        this.xPos += this.outerXVel2 || 0;
        this.yPos += this.outerYVel2 || 0;  

        this.updateBoundingBox();   

        this.life--;
        if(this.life < 0)
        {
            this.remove();
            this.onCollide = function() {};
        }       
    };

    this.blockedObjects = [];

    this.onCollide = function(object, info)
    {
        if(object.physics.solidObject && object.arrayName !== "fallingBlock" && object.physics.movement === "static")
        {
            this.onCollide = function() {};
            this.remove();
        }
        else if(object.isLifeForm && object.arrayName !== "player" && this.blockedObjects.indexOf(object.arrayName + object.index) === -1)
        {
            var blocked = object.takeDamage(this);

            if(!blocked)
            {
                this.onCollide = function(){};
                this.remove(object);
            }else{
                var d = Math.sqrt(Math.pow(this.outerYVel2, 2) + Math.pow(this.outerXVel2, 2));
                var a = atan2(this.outerYVel2, 
                              this.outerXVel2);

                a += PI;
                d *= 1.1;

                this.outerXVel2 = cos(a) * d;
                this.outerYVel2 = sin(a) * d;

                this.blockedObjects.push(object.arrayName + object.index);
            }
        }
    };

    this.activate = function(object)
    {
        return object.arrayName === "lever";
    };
};
gameObjects.addObject("xStar", createArray(XStar));

var Point = function(xPos, yPos, diameter)
{
    Circle.call(this, xPos, yPos, diameter);

    this.physics.solidObject = false;

    this.draw = function()
    {   
        noStroke();
        fill(125, 125, 125);
        circle(this.xPos, this.yPos, this.diameter);

        noFill();
        stroke(0, 0, 0);
        $pjs.rect(this.xPos - this.diameter / 2 - 1 + 4, this.yPos - this.diameter / 2 - 1 + 4, this.diameter - 8, this.diameter - 8);
    };
};

gameObjects.addObject("point", createArray(Point));

//Npc (Non playable character)
var Npc = function(xPos, yPos, width, height, colorValue)
{
    DynamicRect.call(this, xPos, yPos, width, height);
    this.color = colorValue || color(250, 250, 250, 150);

    this.message = "hi";
    this.messagePattern = {
        "hi" : {
            message : "Hi",
        },
    };

    this.showName = false;

    this.lastUpdate2 = this.update;
    this.update = function()
    {
        if(!this.setSize && storedImages.npcs[this.img] !== undefined)
        {
            this.yPos -= abs(storedImages.npcs[this.img].inputHeight - this.height);
            this.height = storedImages.npcs[this.img].inputHeight;
            this.width = storedImages.npcs[this.img].inputWidth;
            this.boundingBox.width = this.width;
            this.boundingBox.height = this.height;
            this.setSize = true;
        }
        this.lastUpdate2();
    };

    this.draw = function()
    {
        if(this.img === undefined)
        {
            fill(this.color);
            $pjs.rect(this.xPos, this.yPos, this.width, this.height, 7.5);
        }
        else if(storedImages.npcs[this.img] !== undefined)
        {
            image(storedImages.npcs[this.img], this.xPos, this.yPos);
        }
    };

    this.avoidCollision = function(object)
    {
        return (object.type === "lifeform" || object.arrayName === this.arrayName);
    };

    this.onCollide = function(object)
    {
        if(object.talkToNpc !== undefined && object.talkToNpc() && !messageHandler.active)
        {
            object.xVel = 0;
            object.yVel = 0;
            this.usedIntro = true;
            talkHandler.start(this.messagePattern, this.message, this.name);
        }
    }
};
gameObjects.addObject("npc", createArray(Npc));

var Player = function(xPos, yPos, width, height, colorValue)
{
    DynamicRect.call(this, xPos, yPos, width, height);
    LifeForm.call(this, 10, true); //Inherit from life form with LifeForm.call(this, hp, notNormalDeath);
    
    this.restart = false;
    this.coins = 0;
    this.maxCoins = 400;
    this.gems = 0;
    this.score = 0;
    this.damage = 1;
    this.xAcl = 0.23;

    this.jumpTime = 5;
    this.jumpSpeed = 1.73;
    this.jumpHeight = 8;
    this.maxYVel = 12.5;

    //Never die (temperary)
    this.maxLives = 9999;
    this.lives = this.maxLives;

    this.walkSpeed = 3.25 - 0.34;
    this.runSpeed  = 4.25 - 0.84;

    this.xForce = 2;
    this.yForce = 3;

    this.imageName = "suit";
    this.marchTimer = 0;
    this.marchTime = 30;
    this.splitMarchTime = this.marchTime / 3;

    this.maxDefense = 70;

    this.invincibleToLifeForm = true;
    this.lifeFormHitTime = millis();
    this.invincibleToLifeFormTime = 2000;

    this.res = {}; //Resistants

    this.discoveredPowers = {}; //These will get replaced, don't attach anything to it.
    this.changePowers = {};
    this.inventory = {};
    this.crystals = {};

    var self = this;

    this.setInventory = function(slots)
    {
        this.inventory.items = [];
        this.inventory.slots = slots || 10;
        for(var i = 0; i < this.inventory.slots; i++)
        {
            this.inventory.items.push({});
        }
    };

    this.setInventory();

    this.updateItemsOrder = function(scene)
    {
        var items = this.inventory.items;

        for(var i = 0; i < items.length; i++)
        {
            var item = items[i];

            if(!item || !item.contains)
            {
                scene.buttons["player_" + i] = new Button(10, 132 + i * 18, 140, 18, color(28, 28, 28, 100), " - ");
            }else{
                scene.buttons["player_" + i] = new Button(10, 132 + i * 18, 140, 18, color(12, 60, 160, 100), " - ");
                scene.buttons["player_" + i].message = items[i].displayName || 
                (usableItems[items[i].contains] ? 
                usableItems[items[i].contains].displayName : false)  || items[i].contains;
            }

            scene.buttons["player_" + i].textSize = 10;
            scene.buttons["player_" + i].textColor = color(240, 240, 240, 200);
            scene.buttons["player_" + i].hover = items[i].description || 
                (usableItems[items[i].contains] ? 
                usableItems[items[i].contains].description : false) || 
                scene.buttons["player_" + i].hover;

            if(scene.buttons["player_" + i].message !== " - ")
            {
                scene.buttons["player_" + i].extra = (items[i].amount ? " x " + items[i].amount : "");
            }else{
                delete scene.buttons["player_" + i].extra;
            }

            scene.buttons["player_" + i].index = i;

            if(this.highlightItems)
            {
                var _lastOnClick = scene.buttons["player_" + i].onClick;
                scene.buttons["player_" + i].lastChangeTime = 0;
                scene.buttons["player_" + i].onClick = function()
                {
                    if(mouseIsPressed && millis() - this.lastChangeTime > 400 && this.message !== " - ")
                    {
                        this.highlighted = !this.highlighted;
                        this.highlightStroke = this.highlighted ? color(200, 200, 200, 180) : undefined;

                        this.lastChangeTime = millis();

                        if(!this.highlighted)
                        {
                            scene.highlightedButtonIndex = undefined;
                            return;
                        }

                        scene.highlightedButtonIndex = this.index;
                    }

                    return _lastOnClick.apply(this, arguments);
                };
            }
        }
    };

    this.onOpenItems = function(scene, highlightItems)
    {
        this.highlightItems = highlightItems || false;
        scene.highlightItems = this.highlightItems;

        if(!this.inventory.items || this.inventory.items.length <= 0)
        {
            this.setInventory();
        }

        this.updateItemsOrder(scene);

        scene.buttons["player_up"] = new Button(10, 312, 70, 18, color(28, 180, 48, 100), "^", undefined, 11);
        scene.buttons["player_up"].lastHitTime = 0;
        scene.buttons["player_up"].onClick = function()
        {
            if(!mouseIsPressed)
            {
                this.lastHitTime = 0;
                return;
            }

            if(millis() - this.lastHitTime < 140)
            {
                return;
            }

            self.inventory.items.push(self.inventory.items.shift());
            self.updateItemsOrder(scene);

            this.lastHitTime = millis();
        };

        scene.buttons["player_down"] = new Button(80, 312, 70, 18, color(28, 180, 48, 100), "v", undefined, 11);
        scene.buttons["player_down"].lastHitTime = 0;
        scene.buttons["player_down"].onClick = function()
        {
            if(!mouseIsPressed)
            {
                this.lastHitTime = 0;
                return;
            }

            if(millis() - this.lastHitTime < 140)
            {
                return;
            }

            self.inventory.items.unshift(self.inventory.items.pop());
            self.updateItemsOrder(scene);

            this.lastHitTime = millis();
        };
    };

    var self = this;

    this.maxAir = 200;
    this.air = 200;
    this.breathing = true;

    this.downBreathSpeed = 0.03;
    this.upBreathSpeed = 0.3;

    this.addCastForLiquid = function()
    {
        self.breathing = true;

        gameObjects.getObject("cast").add(
            self.xPos + self.halfWidth, 
            self.yPos + self.halfHeight * 0.2, 3, self.arrayName, function(object)
        {
            if(object.physics === undefined)
            {
                return;
            }

            if(object.arrayName === "water")
            {
                self.breathing = false;
            }
        }, 
        undefined, false);

        self.cast = gameObjects.getObject("cast").getLast();
        self.cast.noSolid = true;

        cameraGrid.addReference(self.cast);
    };

    var noop = function() {};
    this.discoveredPowersHandler = {
        currentPower : "",
        addPower : function(name, object)
        {
            self.discoveredPowers[name] = object || {};  
            this.currentPower = name;
            this.setChangePowers();
        },
        init : function()
        {
            for(var i in self.discoveredPowers)
            {
                var array = gameObjects.getObject(i);
                array.add(0, 0, 0, 0);
                self.discoveredPowers[i] = array.getLast().actObject || self.discoveredPowers[i];
                array.getLast().remove();
            }
        },
        setChangePowers : function()
        {
            self.changePowers = {};
            for(var i in self.discoveredPowers)
            {
                var power = self.discoveredPowers[i];
                power.active = false;
                self.changePowers[power.key] = i;
            }
        },
        testChangePowers : function()
        {
            if(keyIsPressed)
            {
                var lastPower = this.currentPower;
                this.currentPower = self.changePowers[key.toString()] || this.currentPower;

                if(lastPower !== this.currentPower)
                {
                    var power = self.discoveredPowers[lastPower];
                    (power.onExit || noop) (self, power);
                }
            }
        },
        activate : function()
        {
            if(this.currentPower === "")
            {
                return;
            }

            var power = self.discoveredPowers[this.currentPower];

            var pastActive = power.active;
            power.active = self.controls.activate() || false;

            if(!pastActive && power.active)
            {
                power.startTime = millis();
                (power.start || noop).call(power, self, power);
            }

            if(power.active)
            {
                (power.activate || noop).call(power, self, power);
            }
            else if(pastActive)
            {
                power.endTime = millis();
                (power.end || noop).call(power, self, power);
            }
        },
        avoidDamage : function(object, amt)
        {
            if(this.currentPower === "")
            {
                return false;
            }

            var power = self.discoveredPowers[this.currentPower];

            return (power.avoidDamage || function() 
            { 
                return false;
            }).call(power, object, amt, self, power);
        },
        update : function()
        {
            if(this.currentPower === "")
            {
                return;
            }

            var power = self.discoveredPowers[this.currentPower];
            (power.update || noop).call(power, self, power, self.controls.activate() || false);
        },
        draw : function()
        {
            if(this.currentPower === "")
            {
                return;
            }

            var power = self.discoveredPowers[this.currentPower];
            (power.draw || noop).call(power, self, power, self.controls.activate() || false);
        },
        onCollide : function(object, info)
        {
            if(this.currentPower === "")
            {
                return;
            }

            var power = self.discoveredPowers[this.currentPower];
            (power.onCollide || noop).call(power, self, power, self.controls.activate() || false, object, info);
        },
        mousePressed : function()
        {
            if(this.currentPower === "")
            {
                return;
            }

            var power = self.discoveredPowers[this.currentPower];
            (power.mousePressed || noop).call(power, self, power, self.controls.activate() || false); 
        },
        keyReleased : function()
        {
            if(this.currentPower === "")
            {
                return;
            }

            var power = self.discoveredPowers[this.currentPower];
            (power.keyReleased || noop).call(power, self, power, self.controls.activate() || false); 
        }
    };

    this.getNinjaResMult = function(object)
    {
        return (((object.arrayName === "ninja" || 
        object.arrayName === "ninjaStar") &&
        this.res.ninjaResistanceLevel) ? 
        Math.abs(1 - (Math.min(4, this.res.ninjaResistanceLevel) * 2 / 9)) : 1);
    };

    this.getDamage = function(object, amt)
    {
        return ((!object.isLifeForm/* && this.invincibleToLifeForm*/) ? 0 : (amt || object.damage));
    };

    this.takeDamage = function(object, amt)
    {
        if((!this.lps || performance.now() % this.lps >= this.lps - 1) && (!object.isLifeForm || !this.invincibleToLifeForm))
        {
            this.lastHp = this.hp;
            var damage1 = ((object.getDamage !== undefined) ? object.getDamage(object, amt) : (amt || object.damage));

            if(this.discoveredPowersHandler.avoidDamage(object, amt))
            {
                return true;
            }

            if(this.hp >= 0)
            {
                sounds.playSound("Explosion5.wav");
            }

            this.hp -= (damage1) * this.subDefense() * this.getNinjaResMult(object);

            if(object.isLifeForm || object.makeBlink)
            {
                this.invincibleToLifeForm = true;
                this.lifeFormHitTime = millis();
            }
        }
    };

    this.setFixture = function()
    {
        lighting.fixtures.player = {
            xPos : this.xPos,
            yPos : this.yPos + this.halfHeight,
            range : 100,
            brightness : 100, //0-100
            centeredLighting : 100,
            inCam : true,

            /* Offset settings*/
            perX : levelInfo.unitWidth * 6,
            perY : levelInfo.unitHeight * 6,
            halfWidth : this.halfWidth,
            halfHeight : this.halfHeight,
        };

        if(this.discoveredPowers["flashLight"] !== undefined)
        {
            lighting.fixtures.player.range = 146;
            lighting.fixtures.player.centeredLighting = 80;
        }
    };

    this.setFixture();

    this.xFire = (random(0, 1) < 0.5) ? -1 : 1;
    this.backwards = true;
    this.autoRun = true;

    this.controls = {
        left : function()
        {
            var left = (keys[LEFT] || keys[65]);
            if(left)
            {
                self.xFire = -1;
                self.throwInversed = false;
            }
            if(self.backwards && keys[" "])
            {
                self.xFire = 1;
                self.throwInversed = true;
            }
            return left;
        },
        right : function()
        {
            var right = (keys[RIGHT] || keys[68]);
            if(right)
            {
                self.xFire = 1;
                self.throwInversed = false;
            }
            if(self.backwards && keys[" "])
            {
                self.xFire = -1;
                self.throwInversed = true;
            }
            return right;
        },
        up : function()
        {
            return (keys[UP] || keys[87]) && !self.slowMe;
        },
        down : function()
        {
            return (keys[DOWN] || keys[83]);
        },
        restart : function()
        {
            return (keys[82]); //The 'r' key
        },
        toggleZoom : function()
        {
            // return (keys.x || keys.k);
        },
        zoom : function()
        {
            return self.autoRun;//'x'/'k' keys
        },
        activate : function()
        {
            return (keys.z || keys.l);
        },
        shake : function()
        {
            return keys[' '];
        },
        enter : function()
        {
            return keys.q;
        }
    };

    this.keyPressed = function()
    {
        if(this.controls.toggleZoom())
        {
            this.autoRun = !this.autoRun;
        }

        if(this.gooedTimer > 0 && this.controls.shake())
        {
            this.gooedTimer -= 60;
        }

        if(this.frozen && (this.controls.shake() || this.controls.activate() || 
                           this.controls.up() || this.controls.down() || this.con))
        {
            this.freeze -= 20;
        }
    };

    this.setPowers = function(powers)
    {
        for(var i = powers.length; i >= 0; i--)
        {
            if((powers[i] === "bubbleShield" || (powers[i] !== undefined && powers[i].name === "bubbleShield")))
            {
                var array = gameObjects.getObject("bubbleShield");
                array.add(physics.getMiddleXPos(this), physics.getMiddleYPos(this), max(this.height, this.width));

                if(!this.nextBubbleShield)
                {
                    powers[i].hp -= floor(100 / 3);
                }

                var bubbleShield = array.getLast();
                bubbleShield.hp = min(bubbleShield.maxHp, (powers[i].hp || bubbleShield.hp));

                //The two fundamental things for an object to be known in it's space :
                bubbleShield.updateBoundingBox();
                cameraGrid.addReference(bubbleShield);
            }
        }
    };

    this.getPowers = function()
    {
        var powers = [];
        if(this.bubbleShield !== undefined)
        {
            var inputBs = gameObjects.getObject("bubbleShield").input(this.bubbleShield.index);
            this.bubbleShield = ((!inputBs.fake) ? inputBs : this.bubbleShield);
            powers.push({
                name : "bubbleShield",
                hp : this.bubbleShield.hp,
            });
        }
        return powers;
    };

    var self = this;

    this.exploding = false;
    this.explosionTime = 1000 * 3;
    this.explosionImages = [];
    this.explosionPieces = [];
    this.explosionPieces.update = function()
    {
        for(var i = 0; i < this.length; i++)
        {
            var piece = this[i];
            if(piece.timer === undefined || piece.timer < 0)
            {
                piece.yVel += piece.gravity;

                piece.xPos += piece.xVel;
                piece.yPos += piece.yVel;
            }else{
                piece.timer--;
            }

            if(piece.yPos > self.yPos + cam.halfHeight)
            {
                this.splice(i, 1);
            }
        }
    };
    this.explosionPieces.draw = function(xOff, yOff)
    {
        for(var i = 0; i < this.length; i++)
        {
            image(this[i].image, this[i].xPos + xOff, this[i].yPos + yOff, this[i].width, this[i].height);
        }
    };

    this.tryWidth = 5;
    this.tryHeight = 10;

    this.initImage = function()
    {
        if(this.explosionImages.length <= 0)
        {
            var tryWidth = this.tryWidth;
            var tryHeight = this.tryHeight;

            resetMatrix();
            background(0, 0, 0, 0);
            image(storedImages[this.imageName], 0, 0, this.width, this.height);

            for(var x = 0; x < this.width; x += tryWidth)
            {
                this.explosionImages.push([]);
                for(var y = 0; y < this.height; y += tryHeight)
                {
                    this.explosionImages[x / tryWidth].push(get(x, y, tryWidth, tryHeight));
                }
            }
        }
    };

    this.initImage();

    this.startExplosion = function()
    {
        if(this.exploding)
        {
            return;
        }

        self = this;

        this.explosionStartTime = millis();
        this.exploding = true;

        var tryWidth = this.tryWidth;
        var tryHeight = this.tryHeight;

        var maxJ = this.explosionImages[0].length;
        for(var i = 0; i < this.explosionImages.length; i++)
        {
            for(var j = 0; j < this.explosionImages[i].length; j++)
            {
                this.explosionPieces.push({
                    image : this.explosionImages[i][j],
                    xPos : i * tryWidth,
                    yPos : j * tryHeight,
                    width : tryWidth * random(0.8, 1.6),
                    height : tryHeight * random(0.8, 1.6),
                    xVel : random(-1.4, 1.4),
                    yVel : -4,
                    timer : ((maxJ) - j) * tryHeight,
                    gravity : random(0.2, 0.3) / 1.3,
                });
            }
        }
    };

    this.endExplosion = function(onEnd)
    {
        this.exploding = false;
        this.explosionTimer = 0;
        this.explosionPieces.length = 0;
        this.quickBoom = false;

        (onEnd || function(){})();
    };

    this.updateExplosion = function(onEnd)
    {
        if(!this.exploding)
        {
            return;
        }

        if(millis() - this.explosionStartTime >= 300)
        {
            this.explosionPieces.update();

            if(!this.quickBoom && millis() - this.explosionStartTime >= 900)
            {
                sounds.mplaySound("quickBoom.wav");
                this.quickBoom = true;
            }
        }
        if(this.explosionPieces.length <= 0)
        {
            this.endExplosion(onEnd);
        }
    };

    this.drawExplosion = function()
    {
        if(!this.exploding)
        {
            return;
        }

        this.explosionPieces.draw(this.xPos, this.yPos);
    };

    this.deathInfo = {};
    this.saveDeathInfo = function()
    {
        this.deathInfo = {
            playerWasDead : this.dead,
            playerWasDeath : this.isDeath,
            playerLastHp : this.hp,
        };
    };

    this.safeRevive = function(toSetHp)
    {
        this.dead = false;
        this.exploding = false;
        this.physics.solidObject = true;
        this.invincibleToLifeForm = false;
        this.air = this.maxAir;

        this.gooedTimer = 0;

        this.freeze = 0;
        this.accume = 0;
        this.frozenHits = 0;
        this.frozen = false;

        if(this.deathInfo.playerWasDead && this.goto.travelType === "checkPoint")
        {
            //Does the player need to be revived or not?
            if(this.hp <= 0)
            {
                this.revive();
            }
        }
    };

    this.handleDeath = function(isDeath)
    {
        if(this.goto.checkPointLevel !== undefined)
        {
            this.goto.travelType = "checkPoint";
        }

        if(isDeath)
        {
            this.lives--;

            if(this.lives <= 0)
            {
                this.lives = this.maxLives;
                levelInfo.level = "intro";
                this.goto.checkPointLevel = "intro";
                this.goto.checkPointIndex = 0;
                game.switchGameState(true, "gameOver", true);
            }

            /*Make sure we are still exploding when we die so we don't
            see ourselves reappear when the death animation is over*/
            this.exploding = true; 
        }

        if(this.bubbleShield !== undefined)
        {
            this.bubbleShield.remove();
            this.bubbleShield.save = false;
            this.bubbleShield.objectToAttachTo = undefined;
            this.bubbleShield = undefined;

            var array = gameObjects.getObject("bubbleShield");
            array.length = 0;
        }

        this.gooedTimer = 0;

        this.dead = true;
        this.nextBubbleShield = !isDeath;
        this.isDeath = isDeath;
        this.invincibleToLifeForm = false;

        this.air = this.maxAir;
        this.isLifeForm = true;

        this.saveDeathInfo();
        loader.startLoadLevel(this.goto.checkPointLevel || levelInfo.level);
    };

    // this.lastPower = "";
    this.updateLighting = function()
    {
        if(levelInfo.daylightCycle || levelInfo.nightMode)
        {
            if(lighting.fixtures.player === undefined)
            {
                this.setFixture();
            }

            lighting.fixtures.player.xPos = this.xPos + ((this.xVel >= 0) ? this.halfWidth : this.width);
            lighting.fixtures.player.yPos = this.yPos + this.halfHeight;
        }
    };

    this.rendered = false;
    this.draw = function()
    {
        this.rendered = true;
        var img = "suit";
        if(this.xVel > this.xAcl)
        {
            if(!this.inAir)
            {
                this.marchTimer += this.controls.zoom() ? 1.5 : 1;
            }
            this.imageName = (this.marchTimer < this.splitMarchTime) ? img + "Right" : (this.marchTimer < this.splitMarchTime * 2) ? img + "Right2" : img + "Right3";
        }
        else if(this.xVel < -this.xAcl)
        {
            if(!this.inAir)
            {
                this.marchTimer += this.controls.zoom() ? 1.5 : 1;
            }
            this.imageName = (this.marchTimer < this.splitMarchTime) ? img + "Left" : (this.marchTimer < this.splitMarchTime * 2) ? img + "Left2" : img + "Left3";
        }else{
            this.imageName = img;
        }
        if(this.marchTimer > this.marchTime)
        {
            this.marchTimer = 0;
        }

        if(!this.exploding && (!this.invincibleToLifeForm || millis() % 600 >= 300))
        {
            ctx.drawImage(storedImages[this.imageName].sourceImg, 0, 0, width, height, Math.round(this.xPos), Math.round(this.yPos), this.width, this.height);
        }

        this.drawExplosion();
        this.updateLighting();
        this.discoveredPowersHandler.draw();

        if(this.frozen)
        {
            fill(0, 170, 200, 100);
            fastRect(this.xPos, this.yPos, this.width, this.height);
        }
        if(this.gooedTimer > 0)
        {
            fill(0, 156, 54, 100);
            fastRect(this.xPos, this.yPos, this.width, this.height);
        }
        if(this.redHurtTime > 0)
        {
            fill(178, 0, 12, 100);
            fastRect(this.xPos, this.yPos, this.width, this.height);
            fill(124, 64, 12, 100);
            fastRect(this.xPos, this.yPos, this.width, max(0, this.height * (this.redHurtTime / this.maxRedHurtTime)));
        }

        this.maxCoins = 400 + this.gems * 75;
        this.coins = Math.min(this.coins, this.maxCoins);
    };

    this.maxAccume = 10;
    this.accume = 0;

    this.frozenTime = 0;
    this.freezeTime = 2000;

    this.freeze = 0;
    this.frozenHits = 0;

    this.redHurtTime = 0;
    this.maxRedHurtTime = 50;

    this.lastUpdate = this.update;
    this.update = function()
    {
        this.nextBubbleShield = true;

        if(this.redHurtTime > 0)
        {
            if(this.redHurtTime === 1)
            {
                this.hp -= 3;

                this.invincibleToLifeForm = true;
                this.lifeFormHitTime = millis();

                if(this.hp >= 0)
                {
                    sounds.playSound("Explosion5.wav");
                }

                this.redHurtTime = -1;
            }

            this.redHurtTime--;

            if(this.controls.shake())
            {
                this.redHurtTime = 0;
            }
        }

        if(this.gooedTimer > 0)
        {
            if(!this.gooedDamageTimer || millis() - this.gooedDamageTimer > 750)
            {
                this.hp -= 1;
                this.gooedDamageTimer = millis();

                this.yVel -= 3;
            }

            this.xVel += random(-1, 1);

            this.gooedTimer--;
        }

        if(!this.invincibleToLifeForm)
        {
            if(this.accume >= 1)
            {
                this.accume = 1;
                if(this.freeze <= 0 && !this.frozen)
                {
                    this.freeze = 100;
                    this.frozenTime = millis();
                }
            }

            this.lastFrozen = this.frozen;
            this.frozen = (this.freeze > 0);

            if(!this.frozen && this.lastFrozen)
            {
                this.freeze = 0;
                this.accume = 0;
                this.frozenHits = 0;

                this.invincibleToLifeForm = true;
                this.lifeFormHitTime = millis();
            }

            if(this.frozen)
            {
                if(millis() - this.frozenTime > this.freezeTime)
                {
                    this.hp -= 1;
                    this.frozenHits++;
                    this.frozenTime = millis();

                    if(this.frozenHits > 2)
                    {
                        this.freeze = 0;
                    }
                }
            }
        }

        /*Specific code*/
        if(!this.added)
        {
            travelObjects.add(this);
            this.added = true;
        }
        
        var self = this;
        this.updateExplosion(function()
        {
            self.handleDeath(self.dead); //When the explosion ends, do this!
        });

        if(this.exploding)
        {
            return;
        }

        //Restart key 'r' spam protection
        if(!this.restart && !this.controls.restart())
        {
            this.restart = true;
        }
        
        if(this.dead && this.hp <= 0)
        {
            try{
                var fairyIndex = -1;
                this.inventory.items.some(function(element, index, array)
                {
                    if(element.contains === "fairy")
                    {
                        fairyIndex = index;
                        return true;
                    }
                });

                if(fairyIndex >= 0 && this.yPos < levelInfo.yPos + levelInfo.height)
                {
                    this.dead = false;
                    this.revive();
                    this.yVel -= 3;

                    this.inventory.items[fairyIndex] = {};
                    return;
                }
            }
            catch(e)
            {
                console.log(e);
            }
        }

        if((this.dead || (this.restart && this.controls.restart())) && levelInfo.level !== "LightTowerTopFloor") //or 'r'
        {
            if(!this.dead || this.yPos >= levelInfo.yPos + levelInfo.height)
            {
                this.handleDeath(this.dead);
            }
            else if(!this.controls.restart())
            {
                game.cutScening = true;
                this.isLifeForm = false;
                this.startExplosion();
            }
            this.restart = false;
        }

         /////////////////////////////OTHER\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
        ///////////////////////////////CODE\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

        //Must be called in specifically this order.
        this.discoveredPowersHandler.testChangePowers();
        this.discoveredPowersHandler.activate();
        this.discoveredPowersHandler.update();

        if(this.discoveredPowers["flashLightUpgrade"])
        {
            var power = this.discoveredPowers["flashLightUpgrade"];

            if(power.dir === "down")
            {
                power.timer -= power.reSpeed;

                if(power.timer < 0)
                {
                    power.dir = "up";
                    power.timer = 0;
                }
            }

            if(!power.active)
            {
                delete this.slowMe;
            }
        }

        this.maxXVel = ((this.autoRun || this.controls.zoom()) ? this.runSpeed : this.walkSpeed);

        if(this.inLiquid)
        {
            this.maxXVel = 2;
            if(this.origMaxYVel === undefined)
            {
                this.origMaxYVel = this.maxYVel;
            }
            this.maxYVel = 3;
        }
        else if(this.origMaxYVel !== undefined)
        {
            this.maxYVel = this.origMaxYVel;
        }

        if(this.slowMe)
        {
            this.maxXVel = 1.5;
        }
        
        //May not need:
        if(this.bubbleShield !== undefined && this.toSet)
        {
            this.bubbleShield.xPos = physics.getMiddleXPos(this);
            this.bubbleShield.yPos = physics.getMiddleYPos(this);
            this.toSet = false;
        }

        this.readingSign = false;

        if(millis() - this.lifeFormHitTime >= this.invincibleToLifeFormTime)
        {
            this.invincibleToLifeForm = false;
        }

        if(this.breathing)
        {
            this.air += this.upBreathSpeed;
            this.air = min(this.air, this.maxAir);
        }

        if((this.inLiquid || levelInfo.inWater) && this.bubbleShield && this.bubbleShield.hp > 0)
        {
            this.bubbleShield.hp -= 0.04;
        }

        if(this.inLiquid)
        {
            if(millis() % 200 >= 180)
            {
                this.addCastForLiquid();
            }
        }
        else if(this.cast !== undefined)
        {
            this.breathing = true;
            this.cast.onKill();
            this.cast = undefined;
        }

        if(this.air <= 0 && millis() % 700 >= 650)
        {
            this.hp -= 1;
        }
        if(this.hoverModeEnabled)
        {
            if(this.hoverMode)
            {
                this.gravity = 0;

                if(keys[UP] || keys['w'])
                {
                    this.yVel = -3;
                }
                else if(keys[DOWN] || keys['s'])
                {
                    this.yVel = 3;
                }else{
                    this.yVel = 0;
                }
            }else{
                this.gravity = 0.325;
            }

            if(keys[" "] && millis() - this.lastHoverTime > 500)
            {
                this.hoverMode = !this.hoverMode;

                this.lastHoverTime = millis();
            }
        }

        this.lastUpdate();
    };

    this.hoverModeEnabled = false;
    this.hoverMode = false;
    this.lastHoverTime = 0;

    this.setAfter = function()
    {
        if(this.bubbleShield !== undefined)
        {
            var bubbleShields = gameObjects.getObject("bubbleShield");
            //If the bubble shield ceased to exist, set it back up!
            //Like when we go through a door
            if(bubbleShields.input(this.bubbleShield.index).fake)
            {
                bubbleShields[this.bubbleShield.index] = this.bubbleShield;
                var bubbleShield = bubbleShields[this.bubbleShield.index];
                bubbleShield.xPos = physics.getMiddleXPos(this);
                bubbleShield.yPos = physics.getMiddleYPos(this);
                bubbleShield.delete = false;
                bubbleShield.hideDelete = false;
                bubbleShield.updateBoundingBox();
                cameraGrid.addReference(bubbleShield);
                this.bubbleShield = bubbleShield;
            }
        }
    };

    this.lastOnCollide = this.onCollide;
    this.onCollide = function(object, info)
    {
        this.lastOnCollide(object, info);

        this.discoveredPowersHandler.onCollide(object, info);

        if(object.arrayName === "sign")
        {
            this.readingSign = true;
        }
    };

    /*Specific code*/
    this.goto = {};
    this.activate = function(override)
    {
        return ((!this.inAir || !this.breathing || override) && this.controls.down());
    };
    this.openDoor = function() 
    {
        return this.activate() && (this.hp > 0);
    };

    this.openChest = this.activate;
    this.talkToNpc = this.activate;
    this.useCheckPoint = function()
    {
        return (!this.inAir && this.hp > 0) && (game.autoCheckPoints || this.controls.down());
    };
    this.overrideSave = function()
    {
        return (this.useCheckPoint() && this.controls.down());
    };
    this.collectItem = function()
    {
        return true;
    };

    this.onCheckPoint = function(checkPoint)
    {
        if(game.gameState === "play")
        {
            game.save(checkPoint);
        }
    };
};
gameObjects.addObject("player", createArray(Player));

var BubbleShield = function(xPos, yPos, diameter, colorValue, hp)
{
    DynamicCircle.call(this, xPos, yPos, diameter);
    this.color = colorValue || color(120, 120, 250, 100);
    this.physics.solidObject = false;

    this.hp = hp || 100;
    this.maxHp = this.hp;

    this.maxBlinkTimer = 300;

    this.takeDamage = function(object, amt)
    {
        this.hp -= amt || object.damage;
    };

    this.draw = function()
    {
        if(this.blinking && this.blinkTimer % 30 >= 15 || (this.objectToAttachTo || {}).readingSign)
        {
            return;
        }

        noStroke();

        fill(this.color);
        circle(this.xPos, this.yPos, this.diameter);

        stroke(red(this.color), green(this.color), blue(this.color), 150);
        strokeWeight(10);
        noFill();
        var offSet = ((MODE === "ka") ? 90 : TWO_PI/4);
        arc(this.xPos, this.yPos, this.diameter - 5, this.diameter - 5, -offSet, (this.hp * ((MODE === "ka") ? 360 : TWO_PI) / this.maxHp) - offSet);
        strokeWeight(1);
        noStroke();

        fill(230, 230, 230, 100);
        circle(this.xPos - this.diameter * 0.2, this.yPos - this.diameter * 0.2, this.diameter * 0.3);
        circle(this.xPos - this.diameter * 0.08, this.yPos - this.diameter * 0.4, this.diameter * 0.1);

        textAlign(CENTER, CENTER);
        textSize(16);
        text(max(0, floor(this.hp)), this.xPos, this.yPos - this.radius);
    };

    this.gravity = 0;

    this.setPos = function(isUpdate)
    {
        if(this.objectToAttachTo !== undefined)
        {
            this.xPos = physics.getMiddleXPos(this.objectToAttachTo);
            this.yPos = physics.getMiddleYPos(this.objectToAttachTo);   
        }
    };

    this.lastUpdate = this.update;
    this.update = function()
    {
        this.xVel = 0;
        this.yVel = 0;

        this.lastUpdate();

        this.setPos(true);

        if(this.blinking)
        {
            this.blinkTimer--;
            if(this.blinkTimer < 0)
            {
                this.objectToAttachTo.bubbleShield = undefined;
                this.remove();
            }
        }
    };

    this.onCollide = function(object)
    {
        if(this.hp <= 0)
        {
            if(this.blinking === undefined)
            {
                this.blinkTimer = this.maxBlinkTimer;
            }
            this.blinking = true;
        }

        if(object.arrayName === "voxelizer")
        {
            this.hp -= 1;
        }

        if(object.arrayName === "bullet" || object.arrayName === "ninjaStar" || object.arrayName === "launchBall")
        {
            this.takeDamage(object);
            object.remove();
            object.onCollide = function() {};
        }
        else if(object.arrayName === "player")
        {
            /*Player already has the bubble shield but bubble shield hp not full?
            Fill hp and remove me.*/
            if(object.bubbleShield !== undefined && object.bubbleShield !== this && 
               object.bubbleShield.hp < 100)
            {
                object.bubbleShield.hp = 100;
                object.bubbleShield.blinking = false;
                object.bubbleShield.blinkTimer = object.bubbleShield.maxBlinkTimer;
                this.remove();
            }

            if(this.objectToAttachTo === undefined && object.bubbleShield === undefined)
            {
                this.objArrayName = "player";
                this.objIndex = object.index;

                object.bubbleShield = this;
                this.objectToAttachTo = object;

                this.diameter = max(object.width, object.height) * 1.5;
                this.radius = this.diameter / 2;

                this.boundingBox.width = this.diameter;
                this.boundingBox.height = this.diameter;
            }
        } 
    };
};
gameObjects.addObject("bubbleShield", createArray(BubbleShield));

var WispIce = function(xPos, yPos, diameter, colorValue)
{
    DynamicCircle.call(this, xPos, yPos, diameter);

    this.physics.solidObject = false;

    this.color = colorValue || color(70-50, 160-50, 210-50, 200);

    this.diameter3o1 = this.diameter / 3;

    this.loadDraw = function()
    {
        this.imageName = "wispIce";

        if(storedImages[this.imageName] === undefined)
        {
            this.img = createGraphics(this.diameter, this.diameter, P2D);

            var thd = this.diameter / 3;

            this.img.beginDraw();
                this.img.fill(this.color);
                this.img.noStroke(this.color);

                this.img.fastRect(0, 0, thd, thd);
                this.img.fastRect(thd * 2, 0, thd, thd);

                this.img.fastRect(thd, thd, thd, thd);

                this.img.fastRect(0, thd * 2, thd, thd);
                this.img.fastRect(thd * 2, thd * 2, thd, thd);
            this.img.endDraw();

            storedImages[this.imageName] = this.img;
        }

        this.draw = function()
        {
            if(this.hit && millis() - this.startHit > this.hitTime - 1000 && millis() % 250 >= 125)
            {
                return;
            }

            image(storedImages[this.imageName], this.xPos - this.radius, this.yPos + this.radius, this.radius * 1.5, this.radius * 1.5);
        };
    };

    this.loadDraw();

    this.outerXVel2 = 0;
    this.outerYVel2 = 0;

    this.hitTime = 3500;
    this.startHit = 0;

    this.update = function()
    {
        this.xPos += this.outerXVel2;
        this.yPos += this.outerYVel2;

        if(this.hit && millis() - this.startHit > this.hitTime)
        {
            this.remove();
            this.onCollide = function() {};

            if(this.attached !== undefined)
            {
                this.attached.accume--;
                this.attached.accume = max(0, this.attached.accume);
            }
        }

        if(this.attached !== undefined)
        {
            this.xPos = this.attached.xPos + this.deltaX;
            this.yPos = this.attached.yPos + this.deltaY;
        }

        this.updateBoundingBox();
    };

    this.damage = 0;

    this.onCollide = function(object)
    {
        if(object.arrayName === "player" && !this.blockedByPlayer && !object.invincibleToLifeForm)
        {
            var blocked = object.takeDamage(this, 0);
            if(!blocked)
            {
                this.outerXVel2 = 0;
                this.outerYVel2 = 0;

                this.blocked = blocked;

                var margin = 0;

                if(object.accume <= 2)
                {
                    margin = 1.5;
                }
                else if(object.accume <= 4)
                {
                    margin = 2;
                }
                else if(object.accume <= 6)
                {
                    margin = 2.5;
                }

                margin += 1.15;

                object.xVel = constrain(object.xVel, -object.maxXVel + margin, object.maxXVel - margin);
                object.yVel = constrain(object.yVel, -object.maxYVel + margin, object.maxYVel - margin);

                this.deltaX = this.xPos - object.xPos;
                this.deltaY = this.yPos - object.yPos;

                if(object.accume === undefined)
                {
                    object.accume = 0;
                }

                this.attached = object;
                this.attached.accume++;

                //Temp
                this.remove();
                this.onCollide = function() {};

                if(!this.hit)
                {
                    this.startHit = millis();
                    this.hit = true;
                }
            }else{
                var d = Math.sqrt(Math.pow(this.outerYVel2, 2) + Math.pow(this.outerXVel2, 2));
                var a = atan2(this.outerYVel2, 
                              this.outerXVel2);

                a += PI;
                d *= 1.1;

                this.outerXVel2 = cos(a) * d;
                this.outerYVel2 = sin(a) * d;

                if(object.arrayName === "player")
                {
                    this.blockedByPlayer = true;
                    this.life += 200;
                }
            }
        }
    };
};
gameObjects.addObject("wispIce", createArray(WispIce));

var Wisp = function(xPos, yPos, diameter, colorValue)
{
    DynamicCircle.call(this, xPos, yPos, diameter);
    LifeForm.call(this, 4);
    this.scoreValue = 400;

    this.color = colorValue || color(70, 160, 210, 200);

    this.gravity = 0;

    this.eyeDiameter = this.diameter / 5.5;

    this.topY = this.yPos - this.radius;
    this.downY = this.yPos + this.radius;

    this.direction = "front";

    this.draw = function()
    {
        switch(this.direction)
        {
            case "front" :
                fill(65, 65, 65);
                triangle(this.xPos - this.diameter - 2, this.downY, this.xPos, this.topY, this.xPos, this.downY);
                triangle(this.xPos + this.diameter + 2, this.downY, this.xPos, this.topY, this.xPos, this.downY);

                fill(this.color);
                triangle(this.xPos - this.diameter, this.downY, this.xPos, this.topY, this.xPos, this.downY);
                triangle(this.xPos + this.diameter, this.downY, this.xPos, this.topY, this.xPos, this.downY);

                fill(this.color);
                circle(this.xPos, this.yPos, this.diameter);

                fill(0, 0, 0, 60);
                triangle(this.xPos, this.yPos - this.diameter, this.xPos - this.radius, this.yPos, this.xPos + this.radius, this.yPos);

                fill(0, 0, 0, 60);
                arc(this.xPos, this.yPos, this.diameter - 6, this.diameter - 6, 0, radians(180));

                fill(240, 240, 240, 200);
                circle(this.xPos - 4, this.yPos - 3.4, this.eyeDiameter);

                fill(240, 240, 240, 200);
                circle(this.xPos + 4, this.yPos - 3.4, this.eyeDiameter);
                break;

            case "left" :
                fill(this.color);
                circle(this.xPos, this.yPos, this.diameter);

                fill(0, 0, 0, 60);
                triangle(this.xPos, this.yPos - this.diameter, this.xPos - this.radius, this.yPos, this.xPos, this.yPos);

                fill(0, 0, 0, 60);
                arc(this.xPos, this.yPos, this.diameter - 6, this.diameter - 6, radians(-90), radians(180));
                break;

            case "right" :
                break;
        }
    };

    this.task = "locate";

    this.angle = 0;
    this.speed = 5;

    this.lastLaunchTime = 0;

    this.offXVel = 0;
    this.offYVel = 0;

    this.between = Math.round(random(1500, 2500));

    this._lastUpdate1 = this.update;
    this.update = function()
    {
        this.xPos += cos(radians(this.angle)) * this.speed + this.offXVel;
        this.yPos += sin(radians(this.angle)) * this.speed / 4 + this.offYVel;

        this._lastUpdate1();

        this.angle += 4;

        if(this.angle > 360)
        {
            this.angle = 0;
        }
        else if(this.angle < 0)
        {
            this.angle = 360;
        }

        this.topY = this.yPos - this.radius + 1;
        this.downY = this.yPos + this.radius - 2;

        //The only object this will attack
        // var player = gameObjects.getObject("player").getLast();

        if(player.yPos - this.yPos < -60)
        {
            this.offYVel = -2.5;
        }else{
            this.offYVel = 0;
        }

        if(millis() - this.lastLaunchTime > this.between)
        {
            this.launchIce(player, 5);
            this.lastLaunchTime = millis();
            this.between = Math.round(random(1500, 2500));
        }
    };

    this.launchIce = function(object, speed)
    {   
        var wispIces = gameObjects.getObject("wispIce");
        wispIces.add(this.xPos, this.yPos, 12);

        var ice = wispIces.getLast();
        cameraGrid.addReference(ice);

        physics.getMiddleXPos(object);
        physics.getMiddleYPos(object);

        var angle = atan2(object.middleYPos - this.yPos,
                          object.middleXPos - this.xPos);

        ice.outerXVel2 = cos(angle) * speed;
        ice.outerYVel2 = sin(angle) * speed;
    };

    this._lastOnCollide1 = this.onCollide;
    this.onCollide = function(object, info)
    {
        if(object.arrayName === "player" && object.yVel > 0 && object.yPos + object.height < this.yPos)
        {
            object.yVel = -6;
            this.takeDamage(object);
        }

        this._lastOnCollide1(object, info);
    };
};
gameObjects.addObject("wisp", createArray(Wisp));

var Voxelizer = function(xPos, yPos, width, height, colorValue)
{
    DynamicRect.call(this, xPos, yPos, width, height);
    LifeForm.call(this, 4);
    this.scoreValue = 2000;
    this.damage = 1;

    this.color = colorValue || color(62, 18, 136, 200);

    this.gravity = 0;

    this.angle = 0;
    this.rot = 0;
    this.rotVel = 7 * (random(0, 1) < 0.5 ? 1 : -1);

    var ux = physics.getMiddleXPos(this);
    var uy = physics.getMiddleYPos(this);

    this.draw = function()
    {
        this.rot += this.rotVel;

        ux = physics.getMiddleXPos(this);
        uy = physics.getMiddleYPos(this);
        var uw, uh;

        noStroke();
        $pjs.pushMatrix();
            translate(ux, uy);
            rotate(this.angle);
            fill(29, 18, 174, 70);
            $pjs.rect(-this.halfWidth + 1, -this.halfHeight + 1, this.width - 2, this.height - 2, 2);
        $pjs.popMatrix();

        fill(red(this.color), green(this.color), blue(this.color), 40); 
        for(var i = 0; i < 4; i++)
        {
            $pjs.pushMatrix();
                translate(ux, uy);
                rotate(this.rot + i * 23);

                uw = (this.width - i * 2.3);
                uh = (this.height - i * 2.3);
                fastRect(-uw / 2, -uh / 2, uw, uh);
            $pjs.popMatrix();
        }

        this.streaks.draw();
    };

    var self = this;

    this.streaks = [];
    this.streaks.add = function()
    {
        var rx = random(-self.halfWidth, self.halfWidth);
            ry = random(-self.halfHeight, self.halfHeight);

        this.push({
            x : self.middleXPos + rx,
            y : self.middleYPos + ry,
            sx : self.middleXPos + rx,
            sy : self.middleYPos + ry,
            fade : 100
        });
    };
    this.streaks.draw = function()
    {
        strokeWeight(0.7);

        var _r = red(self.color),
            _g = green(self.color),
            _b = blue(self.color);

        for(var i = this.length - 1; i >= 0; i--)
        {
            var streak = this[i];

            streak.fade -= 1.4;

            if(streak.fade > random(70, 90))
            {
                streak.x += self.xVel;
                streak.y += self.yVel;
            }

            stroke(_r, _g, _b, streak.fade * 50 / 100);
            line(streak.x, streak.y, streak.sx, streak.sy);

            if(streak.fade < 0)
            {
                this.splice(i, 1);
            }
        }

        noStroke();
    };

    this.lastStreakTime = 0;
    this.nextStreakTime = 800;

    this.timeOffset = random(400, 1600);
    this.lastFollowTime = 500;
    this.nextFollowTime = 1000;
    this.following = 0;

    this.maxXVel = 5;
    this.maxYVel = 5;

    this.lastXDeacl = this.xDeacl;
    this.lastYDeacl = this.yDeacl;

    this.lastBouncedTime = 0;

    var lastUpdate = this.update;
    this.update = function()
    {
        if(millis() - this.lastStreakTime > this.nextStreakTime)
        {
            this.streaks.add();

            this.lastStreakTime = millis();
            this.nextStreakTime = random(20, 80);
        }

        if((millis() + this.timeOffset) - this.lastFollowTime > this.nextFollowTime)
        {
            this.following++;
            if(this.following > 3)
            {
                this.following = 0;
            }
            this.nextFollowTime = (this.following !== 1) ? 1000 : 700;
            this.lastFollowTime = millis() + this.timeOffset;
        }

        this.xDeacl = this.lastXDeacl;
        this.yDeacl = this.lastYDeacl;

        if(millis() - this.lastBouncedTime < 2400)
        {
            this.following = 4;
        }

        switch(this.following)
        {
            case 0 : case 2 :
                this.target = player;

                var a = atan2(physics.getMiddleYPos(this.target) - this.middleYPos, 
                              physics.getMiddleXPos(this.target) - this.middleXPos);

                this.xVel = cos(a) * 3.7;
                this.yVel = sin(a) * 3.7;
                break;

            case 1 :
                this.target = this.getClosest(this.arrayName, 100, 600);
                if(this.target.index !== this.index)
                {
                    var a = atan2(physics.getMiddleYPos(this.target) - this.middleYPos, 
                                  physics.getMiddleXPos(this.target) - this.middleXPos);

                    this.xVel = cos(a) * 3;
                    this.yVel = sin(a) * 3;
                }
                break;

            case 4 :
                this.target = player;

                var a = atan2(physics.getMiddleYPos(this.target) - this.middleYPos, 
                              physics.getMiddleXPos(this.target) - this.middleXPos);

                this.xVel = cos(a) * -3.7;
                this.yVel = sin(a) * -3.7;
                break;

            default :
                this.xDeacl = 0.2;
                this.yDeacl = 0.2;
                break;
        }

        return lastUpdate.apply(this, arguments);
    };

    this.getClosest = function(arrayName, minD, maxD)
    {
        var neighbor = this;
        var items = gameObjects.getObject(arrayName);

        minD = Math.pow(minD || -Infinity, 2);
        maxD = Math.pow(maxD || Infinity, 2);

        var closest = Infinity;
        var d = 0;
        var index;

        for(var i = 0; i < items.length; i++)
        {
            if(items[i].arrayName === this.arrayName && 
               i === this.index || items[i].fake)
            {
                continue;
            }

            d = Math.pow(Math.abs(this.xPos - items[i].xPos), 2) + 
                Math.pow(Math.abs(this.yPos - items[i].yPos), 2);

            if(d < closest && d > minD && d < maxD)
            {
                index = i;
                closest = d;
            }   
        }

        if(index !== undefined)
        {
            neighbor = items[index];
        }

        return neighbor;
    };

    this.avoidCollision = function(object)
    {
        return (object.arrayName === "fallingBlock" || object.arrayName === "slope");
    };

    var lastOnCollide = this.onCollide;
    this.onCollide = function(object, info)
    {
        if(this.target && object.arrayName === this.target.arrayName && 
            object.arrayName !== this.arrayName)
        {
            if(object.bubbleShield)
            {
                return lastOnCollide.apply(this, arguments);
            }

            var avoided = object.takeDamage(this)

            if(!avoided)
            {
                object.xVel += this.xVel * 0.5;
                object.yVel += this.yVel * 0.5;
            }else{
                this.lastBouncedTime = millis();
                this.xVel = this.yVel = 0;
            }
        }

        return lastOnCollide.apply(this, arguments);
    };
};
gameObjects.addObject("voxelizer", createArray(Voxelizer));

var Stalactite = function(xPos, yPos, width, height, imageName)
{
    Rect.call(this, xPos, yPos, width, height);
    this.physics.solidObject = false;

    this.imageName = imageName;

    this.snowflakes = 0;

    this.draw = function()
    {
        try{
            image(loadedImages[this.imageName], this.xPos, this.yPos, this.width, this.height);
        }
        catch(e) { }
    };

    this.notExplosive = true;
};
gameObjects.addObject("stalactite", createArray(Stalactite));

var Stalagmite = function(xPos, yPos, width, height, imageName)
{
    Rect.call(this, xPos, yPos, width, height);
    this.physics.solidObject = false;

    this.imageName = imageName || "BlueStalagmite";

    this.snowflakes = 0;

    this.draw = function()
    {
        try{
            image(loadedImages[this.imageName], this.xPos, this.yPos, this.width, this.height);
        }
        catch(e) { }
    };

    this.notExplosive = true;
};
gameObjects.addObject("stalagmite", createArray(Stalagmite));

var Stomper = function(xPos, yPos, width, height)
{
    Enemy.call(this, xPos, yPos, width, height, color(176, 176, 176), {
        charging : true
    }, false, 10);

    this.addCast(this, "stomper");

    this.damage = 3;

    this.snowflakes = 0;
    this.notExplosive = true;

    this.end = "";
    var side = "";

    this._imageTimer = 0;

    this.draw = function()
    {
        if(millis() - this._imageTimer > 160)
        {
            this.end = (this.end === "" ? (side = (side === "Left") ? "Right" : "Left") : "");
            this._imageTimer = millis();
        }

        if(this.inAir)
        {
            this.end = "";
        }

        this.imageName = "stomper" + this.end;

        if(this.xVel > 0)
        {
            image(loadedImages[this.imageName], this.xPos, this.yPos, this.width, this.height);
        }else{
            $pjs.pushMatrix();
                translate(this.xPos, this.yPos);
                scale(-1.0, 1.0);
                image(loadedImages[this.imageName], -this.width, 0, this.width, this.height);
            $pjs.popMatrix();
        }
    };

    var _lastUpdate = this.update;
    this.update = function()
    {
        _lastUpdate.apply(this, arguments);

        if(millis() - this.startedJumpTime > 2000)
        {
            this.yDir = "";
        }
    };

    var _lastOnCollide = this.onCollide;
    this.onCollide = function(object, info)
    {
        if((info.side === "left" || info.side === "right") && object.arrayName === "player")
        {
            this.yDir = "up";
            this.startedJumpTime = millis();
        }

        return _lastOnCollide.apply(this, arguments);
    };
};
gameObjects.addObject("stomper", createArray(Stomper));

var Water = function(xPos, yPos, width, height, colorValue)
{
    Rect.call(this, xPos, yPos, width, height, colorValue); 
    this.color = colorValue || color(40, 103, 181, 150);
    this.physics.solidObject = false;
    
    this.type = "liquid";
    this.thickness = 1.405;
    this.damage = 0.1;

    this.frozen = false;
    this.freezing = false;
    this.freezable = true;

    this.temp = 70;
    this.freezeTemp = 22;
    this.maxTemp = 72;
    this.freezeRate = 0.05;
    this.scoreValue = 150;

    this.offMillis = Math.round(random(-2000, 1000));

    this.boundingBox.width += 2;
    this.boundingBox.height += 2;

    this.updateBoundingBox = function()
    {
        this.boundingBox.xPos = this.xPos - 1;
        this.boundingBox.yPos = this.yPos - 1;
    };

    if(levelInfo.theme === "underground")
    {
        this.color = color(153, 90, 150, 155);
    }

    this.draw = function()
    {
        noStroke();
        fill(this.color);
        fastRect(this.xPos, this.yPos, this.width, this.height);

        if(this.freezing && !this.showNoFreeze)
        {
            fill(33, 198, 207, this.a || 200 * (this.maxTemp - this.temp) / this.maxTemp);
            triangle(this.xPos + this.width, this.yPos + this.height, this.xPos + this.width, this.yPos, this.xPos, this.yPos + this.height);
        }
    };

    this.__lastUpdate = this.update;
    this.update = function()
    {
        this.__lastUpdate();

        if(!this.freezable) 
        {
            this.freezing = false;
            return;
        }

        if(this.freezing)
        {
            this.temp -= this.freezeRate;
        }

        if(this.temp < this.freezeTemp)
        {
            this.frozen = true;

            this.remove();
            gameObjects.getObject("ice").add(this.xPos, this.yPos, this.width, this.height, undefined, undefined, true);

            var ice = gameObjects.getObject("ice").getLast();

            //Make the ice look like when water is frozen
            ice.draw = this.draw;
            ice.a = 200;
            ice.color = this.color;
            ice.freezing = true;

            cameraGrid.addReference(ice);
        }

        this.physics.movement = (millis() % (3000 + this.offMillis) >= 2970 + this.offMillis) ? "dynamic" : "static"; 
    };

    this.lastDepleteBubbleShieldHp = millis();

    this.onCollide = function(object)
    {
        if(object.air !== undefined && !object.breathing)
        {
            if(!object.bubbleShield)
            {
                if(this.width > levelInfo.unitWidth && this.height > levelInfo.unitHeight)
                {
                    object.air -= (object.downBreathSpeed || 0.25) * 5;
                    object.air = max(object.air, 0);
                }else{
                    object.air -= object.downBreathSpeed || 0.25;
                    object.air = max(object.air, 0);
                }
            }
        }
        if(object.physics.movement === "dynamic" && 
          (object.inAir || object.yVel > 0 || object.boundingBox.yPos + object.boundingBox.height > this.yPos))
        {
            object.yVel = object.yVel / this.thickness;
            object.inLiquid = true;
            object.inAir = false;
        }
    };
};
gameObjects.addObject("water", createArray(Water));

var QuickSand = function(xPos, yPos, width, height, colorValue)
{
    Rect.call(this, xPos, yPos, width, height);
    this.color = colorValue || color(215, 125, 50, 160);
    this.physics.solidObject = false;

    this.type = "liquid";
    this.thickness = 2.075;

    this.onCollide = function(object)
    {
        if(object.air !== undefined && !object.breathing)
        {
            if(!object.bubbleShield)
            {
                if(this.width > levelInfo.unitWidth && this.height > levelInfo.unitHeight)
                {
                    object.air -= (object.downBreathSpeed || 0.25) * 5;
                    object.air = max(object.air, 0);
                }else{
                    object.air -= object.downBreathSpeed || 0.25;
                    object.air = max(object.air, 0);
                }
            }
        }
        if(object.physics.movement === "dynamic")
        {
            object.inAir = false;
            object.inLiquid = true;
            object.yVel = object.yVel / this.thickness;
            object.xVel = object.xVel / this.thickness;
            object.yVel += 0.02;
            object.yPos += 0.1;
            object.yVel += abs(object.xVel) * 0.02;
        }
    };
};
gameObjects.addObject("quickSand", createArray(QuickSand));

var DirtyBlock = function(xPos, yPos, width, height, colorValue)
{
    Rect.call(this, xPos, yPos, width, height);
    this.color = colorValue;
    this.type = "block";

    this.physics.solidObject = false;

    this.imageName = "dirtyBlock";

    this.draw = function()
    {
        image(storedImages[this.imageName], this.xPos, this.yPos, this.width, this.height);
    };

    var nameExtension = "";

    if(levelInfo.theme === "underground")
    {
        this.draw = function()
        {
            image(storedImages[this.imageName], this.xPos, this.yPos, this.width, this.height);
            fill(0, 64, 12, 103);
            $pjs.rect(this.xPos, this.yPos, this.width, this.height);
        };
    }

    // object, constImage, name, notRect, customBackColor, ref, tone, pro
    screenUtils.loadImage(this, true, "dirtyBlock" + "--" + nameExtension, undefined, undefined, undefined, 200, true);
    this.imageName = "dirtyBlock" + "--";

    this.intensity = 18;

    this.onCollide = function(object)
    {
        object.inAir = object.yPos + object.height < this.yPos + 3;

        object.yVel = max(-2, object.yVel);

        var v = (object.maxXVel + object.maxYVel) / 2 / this.intensity;

        object.xVel = constrain(object.xVel, -v, v);
        object.yVel = constrain(object.yVel, -v, v);
    };
};
gameObjects.addObject("dirtyBlock", createArray(DirtyBlock));

var HardCaseBlock = function(xPos, yPos, width, height, colorValue)
{
    Rect.call(this, xPos, yPos, width, height);
    this.color = colorValue || color(0, 0, 0, 170);

    this.snowflakes = 0;

    if(configs[levelInfo.theme] && configs[levelInfo.theme].usingHpRegenerators)
    {
        this.useCore = true;

        physics.getMiddleXPos(this);
        physics.getMiddleYPos(this);

        this.physics.sides = {
            up : true,
        };

        this.updateBoundingBox();
    }

    this.coreTimer = 0;
    this.vel = 0.1;

    this.coinAmt = levelInfo.regenCoinCost || 3;
    this.hpAmt = 1;

    this.draw = function()
    {
        noStroke();

        fill(this.color);
        fastRect(this.xPos, this.yPos, this.width, this.height);

        fill(255, 255, 255, 30);
        $pjs.rect(this.xPos + 5, this.yPos + 5, this.width - 10, this.height - 10, 5);

        if(this.useCore)
        {
            $pjs.pushMatrix();
                translate(this.middleXPos, this.middleYPos);
                rotate(this.k);
                fill(120, 200, 0, 100);
                ellipse(0, 0, this.halfWidth - 2, (this.halfHeight - 2) - (this.coreTimer));
            $pjs.popMatrix();

            fill(0, 0, 0, 100);
            $pjs.rect(this.xPos, this.yPos - 60 - 2, this.width, 14);

            textSize(7);
            textAlign(LEFT, TOP);
            fill(255, 255, 255, 200);
            text(this.coinAmt + "c/" + this.hpAmt + "hp", this.xPos + 4, this.yPos - 60 + 1);
        }
    };

    this.k = Math.round(random(-180, 180));

    this._lastUpdate = this.update;
    this.update = function()
    {
        this._lastUpdate();

        if(!this.useCore)
        {
            return;
        }

        this.k += 5;

        if(this.k > 360)
        {
            this.k = 0;
        }

        if(abs(this.coreTimer) > 5)
        {
            this.vel = -this.vel;
        }

        this.coreTimer += this.vel;
    };

    this.lastGiveTime = 0;

    this.onCollide = function(object)
    {
        if(object.arrayName === "player" && configs[levelInfo.theme] && configs[levelInfo.theme].usingHpRegenerators && 
            (game.autoCheckPoints || (object.activate !== undefined && object.activate(true))))
        {
            if(object.coins > 0 && millis() - this.lastGiveTime > 500 && object.hp < object.maxHp)
            {
                object.hp += this.hpAmt;
                object.hp = min(object.hp, object.maxHp);

                object.coins -= this.coinAmt;

                this.lastGiveTime = millis();
            }
        }
    };

    this.notExplosive = true;
};
gameObjects.addObject("hardCaseBlock", createArray(HardCaseBlock));

var Fog = function(xPos, yPos, diameter, colorValue)
{
    Circle.call(this, xPos, yPos, diameter);
    this.color = colorValue || color(0, 0, 0, 100);

    this.maxAlpha = alpha(this.color);

    this.physics.solidObject = false;
    this.physics.skipCollision = true;

    this.maxLife = 100;
    this.life = 100;

    this.gravity = 0;

    this.angle = 0;
    this.angleVel = radians(random(-2, 2));

    this.speed = 0.4;

    this.maxRadius = this.radius;

    this.lastUpdate_ = this.update;
    this.update = function()
    {
        if(this.diameter < this.maxDiameter)
        {
            this.diameter += 1;
        }else{
            this.diameter = this.maxDiameter;
             this.grown = true;
        }

        this.life -= 0.5;

        if(this.life <= 1)
        {
            this.life = 1;
            this.remove();
            this.draw = function() {};
        }

        this.color = color(red(this.color), green(this.color), blue(this.color), this.life * this.maxAlpha / this.maxLife);
        
        this.angle += this.angleVel;

        this.xPos += sin(this.angle) * this.speed;
        this.yPos += cos(this.angle) * this.speed;

        if(millis() % 1000 >= 800)
        {
            this.angleVel = radians(random(-2, 2));
        }
        else if(millis() % 1000 >= 700)
        {
            if(this.xPos + this.radius < levelInfo.xPos || 
               this.yPos + this.radius < levelInfo.yPos || 
               this.xPos - this.radius > levelInfo.xPos + levelInfo.width || 
               this.yPos - this.radius > levelInfo.yPos + levelInfo.height)
            {
                this.remove();
                this.draw = function() {};
            }
        }

        this.updateBoundingBox();
    };
};
gameObjects.addObject("fog", createArray(Fog));

var FogMachine = function(xPos, yPos, width, height, colorValue)
{
    Rect.call(this, xPos, yPos, width, height);
    this.color = colorValue || color(0, 0, 0, 170);

    this.physics.solidObject = false;

    this.draw = function() {};

    this.fogPerUpdate = 3;
    this.updateTime = 420;
    this.lastUpdateTime = millis();

    physics.getMiddleXPos(this);
    physics.getMiddleYPos(this);

    this.update = function()
    {
        if(millis() - this.lastUpdateTime > this.updateTime)
        {
            var fogs = gameObjects.getObject("fog"); 

            for(var i = 0; i < this.fogPerUpdate; i++)
            {
                fogs.add(this.middleXPos + random(-10, 10), this.middleYPos + random(-10, 10), 0);

                var fog = fogs.getLast();
                fog.angle = radians(/*random(0, 70) + 160*/random(0, 360));
                fog.maxDiameter = random(3, 5) * 4;

                cameraGrid.addReference(fog);
            }

            this.lastUpdateTime = millis();
        }
    };
};
gameObjects.addObject("fogMachine", createArray(FogMachine));

var Snow = function(xPos, yPos, width, height, colorValue, collisionOff)
{
    Rect.call(this, xPos, yPos, width, height);
    this.color = colorValue || color(255, 255, 255);
    addParticleRules(this);

    this.isFlake = random(0, 1) < 0.5;

    this.draw = function() 
    {
        if(this.isFlake)
        {
            stroke(this.color);
            strokeWeight(1.3);
            $pjs.pushMatrix();
            translate(this.xPos, this.yPos);
            rotate(this.angle);
            
            line(this.halfWidth, -this.halfHeight, -this.halfWidth, this.halfHeight);
            line(-this.halfWidth, 0, this.halfWidth, 0);
            line(-this.halfWidth, -this.halfHeight, this.halfWidth, this.halfHeight);
            line(0, -this.halfHeight, 0, this.halfHeight);
            
            $pjs.popMatrix();

            return;
        }

        fill(this.color);
        ellipse(this.xPos, this.yPos, this.width, this.height);
    };
    
    this.xVel = 0;
    this.maxXVel = 2;
    this.xDeacl = 0.2;

    this.yVel = 0;
    this.maxYVel = Number(random(1, 2).toFixed(2)) + 0.7;

    this.minYVel = -3;

    this.angle = 360 / 2;
    this.angleVel = (random(0, 100) > 50) ? -2 : 2;
    this.gravity = 0.053;

    this.inAir = true;
    
    this.zPos = 1;
    this.lastUpdate1 = this.update;

    this.offset = floor(random(-500, 500));

    this.physics.skipCollision = (random(0, 1) < 0.3);

    this.meltTimer = random(80, 150) * 2.5 * 2;

    this.speedFall = 0.005;

    this.update = function()
    {
        this.lastUpdate1();
        this.xVel = constrain(this.xVel, -this.maxXVel, this.maxXVel);
        this.xPos += this.xVel;

        if(this.xVel > 0)
        {
            this.xVel -= this.xDeacl;
        }
        else if(this.xVel < 0)
        {
            this.xVel += this.xDeacl;
        }
        if(this.xVel < this.xDeacl && this.xVel > -this.xDeacl)
        {
            this.xVel = 0;
        }

        if(this.touchedObject)
        {
            this.meltTimer--;
        }

        if(this.meltTimer < 0)
        {
            this.inAir = true;
        }

        if(this.inAir)
        {
            this.yVel += this.gravity;
            this.yVel = constrain(this.yVel, -this.maxYVel, this.maxYVel);

            if(this.angle < 0 || this.angle > 360)
            {
                this.angleVel = -this.angleVel;    
            }
            this.angle += this.angleVel;
        }

        this.maxYVel += this.speedFall;

        this.yPos += this.yVel;

        if(abs(this.yVel) > this.maxYVel * 0.05)
        {
            this.inAir = true;
        }

        if(this.yPos >= levelInfo.height + this.height || this.yPos >= cam.focusYPos + cam.halfHeight)
        {
            this.remove();
        }
    };

    this.hitRect = 0;

    this.onCollide = collisionOff ? this.onCollide : this.onCollide = function(object)
    {
        if(object.physics.shape === "slope")
        {
            this.physics.skipCollision = true;
        }
        else if(object.arrayName === "snowLayer" || object.arrayName === "snowBlock")
        {
            return;
        }
        if(object.arrayName === "lava")
        {
            this.remove();
            return;
        }
        else if(object.arrayName === "ladder" && random(0, 1) <= 0.06 && object.snowflakes < 5)
        {
            object.snowflakes++; 

            this.inAir = false;
            this.yVel = 0;
            return;
        }
        if(object.physics.shape === "rect" && object.physics.solidObject)
        {
            if(typeof object.snowflakes !== "undefined" && !this.slidObject)
            {
                object.snowflakes++; 

                if(object.snowflakes >= 5 && !object.snowLayers)
                {
                    if(!object.snowLayered)
                    {
                        object._lastDraw = object.draw;
                        object.draw = function()
                        {
                            this._lastDraw();
                            noStroke();
                            fill(250, 250, 250, 215);
                            fastRect(this.xPos, this.yPos, this.width, this.height * 0.15);
                        };

                        object.snowLayered = true;
                    }

                    object.snowLayers = 1;
                }
                else if(object.snowflakes % 5 >= 4 && (object.snowLayers === 1 || object.snowLayers === 2))
                {
                    var hy = object.height * 0.1;

                    gameObjects.getObject("snowLayer").add(object.xPos, object.yPos - hy * object.snowLayers, object.width, hy);
                    cameraGrid.addReference(gameObjects.getObject("snowLayer").getLast());
                    
                    object.snowLayers++;
                }
            }

            if(object.physics.movement === "dynamic")
            {
                this.xVel += object.xVel * 0.1;
                this.yVel += object.yVel * 0.4;
            }
            else if(this.zPos >= -2 && this.zPos <= 2)
            {
                if(random(0, 100) > 50 && !this.slidObject)
                {
                    if(this.yPos < object.yPos + object.height * 0.1)
                    {
                        this.inAir = false;
                        this.yPos = object.yPos - 1;
                        this.yVel = 0;
                    }
                    this.touchedObject = true;
                }else{
                    this.zPos = 4;
                }
            }

            if(object.physics.movement === "static")
            {
                this.slidObject = true;
                this.physics.skipCollision = true;
            }
        }
    };
};
gameObjects.addObject("snow", createArray(Snow));

var SnowLayer = function(xPos, yPos, width, height)
{
    DynamicRect.call(this, xPos, yPos, width, height);
    this.color = fill(250, 250, 250, 210);

    this.maxXVel = 2;
    this.isSnowLayer = true;

    this.avoidCollision = function(object)
    {
        return object.physics.shape === "slope" || object.arrayName === "bubbleShield";
    };

    this.onCollide = function(object, info)
    {
        if(object.arrayName === "bubbleShield")
        {
            return;
        }

        //Add snow on blocks
        if(typeof object.snowflakes !== "undefined" && object.physics.shape === "rect" && 
            this.yPos < object.yPos && !object.snowLayered)
        {
            object._lastDraw = object.draw;
            object.draw = function()
            {
                this._lastDraw();
                noStroke();
                fill(250, 250, 250, 215);
                fastRect(this.xPos, this.yPos, this.width, this.height * 0.15);
            };

            object.snowLayered = true;
            return;
        }

        if(object.isLifeForm && object.physics.shape === "rect")
        {
            var hy = object.yPos + object.height;
            if(hy > this.yPos && hy <= this.yPos + this.height &&
                (info.side === "left" && object.xVel > 0 || 
                info.side === "right" && object.xVel < 0))
            {
                object.yPos = this.yPos - object.height;
                object.xPos += object.xVel;
                this.xVel = 0;
                return;
            }
        }

        if(object.isSnowLayer)
        {
            this.yVel = 0;
        }

        this.xPos += object.xVel / 2.5 || 0;
    };
};
gameObjects.addObject("snowLayer", createArray(SnowLayer));

var SnowBall = function(xPos, yPos, diameter)
{
    DynamicCircle.call(this, xPos, yPos, diameter);
    this.color = color(240, 240, 240, 250);

    this.__lastOnCollide = this.onCollide;
    this.onCollide = function(object, info)
    {
        //Add snow on blocks
        if(typeof object.snowflakes !== "undefined" && object.physics.shape === "rect" && 
            this.yPos + this.radius - 1 <= object.yPos && !object.snowLayered)
        {
            object._lastDraw = object.draw;
            object.draw = function()
            {
                this._lastDraw();
                noStroke();
                fill(250, 250, 250, 215);
                fastRect(this.xPos, this.yPos, this.width, this.height * 0.15);
            };

            object.snowLayered = true;
            return;
        }
        this.__lastOnCollide(object, info);
    };
};
gameObjects.addObject("snowBall", createArray(SnowBall));

var SnowBlock = function(xPos, yPos, width, height, colorValue, layoutType)
{
    Rect.call(this, xPos, yPos, width, height, colorValue || color(200, 200, 255));

    this.sWidth = this.width * 0.1;
    this.sHeight = this.height * 0.1;
    this.tWidth = this.width * 0.15;
    this.tHeight = this.height * 0.15;

    this.snowflakes = 0;

    this.loadDraw = function()
    {
        if(typeof storedImages["snowBlock" + (layoutType || "")] === "undefined")
        {
            switch(layoutType)
            {
                case "other" :
                    this.xSize = this.width / 12;
                    this.ySize = this.height / 12;
                    this.layout = [
                        "  0   0   ",
                        "  0   0   ",
                        "  0   0   ",
                        "0   0   0 ",
                        "0   0   0 ",
                        "0   0   0 ",
                        "  0   0   ",
                        "  0   0   ",
                        "  0   0   ",
                        "0   0   0 ",
                        "0   0   0 ",
                        "0   0   0 ",
                    ];
                    break;

                default :
                    this.xSize = this.width / 8;
                    this.ySize = this.height / 8;
                    this.layout = [
                        "00000000",
                        "       0",
                        "000000 0",
                        "0    0 0",
                        "0 0  0 0",
                        "0 0000 0",
                        "0      0",
                        "00000000",
                    ];
                    break;
            }

            this.draw = function()
            {
                fill(this.color);
                fastRect(this.xPos, this.yPos, this.width, this.height);

                fill(0, 0, 0, 30);
                fastRect(this.xPos + this.sWidth, this.yPos + this.sHeight, this.width - this.sWidth * 2, this.height - this.sHeight * 2);

                fill(255, 255, 255);
                for(var i = 0; i < this.layout.length; i++)
                {
                    for(var j = 0; j < this.layout[i].length; j++)
                    {
                        switch(this.layout[i][j])
                        {
                            case '0' :
                                fastRect(this.xPos + j * this.xSize, this.yPos + i * this.ySize, this.xSize, this.ySize);
                                break;
                        }
                    }
                }
            };

            screenUtils.loadImage(this, true, "snowBlock" + (layoutType || ""), undefined, undefined, undefined, 190);
        }else{
            this.draw = function()
            {
                image(storedImages["snowBlock" + (layoutType || "")], this.xPos, this.yPos, this.width, this.height);
            };
        }
    };

    this.loadDraw();

    screenUtils.speedUpImage(storedImages["snowBlock" + (layoutType || "")]);

    this.physics.movement = "dynamic";
    this.gravity = 0.06;

    this.oxVel = 0;
    this.oyVel = 0;

    this.maxOXVel = 0;
    this.maxOYVel = 8;

    this.xVel = 0;
    this.yVel = 0;

    var self = this;

    this.coolDown = 0;

    this.addCheckRect = function(xPos, yPos, direction)
    {
        var rects = gameObjects.getObject("rect");

        rects.add(xPos, yPos, this.width, this.height);

        this.checkRect = rects.getLast();

        this.checkRect.physics.solidObject = false;
        this.checkRect.physics.movement = "dynamic";

        this.checkRect.boundingBox.xPos += 2;
        this.checkRect.boundingBox.yPos += 2;
        this.checkRect.boundingBox.width -= 4;
        this.checkRect.boundingBox.height -= 4;

        this.checkRect.draw = function() {};

        this.checkRect.timer = 0;
        this.checkRect.update = function()
        {
            if(this.timer >= 3)
            {
                self.moveDir = direction;
               
                self.busyChecking = false;
                this.remove();
                this.onCollide = function() {};
            }

            this.timer++;
        };
        this.checkRect.onCollide = function(object)
        {
            physics.getMiddleXPos(self);
            physics.getMiddleXPos(object);

            if(object.arrayName === self.arrayName && object.yPos === this.yPos && object.index !== self.index)
            {
                object.checkIfSafe(direction);
            }
            if(object.physics.solidObject && object.arrayName !== "snow" && object.arrayName !== "snowLayer")
            {
                self.moveDir = "";
                self.busyChecking = false;
                this.remove();
                this.onCollide = function() {};
            }
        };

        cameraGrid.addReference(this.checkRect);
    };

    this.checkIfSafe = function(direction)
    {
        if(this.busyChecking && millis() - this.coolDown > 1000)
        {
            return;
        }

        switch(direction)
        {
            case "left" :
                this.addCheckRect(this.xPos - this.width, this.yPos, "left");
                this.busyChecking = true;
                this.coolDown = millis();
                break;

            case "right" :
                this.addCheckRect(this.xPos + this.width, this.yPos, "right");
                this.busyChecking = true;
                this.coolDown = millis();
                break;
        }
    };

    this.lastMoveDir = "";

    this.update = function()
    {
        this.xVel = 0;
        this.yVel = 0;

        if(this.lastMoveDir !== "" && this.moveDir !== "")
        {
            this.moveDir = "";
        }
        else if(!this.lastMoved)
        {
            this.busyChecking = false;
        }

        if(this.lastMoved)
        {
            this.moveDir = "";
            this.busyChecking = true;
        }

        this.lastMoved = false;

        if(!this.busyChecking)
        {
            if(this.moveDir === "left")
            {
                this.xPos -= this.width;
                cameraGrid.addReference(this);
                this.moveDir = "";

                this.lastMoved = true;
            }
            else if(this.moveDir === "right")
            {
                this.xPos += this.width;
                cameraGrid.addReference(this);
                this.moveDir = "";

                this.lastMoved = true;
            }else{
                this.oyVel += this.gravity;
                this.oyVel = constrain(this.oyVel, -this.maxOYVel, this.maxOYVel);

                this.yPos += this.oyVel;

                this.oxVel = constrain(this.oxVel, -this.maxOXVel, this.maxOXVel);
                this.xPos += this.oxVel;
            }
        }

        this.updateBoundingBox();
    };

    this.updateBoundingBox = function()
    { 
        this.boundingBox.xPos = this.xPos + 2;
        this.boundingBox.yPos = this.yPos + 2;
        this.boundingBox.width = this.width - 4;
        this.boundingBox.height = this.height - 4;
    };

    this.updateBoundingBox = function()
    {
        this.boundingBox.xPos = this.xPos;
        this.boundingBox.yPos = this.yPos;
    };

    this.avoidCollision = function(object)
    {
        return (object.arrayName === "snowLayer" || object.height <= 10 ||
               object.physics.shape === "circle" && object.physics.solidObject && object.physics.movement === "dynamic");
    };

    this.onCollide = function(object, info)
    {   
        if(object.isLifeForm)
        {
            switch(true)
            {
                case (info.side === "left" || info.side === "right") :
                    object.xVel = 0;
                    break;

                case (info.side === "up" || info.side === "down") :
                    object.yVel = 0;
                    break;
            }
        }

        if(object.arrayName === "water" && !this.busyChecking)
        {
            this.oyVel = -this.gravity;
            this.inLiquid = true;
        }
        else if(object.arrayName === "ninjaStar" || object.arrayName === "xStar")
        {
            if(object.xPos > this.middleXPos)
            {
                if(object.lastXPos > object.xPos)
                {
                    this.checkIfSafe("left");
                    this.recheck = false;
                }
            }else{
                if(object.lastXPos < object.xPos)
                {
                    this.checkIfSafe("right");
                    this.recheck = false;
                }
            }

            object.remove();
        }
    };
};
gameObjects.addObject("snowBlock", createArray(SnowBlock));

var Rain = function(xPos, yPos, width, height, colorValue, collisionOff)
{
    Rect.call(this, xPos, yPos, width, height);
    this.color = colorValue || color(20, 90, 220, random(70, 150));
    addParticleRules(this);

    this.gravity = 0.03;
    this.draw = function() 
    {
        noStroke();
        fill(this.color);
        ellipse(this.xPos, this.yPos, this.width, this.height); 
    };
    
    this.yVel = 0;
    this.maxYVel = 3;
    
    this.xVel = 0;
    this.maxXVel = 0;

    this.offset = floor(random(-500, 500));

    this.update = function()
    {
        this.xVel = constrain(this.xVel, -this.maxXVel, this.maxXVel);
        this.xPos += this.xVel;
        
        this.yVel += this.gravity;
        this.yVel = constrain(this.yVel, -this.maxYVel, this.maxYVel);
        this.yPos += this.yVel;

        if(this.yPos >= levelInfo.height + this.height)
        {
            this.remove();
        }

        //Huge performance boost!
        this.physics.skipCollision = ((millis() - this.offset) % 1000 > 700);
    };

    this.onCollide = collisionOff ? this.onCollide : function(object)
    {
        if(object.type === "block" && object.physics.solidObject)
        {
            if(this.yPos < object.yPos + object.height * 0.1)
            {                    
                this.remove();
            }
        }
    };
};
gameObjects.addObject("rain", createArray(Rain));

var Net = function(xPos, yPos, width, height, colorValue)
{
    Rect.call(this, xPos, yPos, width, height);
    this.color = colorValue || color(0, 0, 0);

    this.physics.solidObject = false;
    this.type = "use";
    
    this.snowflakes = 0;

    this.size = (this.width + this.height) / 2;
    this.step = this.size / 3;

    this.tightness = 0.2;

    this.arrayName = "net";

    this.loadDraw = function()
    {
        if(typeof storedImages[this.arrayName] === "undefined")
        {
            this.img = createGraphics(this.width + 1, this.height + 1, P2D);
            this.img.beginDraw();
                this.img.smooth();
                this.img.noFill();
                this.img.strokeWeight(1);
                this.img.stroke(0, 0, 0);

                for(var i = 0; i < this.size; i += this.step)
                {
                    this.img.rect(i / 2, i / 2, this.width - i, this.height - i, 4);
                }
            this.img.endDraw();

            storedImages[this.arrayName] = this.img;
        }else{
            this.img = storedImages[this.arrayName];
        }
    };

    this.loadDraw();

    this.draw = function()
    {
        image(this.img, this.xPos, this.yPos, this.width, this.height);
    };

    this.onCollide = function(object)
    {
        if(object.isLifeForm)
        {
            object.xVel = constrain(object.xVel, -this.tightness,  this.tightness);
            object.yVel = constrain(object.yVel, -this.tightness,  this.tightness);
        }
    };
};
gameObjects.addObject("net", createArray(Net));

var Cloud = function(xPos, yPos, width, height, colorValue, weather, cloudType, noFade, collisionOff)
{
    Rect.call(this, xPos, yPos, width, height);
    this.color = colorValue;
    this.weather = weather || "rain";
    
    this.physics.solidObject = false;

    this.cloudType = cloudType || "light";
    this.switchType = this.cloudType;
        
    this.maxWaterLife = 100;
    this.waterLife = this.maxWaterLife;

    if(weather === undefined || weather === "")
    {
        this.silent = true;
    }

    this.rain = createArray(Rain);
    this.snow = createArray(Snow);

    this.alpha = 255;
    this.notExplosive = true;

    this.setColor = function()
    {
        switch(this.cloudType)
        {
            case "dark" :
                this.color = color(255/2, 255/2, 255/2, this.alpha);
                break;
                
            case "light" :
                this.color = color(255, 255, 255, this.alpha);
                break;
                
            case "fade" :
                this.color = color(255, 255, 255, 255, this.alpha);
                break;
        }
    };
    
    this.sleepTime = 0;
    this.startSleepTime = 0;
    this.sleeping = false;

    this.sleep = function(time)
    {
        this.sleepTime = time; // Time in millis!
        this.sleeping = true;
        this.startSleepTime = millis();
    };

    this.setColor();
    
    this.setWeather = function(weather)
    {
        this.weather = weather;
    };

    this.draw = function() 
    {
        if(this.useInside)
        {
            this.rain.draw();
            this.snow.draw();
        }

        noStroke();
        fill(this.color);
        ellipse(this.xPos + this.width * 0.5, this.yPos + this.height * 0.35, this.width * 0.5, this.height * 0.6);
        ellipse(this.xPos + this.width * 0.3, this.yPos + this.height * 0.6, this.width * 0.5, this.height * 0.6);
        ellipse(this.xPos + this.width * 0.67, this.yPos + this.height * 0.6, this.width * 0.6, this.height * 0.7);
    };
    
    this.lastUpdate1 = this.update;

    this.addParticle = function(arrayName, w, h)
    {
        var inputSize = random(3, 8) + 3;
        w = w || inputSize;
        h = h || inputSize;
        var inputXPos = Math.round(random(this.xPos + this.width * 0.1, this.xPos + this.width * 0.9));
        if(inputXPos > cameraGrid.xPos + (cam.upperLeft.col) * cameraGrid.cellWidth && 
           inputXPos < cameraGrid.xPos + (cam.lowerRight.col + 1) * cameraGrid.cellWidth)
        {
            var inputYPos = this.yPos + this.halfHeight;
            if(inputYPos > cameraGrid.yPos + (cam.upperLeft.row) * cameraGrid.cellHeight && 
            inputYPos < cameraGrid.yPos + (cam.lowerRight.row + 1) * cameraGrid.cellHeight)
            {
                if(this.useInside)
                {
                    if(this.weather === "rain")
                    {
                        this.rain.add(inputXPos, inputYPos, w, h, undefined, collisionOff);
                    }
                    else if(this.weather === "snow")
                    {
                        this.snow.add(inputXPos, inputYPos, w, h, undefined, collisionOff);
                    }
                }else{
                    if(arrayName === "snow" || arrayName === "rain")
                    {
                        w -= 3.4;
                        h -= 3.4;
                    }
                    gameObjects.getObject(arrayName).add(inputXPos, inputYPos, w, h, undefined, collisionOff);
                    cameraGrid.addReference(gameObjects.getObject(arrayName).getLast());
                }
            }
        }
    };

    this.lastRainTime = 0;
    this.lastSnowTime = 0;

    this.nextRainTime = 30;
    this.nextSnowTime = 250;

    this.delag = 40;

    this.update = function()
    {
        this.lastUpdate1();

        if(this.silent)
        {
            return;   
        }

        if(this.sleeping && millis() - this.startSleepTime >= this.sleepTime)
        {
            this.sleeping = false;
        }

        if(this.waterLife >= 0 && !this.sleeping)
        {
            switch(this.weather)
            {
                case "rain" :
                   if(millis() - this.lastRainTime > this.nextRainTime)
                    {
                        this.addParticle("rain");

                        if(this.hasLife)
                        {
                            this.waterLife--;
                        }

                        this.nextRainTime = random(40, 160) + this.delag;
                        this.lastRainTime = millis();
                    }
                    break;
                    
                case "snow" :
                    if(millis() - this.lastSnowTime > this.nextSnowTime)
                    {
                        this.addParticle("snow");

                        if(this.hasLife)
                        {
                            this.waterLife--;
                        }

                        this.nextSnowTime = random(60, 280) + this.delag;
                        this.lastSnowTime = millis();
                    }
                    break;
            }
           
        }

        if(this.waterLife < 0)
        {
            this.cloudType = this.switchType;
            if(this.cloudType !== "fade")
            {
                this.waterLife = this.maxWaterLife;
            }
            switch(this.cloudType)
            {
                case "dark" :
                    this.switchType = "light";
                    break;
                    
                case "light" :
                    this.switchType = "fade";
                    break;
            }
        }
        
        if(this.cloudType !== this.switchType)
        {
            switch(this.switchType)
            {
                case "light" :
                    var input = 255 - this.waterLife * 127.5 / this.maxWaterLife;
                    this.color = color(input, input, input, 255);
                    break;
            }
        }
        if(this.cloudType === "fade" && this.waterLife < 0)
        {
            this.color = color(red(this.color), green(this.color),
            blue(this.color), alpha(this.color) - 1);
        }

        if(noFade)
        {
            this.color = color(red(this.color), green(this.color),
            blue(this.color), 255);
        }

        if(this.useInside)
        {
            this.rain.update();
            this.snow.update();
        }
    };
};
gameObjects.addObject("cloud", createArray(Cloud));

var NinjaGuard = function(xPos, yPos, diameter)
{
    Circle.call(this, xPos, yPos, diameter);

    this.physics.solidObject = false;
    this.type = "power";

    this.color = color(40, 120, 200, 130);

    this.font = createFont("monoSpace");

    this.draw = function()
    {
        fill(this.color);
        circle(this.xPos, this.yPos, this.diameter);

        $pjs.pushMatrix();
            fill(70, 130, 200, 200);
            translate(this.xPos, this.yPos);
            scale(this.flip, 1);
            stroke(0, 120, 150);
            strokeWeight(2);
            circle(0, 0, this.diameter * 0.8);

            fill(0, 0, 0, 70);
            textSize(this.diameter / 2.5);
            textFont(this.font);
            textAlign(CENTER, CENTER);
            text("NG", 0, 0);
        $pjs.popMatrix();

        noStroke();

        var av = radians(this.angle);
        var ac = av * 2;
        var az = TWO_PI / 8;
        var r = this.radius + 16;

        fill(70, 160, 120, 160);

        for(var a = 0; a < TWO_PI; a += az)
        {
            var ox = this.xPos + sin(a + av) * r,
                oy = this.yPos + cos(a + av) * r;

            circle(ox, oy, 8);

            for(var a2 = 0; a2 < TWO_PI; a2 += az)
            {
                circle(ox + sin(a2 + ac) * 8, oy + cos(a2 + ac) * 8, 5);
            }
        }
    };

    this.flip = 1;
    this.flipVel = 0.05;

    this.angle = 0;
    this.angleVel = 3;

    this.nextChange = millis();

    this._lastUpdate = this.update;
    this.update = function()
    {
        if(this.flip > 1 || this.flip < -1)
        {
            this.flipVel = -this.flipVel;
        }
        this.flip += this.flipVel;

        this.angle += this.angleVel;
        this.angle %= 360;

        if(millis() - this.nextChange > 3000)
        {
            this.angleVel = -this.angleVel;
            this.nextChange = millis();
        }

        this._lastUpdate();
    };

    this.actObject = {
        description : "Deflect Ninja Stars by timing the button press correctly.",
        key : '1',
        name : "Ninja Guard",
        start : function(object, power)
        {
            //Spam protection
            if((typeof power.hitEndedTime === "undefined" || millis() - power.hitEndedTime >= 200) && 
               (typeof power.hitStartedTime === "undefined" || millis() - power.hitStartedTime >= 400))
            {
                power.hitStartedTime = millis();
                power.on = true;
            }
        },
        avoidDamage : function(hitObject, amt, object, power)
        {
            var diff = millis() - power.hitStartedTime;

            if(power.on)
            {
                if(hitObject.arrayName === "ninjaStar" || hitObject.arrayName === "launchBall" || hitObject.arrayName === "wispIce")
                {                    
                    return (diff > 16 && diff < 450);
                }
                else if(hitObject.arrayName === "voxelizer")
                {
                    return true;
                }
            }

            return false;
        },
        update : function(object, power)
        {
            if(millis() - power.startTime > 500)
            {
                if(power.on)
                {
                    power.hitEndedTime = millis();
                    power.on = false;
                }
            }
        },
        draw : function(object, power)
        {
            if(!power.on)
            {
                return;
            }

            physics.getMiddleXPos(object);
            physics.getMiddleYPos(object);

            var diff = millis() - power.hitStartedTime;
            
            var oldDiff = diff;
            if(diff > 450 - 30)
            {
                diff = 450;
            }

            var s = (0.1 + diff * 1.15 / 340);
            var sFill = ((oldDiff >= 280) ? (oldDiff - 280) * 170 / 270 : 0);

            noFill();
            strokeWeight(4 + diff * 4 / 350);
            stroke(80, 20, 160, 170 - sFill);
            ellipse(object.middleXPos, object.middleYPos, object.width * s, object.height * s);
            fill(31, 89, 235, 170 - sFill);
            ellipse(object.middleXPos, object.middleYPos, object.width * s, object.height * s);
            noStroke();
        },
    };

    this.onCollide = function(object)
    {
        if(object.arrayName === "player")
        {
            object.xVel = 0;
            object.yVel = 0;

            if(typeof object.discoveredPowers[this.arrayName] === "undefined")
            {
                this.messages = {
                    up : true,
                    "start" : {
                        messages : [{
                            message : "You got a new Power-up!",
                            color : color(255, 255, 255, 160),
                        }, {
                            message : "Ninja Guard!\n",
                            color : color(0, 140, 100, 160),
                        }],
                        choices : {
                            "---" : "..."
                        },
                    },
                    "---" : {
                        message : "With Ninja Guard you can dodge\nNinja stars by timing it correctly.\nJust press Z or L !",
                        choices : {
                            "exit" : "..."
                        }
                    }
                };

                talkHandler.start(this.messages, "start", "");

                var self = this;
                talkHandler.onEnd = function()
                {
                    self.remove();
                    self.draw = function() {};
                };
            }else{
                this.remove();
                this.draw = function() {};
            }

            object.discoveredPowersHandler.addPower(this.arrayName, this.actObject);
        }
    };
};
gameObjects.addObject("ninjaGuard", createArray(NinjaGuard));

var NinjaStarShooter = function(xPos, yPos, diameter)
{
    Circle.call(this, xPos, yPos, diameter);

    this.physics.solidObject = false;
    this.type = "power";

    this.color = color(101, 7, 160);

    this.angle = 0;
    this.xOut = 0;
    this.xOutVel = 1;

    this.draw = function()
    {
        noStroke();
        fill(this.color);
        circle(this.xPos, this.yPos, this.diameter);

        noFill();
        stroke(0, 90, 170);
        strokeWeight(2);
        ellipse(this.xPos, this.yPos, (this.diameter - this.xOut) * 1.5, this.diameter * 1.5);

        $pjs.pushMatrix();
            translate(this.xPos, this.yPos);
            rotate(this.angle);
            stroke(0, 90, 30);
            strokeWeight(3);
            for(var a = 0; a < 360; a += 60)
            {
                arc(0, 0, this.diameter, this.diameter, radians(a), radians(a + 20));
            }
        $pjs.popMatrix();

        stroke(0, 0, 0, 100);
        strokeWeight(1);
        var vs = (millis() % 1000 / 1000);
        circle(this.xPos, this.yPos, this.diameter * vs);

        vs = ((millis() + 500) % 1000 / 1000);
        circle(this.xPos, this.yPos, this.diameter * vs);
        noStroke();
    };

    this._lastUpdate = this.update;
    this.update = function()
    {
        this._lastUpdate();

        if(this.xOut > this.diameter || this.xOut < 0)
        {
            this.xOutVel = -this.xOutVel;
        }

        this.xOut += this.xOutVel;

        this.angle += 2;

        if(this.angle > 360)
        {
            this.angle = 0;
        }
    };

    this.messages = {
        "start" : {
            messages : [{
                message : "You got another power-up\n",
                color : color(255, 255, 255, 160),
            }, {
                message : "Ninja Star Shooter!",
                color : color(0, 140, 100, 160),
            }],
            choices : {
                "---" : "..."
            },
        },
        "---" : {
            message : "With this new power up you can shoot\nNinja Stars! Press 'z' or 'l' to fire!",
            choices : {
                "last" : "..."
            }
        },
        "last" : {
            message : "Also remember you can press\nkeys like '1' or '2' to switch power-ups.",
            choices : {
                "exit" : "..."
            }
        }
    };

    this.actObject = {
        description : "Shoot Ninja Stars at stuff by pressing 'z' or 'l'!\nYou can even hold space to shoot backwards.",
        key : '2',
        name : "Ninja Star Shooter",
        hitStartedTime : 0,
        start : function(object, power)
        {
            
        },
        update : function(object, power, activateKey)
        {
            if(activateKey && millis() - power.hitStartedTime > 700)
            {
                power.launchStar(object, power);
                power.hitStartedTime = millis();
            }
        },
        launchStar : function(object, power)
        {
            var xStars = gameObjects.getObject("xStar");
            xStars.add(object.xPos + object.halfWidth, object.yPos + object.halfHeight / 2, 14.5);

            sounds.mplaySound("swoosh.mp3");

            var xStar = xStars.getLast();
            xStar.likeLifeForm = true;

            xStar.lastRemove = xStar.remove;
            xStar.remove = function(objectB, scoreValue)
            {
                if(objectB && (objectB.dead || objectB.hp <= 0) && 
                  (objectB.isLifeForm || objectB.likeLifeForm) && !objectB.usedScore)
                {
                    object.score += scoreValue || objectB.scoreValue || 0;
                    objectB.usedScore = true;
                }
                return this.lastRemove.apply(this, arguments);
            };

            cameraGrid.addReference(xStar);

            xStar.outerXVel2 = (object.xFire < 0) ? -4 : 4;
            xStar.outerYVel2 = 0;

            if(object.controls.zoom())
            {
                xStar.outerXVel2 = (object.xFire < 0) ? -5 : 5;
            }
            if(object.throwInversed)
            {
                xStar.outerXVel2 *= 0.5;
            }

            xStar.setAngleVel = (object.xFire > 0) ? -3 : 3;
        },
    };

    this.onCollide = function(object)
    {
        if(object.arrayName === "player")
        {
            object.xVel = 0;
            object.yVel = 0;

            if(typeof object.discoveredPowers[this.arrayName] === "undefined")
            {
                talkHandler.start(this.messages, "start", "");

                var self = this;
                talkHandler.onEnd = function()
                {
                    self.remove();
                    self.draw = function() {};
                };
            }else{
                this.remove();
                this.draw = function() {};
            }

            object.discoveredPowersHandler.addPower(this.arrayName, this.actObject);
        }
    };
};
gameObjects.addObject("ninjaStarShooter", createArray(NinjaStarShooter));

var IceSplicer = function(xPos, yPos, diameter)
{
    Circle.call(this, xPos, yPos, diameter);

    this.physics.solidObject = false;
    this.type = "power";

    this.rectAngle = 0;
    this.vel = 3;
    
    this.color = color(191, 15, 115);
    this.color2 = color(221, 45, 145);

    this.draw = function() 
    {
        this.rectAngle += this.vel;
        this.size = this.radius * 1.1 * (this.rectAngle * 0.05) * 0.1;
        this.halfSize = this.size / 2;

        fill(this.color);
        circle(this.xPos, this.yPos, this.halfSize * 2.3);
        $pjs.pushMatrix();
        translate(this.xPos, this.yPos);
        rotate(this.rectAngle);
        fastRect(-this.halfSize, -this.halfSize, this.size, this.size);
        $pjs.popMatrix();
        fill(this.color2);
        circle(this.xPos, this.yPos, this.halfSize * 1.6);

        if(this.rectAngle > 360 || this.rectAngle < 0)
        {
            this.vel = -this.vel;  
        }
    };

    this.messages = {
        "start" : {
            messages : [{
                message : "You got a new power-up, ",
                color : color(255, 255, 255, 160),
            }, {
                message : "Ice Splicer.",
                color : color(0, 140, 100, 160),
            }],
            choices : {
                "next" : "..."
            }
        },
        "next" : {
            message : "You can now splice normal ice!",
            choices : {
                "last" : "..."
            }
        },
        "last" : {
            message : "Remember to only use this on\nice that is light blue but not clear.",
            choices : {
                "exit" : "..."
            }
        }
    };

    this.actObject = {
        description : "Only splice/break ice that is light blue but not clear. With\n'z' or 'l'! If it doesn't work, try throwing yourself at the ice.",
        key : '3',
        name : "Ice Splicer",
        lastRemoveTime : 0,
        onCollide : function(object, power, activateKey, hitObject, info)
        {
            if(activateKey && hitObject.triangular && hitObject.arrayName === "ice" && millis() - power.lastRemoveTime > 300)
            {
                hitObject.shatter();
                
                power.lastRemoveTime = millis();
            }
        },
    };

    this.onCollide = function(object)
    {
        if(object.arrayName === "player")
        {
            object.xVel = 0;
            object.yVel = 0;

            if(typeof object.discoveredPowers[this.arrayName] === "undefined")
            {
                talkHandler.start(this.messages, "start", "");

                var self = this;
                talkHandler.onEnd = function()
                {
                    self.remove();
                    self.draw = function() {};
                };
            }else{
                this.remove();
                this.draw = function() {};
            }

            object.discoveredPowersHandler.addPower(this.arrayName, this.actObject);
        }
    };
};
gameObjects.addObject("iceSplicer", createArray(IceSplicer));

var HookShot = function(xPos, yPos, diameter)
{
    Circle.call(this, xPos, yPos, diameter);

    this.messages = {
        up : true,
        "start" : {
            messages : [{
                message : "You got the ",
                color : color(255, 255, 255, 160),
            }, {
                message : "Hookshot!",
                color : color(0, 70, 200, 190),
            }],
            choices : {
                "next" : "..."
            }
        },
        "next" : {
            message : "Use this power up to connect to points.",
            choices : {
                "next2" : "..."
            }
        },
        "next2" : {
            message : "Controls: Right Click to connect to a\npoint. (A square in a circle) Right Click\noutside of the point to disconnect.",
            choices : {
                "exit" : "..."
            }
        },
    };

    this.draw = function()
    {
        image(loadedImages["hookShot"], this.xPos - this.radius, this.yPos - this.radius, this.diameter, this.diameter);
    };

    this.physics.solidObject = false;
    this.type = "power";

    var loops = 0;
    var swing = 0.2;

    this.actObject = {
        description : "Allows you to connect to points like a grappling hook.\nYou can also shoot certain enemies with this!",
        key : '4',
        name : "Hook Shot",
        onCollide : function(object, power, activateKey, hitObject, info)
        {
            // Do something here, not sure what.
        },
        vel : 10,
        maxPutLength : 200 + 40,
        _maxLength : 170 + 20,
        traveled : 0,
        stretched : 0,
        target : {},
        position : {
            x: 0,
            y: 0,
        },
        clickedPoint : function(x, y, object, power)
        {
            var place = cameraGrid.getPlace(x, y);

            var cell = cameraGrid[place.col][place.row];

            var point;
            for(var i in cell)
            {
                if(cell[i].arrayName === "point" && cell[i].index !== power._pointIndex && 
                   ((point = gameObjects.getObject("point")[cell[i].index]) !== undefined) &&
                    Math.pow(x - point.xPos, 2) + Math.pow(y - point.yPos, 2) < point.radius * point.radius * 5)
                {
                    power.ox = point.xPos;
                    power.oy = point.yPos;          
                    power._pointIndex = cell[i].index;          
                    return true;
                }
            }

            return false;
        },
        clickedRect : function(x, y, object, power)
        {
            var place = cameraGrid.getPlace(x, y);

            var cell = cameraGrid[place.col][place.row];

            var setObject;
            for(var i in cell)
            {
                if(((setObject = gameObjects.getObject(cell[i].arrayName)[cell[i].index]) !== undefined) && 
                    setObject.physics.solidObject && setObject.physics.shape === "rect" && setObject.physics.movement === "static" &&
                    x > setObject.xPos && x < setObject.width + setObject.xPos && 
                    y > setObject.yPos && y < setObject.height + setObject.yPos)
                {
                    return true;
                }
            }

            return false;
        },
        executeDamage : function(x, y, object, power)
        {
            var place = cameraGrid.getPlace(x, y);

            var cell = cameraGrid[place.col][place.row];

            var setObject;
            for(var i in cell)
            {
                if(!(setObject = gameObjects.getObject(cell[i].arrayName)[cell[i].index]))
                {
                    return;
                }

                if(cell[i].arrayName === "captainFleep")
                {
                    setObject.hs = this;
                }

                if(cell[i].arrayName === "gem" &&
                    x > setObject.xPos && x < setObject.width + setObject.xPos && 
                    y > setObject.yPos && y < setObject.height + setObject.yPos)
                {   
                    setObject.onCollect(player);

                    power.exit(object, power);
                }
                else if((cell[i].arrayName === "voxelizer" || cell[i].arrayName === "bat" || cell[i].arrayName === "captainFleep") &&
                    x > setObject.boundingBox.xPos && x < setObject.boundingBox.width + setObject.boundingBox.xPos && 
                    y > setObject.boundingBox.yPos && y < setObject.boundingBox.height + setObject.boundingBox.yPos)
                {
                    if(cell[i].arrayName === "bat")
                    {
                        setObject.takeDamage(object);
                    }else{
                        setObject.hp -= 1;
                    }
                    power.exit(object, power);
                }
            }
        },
        objectInWay : function(object, power)
        {
            var x = power.position.x;
            var y = power.position.y;

            // var place = cameraGrid.getPlace(object.xPo, object.yPos + object.halfHeight);
            // var cell = cameraGrid[place.col][place.row];

            var mx = object.xPos + object.halfWidth;
            var my = object.yPos + object.halfHeight;
            var colliding = observer.collisionTypes.rectrect.colliding;

            var oDown = object.yPos + object.height;
            var oRight = object.xPos + object.width;

            var d = 100 * 100;

            cameraGrid.addReference(object);

            var col, row, i, cell, setObject, down, right, dx, dy;

            for(col = object._places.upperLeft.col; col < object._places.lowerRight.col; col++)
            {
                for(row = object._places.upperLeft.row; row < object._places.lowerRight.row; row++)
                {
                    cell = cameraGrid[col][row];
                    for(i in cell)
                    {
                        if(((setObject = gameObjects.getObject(cell[i].arrayName)[cell[i].index]) !== undefined) && 
                            setObject.physics.solidObject && setObject.physics.shape === "rect" && setObject.physics.movement === "static")
                        {
                            down = setObject.yPos + setObject.height;
                            right = setObject.xPos + setObject.width;

                            dx = setObject.xPos + setObject.halfWidth - mx;
                            dy = setObject.yPos + setObject.halfHeight - my;

                            if(dy * dy + dx * dx < d && 
                                (object.yPos >= down && y < down ||                       
                                oDown <= setObject.yPos && y > setObject.yPos || 

                                object.xPos >= right && x < right ||                       
                                oRight <= setObject.xPos && x > setObject.xPos))
                            {
                                return true;
                            }
                        }
                    }
                }
            }

            return false;
        },
        mousePressed : function(object, power)
        {
            if(mouseButton !== RIGHT)
            {
                return;
            }

            power.maxLength = power._maxLength;
            power.maxLengthSq = power.maxLength * power.maxLength;

            /*--------------------------------------------------*/

            power.ox = (cam.focusXPos - cam.halfWidth) + mouseX;
            power.oy = (cam.focusYPos - cam.halfHeight) + mouseY;

            // if(!power.clickedPoint(power.ox, power.oy, object, power))
            // {
            //     if(power.working && power.arrived)
            //     {
            //         power.exit(object, power);
            //     }
            //     return;
            // }

            power.working = true;
            power.arrived = false;
            power.traveled = 0;

            power.target.x = power.ox;
            power.target.y = power.oy;

            power.position.x = object.xPos + object.halfWidth;
            power.position.y = object.yPos + object.halfHeight;

            power.momentum = 0;

            delete power.angle;
            delete power.swing;
            delete power.length;
            delete power.toAngle;
            delete power.angleVel;

            power.hanging = false;
        },
        onExit : function(object, power)
        {
            power.exit(object, power);
        },
        exit : function(object, power)
        {
            power.position.x = object.xPos + object.halfWidth;
            power.position.y = object.yPos + object.halfHeight;
            delete power._pointIndex;

            power.arrived = false;
            power.working = false;
            power.traveled = 0;
            power.stretched = 0;
            power.momentum = 0;

            delete power.angle;
            delete power.swing;
            delete power.length;
            delete power.angleVel;
            delete power.toAngle;

            power.hanging = false;
        },
        update : function(object, power)
        {
            power.active = true;

            if(!power.working)
            {
                return;
            }

            if(game.gameState === "load")
            {
                power.exit(object, power);
                return;
            }

            power.executeDamage(power.position.x, power.position.y, object, power);

            if(!power.arrived)
            {
                if(power.toAngle === undefined)
                {
                    var dx = power.target.x - power.position.x;
                    var dy = power.target.y - power.position.y;

                    power.toAngle = atan2(dy, dx);

                    power.maxLength = 1;
                }

                power.position.x += cos(power.toAngle) * power.vel;
                power.position.y += sin(power.toAngle) * power.vel;
                power.traveled += power.vel;

                if(power.traveled > power.maxPutLength || power.clickedRect(power.position.x, power.position.y, object, power))
                {
                    power.exit(object, power);
                    return;
                }

                // if(Math.abs(power.target.x - power.position.x) <= power.vel / 2 && Math.abs(power.target.y - power.position.y) <= power.vel / 2)
                if(power.clickedPoint(power.position.x, power.position.y, object, power))
                {
                    power.target.x = power.position.x = power.ox;
                    power.target.y = power.position.y = power.oy;
                    power.maxLength = dist(object.xPos + object.halfWidth, object.yPos + object.halfHeight, power.position.x, power.position.y);
                    power.arrived = true;
                }
            }else{
                if(!power.objectInWay(object, power))
                {
                    power.maxLength -= 25;
                }

                var dx = object.xPos + object.halfWidth - power.position.x;
                var dy = object.yPos + object.halfHeight - power.position.y;

                var angle = atan2(dy, dx);

                power.maxLength = max(1, power.maxLength);

                // object.xPos = ((power.position.x + cos(angle) * power.maxLength) - object.halfWidth);
                // object.yPos = ((power.position.y + sin(angle) * power.maxLength) - object.halfHeight);

                object.xPos -= (object.xPos - ((power.position.x + cos(angle) * power.maxLength) - object.halfWidth)) / 3;
                object.yPos -= (object.yPos - ((power.position.y + sin(angle) * power.maxLength) - object.halfHeight)) / 3;

                if(object.controls.down())
                {
                    // Go down here.
                }

                if(mouseIsPressed && mouseButton === RIGHT)
                { 
                    // power.exit(object, power);
                    // power.maxLength += 20;
                    power.mousePressed(object, power);
                    power.mousePressed(object, power);
                }
                else if(keys[" "])
                {
                    power.exit(object, power);
                }
            }
        },
        hang : function(object, power)
        {
            if(power.set)
            {
                object.xPos -= (object.xPos - ((power.position.x + cos(power.setAngle) * power.maxLength) - object.halfWidth)) / 5;
                object.yPos -= (object.yPos - ((power.position.y + sin(power.setAngle) * power.maxLength) - object.halfHeight)) / 5;

                if(object.controls.up())
                {
                    power.maxLength -= 5;
                    power.maxLength = Math.max(2, power.maxLength);
                    power.maxLengthSq = power.maxLength * power.maxLength;
                }
                if(object.controls.down())
                {
                    power.maxLength += 5;
                    power.maxLength = Math.min(power._maxLength, power.maxLength);
                    power.maxLengthSq = power.maxLength * power.maxLength;
                }

                if(!object.controls.up() && !object.controls.down())
                {
                    power.set = false;
                }
            }else{
                var ox = object.xPos + object.halfWidth;
                var oy = object.yPos + object.halfHeight;

                // This will change later.
                var length = power.maxLength;

                var speed = 28;

                var gravity = object.gravity;

                if(power.rate === undefined)
                {
                   power.rate = (gravity / length);
                }

                var aRate = (gravity / length);

                var aSpeed = 0.0005;

                if(power.rate > aRate)
                {
                    power.rate -= aSpeed;
                }
                if(power.rate < aRate)
                {
                    power.rate += aSpeed;
                }

                // Angle of how much to swing
                var theta = 2 * Math.PI / Math.sqrt(1 / power.rate) * power.momentum;
                
                // Get angle based on time and theta.
                var angle = HALF_PI + Math.min(theta * sin(power.rate * loops), Math.PI);
                // console.log(power.rate, power.momentum);

                // Update time for next loop
                loops += speed;

                var decay = 0.00001;

                var onEdge = false;

                if(angle >= HALF_PI + theta / 2)
                {
                    if(object.controls.left())
                    {
                        swing += 0.0024 * 2.7;
                        power.momentum = swing;
                    }
                    else if(object.controls.right())
                    {
                        swing -= 0.0024 * 1.4;
                        power.momentum = swing;
                    }
                }

                if(angle <= HALF_PI - theta / 2)
                {
                    if(object.controls.right())
                    {
                        swing += 0.0024 * 2.7;
                        power.momentum = swing;
                    }
                    else if(object.controls.left())
                    {
                        swing -= 0.0024 * 1.4;
                        power.momentum = swing;
                    }
                }

                swing -= 0.0007;

                if(object.controls.left() && angle <= HALF_PI)
                {
                    if(angle >= (HALF_PI + theta / 2) - 0.1)
                    {
                        power.momentum += swing;
                        onEdge = true;
                    }

                    var diff = abs(angle - HALF_PI);

                    if(diff < 0.004)
                    {
                        power.momentum += 0.01;
                    }
                }
                if(object.controls.right() && angle >= HALF_PI)
                {
                    if(angle <= (HALF_PI - theta / 2) + 0.1)
                    {   
                        power.momentum += swing;
                        onEdge = true;
                    }

                    var diff = abs(angle - HALF_PI);

                    if(diff < 0.004)
                    {
                        power.momentum += 0.01;
                    }
                }
                
                swing = constrain(swing, 0, 5.6);

                if(power.momentum > 0.001)
                {
                    power.momentum -= decay;
                }
                power.momentum = max(0, power.momentum);

                if(!onEdge)
                {
                    if(object.controls.up() && abs(HALF_PI - angle) < 12 * DEG_TO_RAD)// && abs(HALF_PI - angle) < 30 * DEG_TO_RAD)
                    {
                        power.maxLength -= 1;
                        power.maxLength = Math.max(2, power.maxLength);
                        power.maxLengthSq = power.maxLength * power.maxLength;

                        if(power.maxLength < 3)
                        {
                            swing = 0;
                            power.momentum = 0;
                            power.maxLength = 3.1;
                            return;
                        }

                        if(power.maxLength > 2)
                        {
                            power.setAngle = angle;
                            power.setLength = power.maxLength;
                            power.set = true;

                            return;
                        }
                    }
                    if(object.controls.down() && abs(HALF_PI - angle) < 12 * DEG_TO_RAD)
                    {
                        power.maxLength += 1;
                        power.maxLength = Math.min(power._maxLength, power.maxLength);
                        power.maxLengthSq = power.maxLength * power.maxLength;

                        if(power.maxLength < power._maxLength)
                        {
                            power.setAngle = angle;
                            power.setLength = power.maxLength;
                            power.set = true;

                            return;
                        }
                    }
                }

                // Set point based on angle and length.
                object.xPos -= (object.xPos - ((power.position.x + cos(angle) * length) - object.halfWidth)) / 5;
                object.yPos -= (object.yPos - ((power.position.y + sin(angle) * length) - object.halfHeight)) / 5;
            }
        },
        draw : function(object, power)
        {
            if(!power.working)
            {
                return;
            }

            if(levelInfo.nightMode)
            {
                stroke(255, 255, 255, 200);
            }else{
                stroke(0, 0, 0);
            }
            strokeWeight(2);

            var ox = object.xPos + object.halfWidth;
            var oy = object.yPos + object.halfHeight;

            line(ox, oy, power.position.x || ox, power.position.y || oy);

            if(levelInfo.nightMode)
            {
                stroke(255, 255, 255, 100);
            }else{
                stroke(0, 0, 0, 100);
            }

            strokeWeight(0.5);
            line(power.target.x - 8, power.target.y, power.target.x + 8, power.target.y);
            line(power.target.x, power.target.y - 8, power.target.x, power.target.y + 8);

            noFill();
            circle(power.target.x, power.target.y, 16);
        },
    };

    this.onCollide = function(object)
    {
        if(object.arrayName === "player")
        {
            object.xVel = 0;
            object.yVel = 0;

            if(typeof object.discoveredPowers[this.arrayName] === "undefined")
            {
                talkHandler.start(this.messages, "start", "");

                var self = this;
                talkHandler.onEnd = function()
                {
                    self.remove();
                    self.draw = function() {};
                };
            }else{
                this.remove();
                this.draw = function() {};
            }

            object.discoveredPowersHandler.addPower(this.arrayName, this.actObject);
        }
    };
};
gameObjects.addObject("hookShot", createArray(HookShot));

var FlashLight = function(xPos, yPos, width, height)
{
    Rect.call(this, xPos, yPos, width, height);

    this.draw = function()
    {
        fastImage(loadedImages["flashLight"], this.xPos, this.yPos, this.width, this.height);
    };

    this.messages = {
        up : true,
        "start" : {
            messages : [{
                message : "You got the ",
                color : color(255, 255, 255, 160),
            }, {
                message : "Flashlight!",
                color : color(0, 70, 200, 190),
            }],
            choices : {
                "next" : "..."
            }
        },
        "next" : {
            message : "Use this to help you see\nyour way through!",
            choices : {
                "next2" : "..."
            }
        },
        "next2" : {
            message : "That's all it does!",
            choices : {
                "exit" : "..."
            }
        }
    };

    this.actObject = {
        description : "A flashlight to help you see your way through the darkness!",
        key : '',
        name : "flashlight"
    };

    this.onCollide = function(object)
    {
        if(object.arrayName === "player")
        {
            object.xVel = 0;
            object.yVel = 0;

            if(typeof object.discoveredPowers[this.arrayName] === "undefined")
            {
                talkHandler.start(this.messages, "start", "");

                var self = this;
                talkHandler.onEnd = function()
                {
                    self.remove();
                    self.draw = function() {};
                };
            }else{
                this.remove();
                this.draw = function() {};
            }

            object.discoveredPowersHandler.addPower(this.arrayName, this.actObject);
        }
    };
};
gameObjects.addObject("flashLight", createArray(FlashLight));

var FlashLightUpgrade = function(xPos, yPos, width, height)
{
    Rect.call(this, xPos, yPos, width, height);

    this.draw = function()
    {
        fastImage(loadedImages["flashLight"], this.xPos, this.yPos, this.width, this.height);
    };

    this.messages = {
        up : true,
        "start" : {
            messages : [{
                message : "You got the upgraded",
                color : color(255, 255, 255, 160),
            }, {
                message : "Flashlight!",
                color : color(0, 70, 200, 190),
            }],
            choices : {
                "next" : "..."
            }
        },
        "next" : {
            message : "Not only does this allow you to see in the\ndark, but now it allows you do a\nscreen flash!",
            choices : {
                "next2" : "..."
            }
        },
        "next2" : {
            message : "But what is a screen flash? A screen flash is\nwhen you hold down 'x/k'\nlong enough, then...",
            choices : {
                "next3" : "..."
            }
        },
        "next3" : {
            message : "the screen will flash and all enemies on\nscreen will be stunned for a time!",
            choices : {
                "last" : "..."
            }
        },
        "last" : {
            message : "This can be really useful in areas\nwhere there is lots of enemies.",
            choices : {
                "exit" : "..."
            }
        }
    };

    this.actObject = {
        description : "A flashlight to help you see your way through the darkness!\nYou can also hold 'x/k' to do a screen flash.",
        key : '5',
        name : "upgraded flashlight",
        maxTime : 300,
        timer : 0,
        flashInterval : 1000,
        flashing : false,
        dir : "up",
        stun : function(object)
        {
            var _lastUpdate = object.update;
            object.stunTime = millis();
            object.stunAmt = 5500;
            object.stunned = true;   
            object.update = function()
            {
                if(this.stunned)
                {
                    if(millis() - this.stunTime > this.stunAmt)
                    {
                        delete this.stunned;
                        delete this.stunTime;
                        delete this.stunAmt;
                    }
                }else{
                    object.update = _lastUpdate;
                }

                _lastUpdate.apply(this, arguments);
            };
        },
        flash : function(object, power, arguments)
        {
            if(!power.stunnedEnemies && millis() - power.flashTime < power.flashInterval * 0.5)
            {
                var enemies = [];
                var used = {};

                var col, row, cell, i, array, object;

                for(col = cam.upperLeft.col; col <= cam.lowerRight.col; col++)
                {
                    for(row = cam.upperLeft.row; row <= cam.lowerRight.row; row++)
                    {           
                        cell = cameraGrid[col][row];

                        for(i in cell)
                        {
                            if(used[i])
                            {
                                continue;
                            }

                            object = gameObjects.getObject(cell[i].arrayName)[cell[i].index];

                            if(object.hp && object.arrayName !== "player" && !object.isBoss)
                            {
                                enemies.push(object);
                            }

                            used[i] = true;
                        }
                    }
                }

                for(var i = 0; i < enemies.length; i++)
                {
                    this.stun(enemies[i]);
                }

                power.stunnedEnemies = true;
            }
        },
        executeFlash : function(object, power, arguments)
        {
            power.flashTime = millis();
        },
        update : function(object, power, activateKey)
        {
            power.activateKey = activateKey;

            power.flashing = false;
            object.slowMe = false;

            if(millis() - power.flashTime < power.flashInterval)
            {
                power.flash.apply(power, arguments);
                power.flashing = true;
                return;
            }else{
                power.stunnedEnemies = false;
            }

            if(power.dir === "up")
            {
                if(activateKey)
                {
                    object.slowMe = true;
                    power.timer += 1.4;
                }
                else if(power.timer > 0)
                {
                    power.timer = 0;
                }
            }
            else if(power.dir === "down")
            {
                power.timer -= this.reSpeed;

                if(power.timer < 0)
                {
                    power.dir = "up";
                    power.timer = 0;
                }
            }

            power.timer = min(power.timer, power.maxTime);
        },
        reSpeed : 0.12,
        keyReleased : function(object, power, activateKey)
        {
            if(!activateKey && power.dir === "up" && power.timer >= power.maxTime)
            {
                power.executeFlash.apply(power, arguments);
                power.dir = "down";
            }
        }
    };

    this.onCollide = function(object)
    {
        if(object.arrayName === "player")
        {
            object.xVel = 0;
            object.yVel = 0;

            if(typeof object.discoveredPowers["flashLightUpgrade"] === "undefined")
            {
                talkHandler.start(this.messages, "start", "");

                var self = this;
                talkHandler.onEnd = function()
                {
                    self.remove();
                    self.draw = function() {};
                };
            }else{
                this.remove();
                this.draw = function() {};
            }

            object.discoveredPowersHandler.addPower("flashLightUpgrade", this.actObject);
        }
    };
};
gameObjects.addObject("flashLightUpgrade", createArray(FlashLightUpgrade));

var Heart = function(xPos, yPos, diameter, amt)
{
    Circle.call(this, xPos, yPos, diameter);

    this.physics.solidObject = false;
    this.type = "power";
    this.amt = amt || 5;

    this.color = color(30, 160, 120, 220);

    this.draw = function()
    {
        $pjs.pushMatrix();
            translate(this.xPos, this.yPos);
            scale(this.flip, 1);
            noStroke();
            fill(this.color);
            circle(0, 0, this.diameter);

            textAlign(CENTER, CENTER);
            fill(255, 255, 255, 130);
            textSize(11);
            text((this.amt || amt) + " hp", 0, 0);
        $pjs.popMatrix();
    };

    this.falling = false;

    this.gravity = 0;
    this.minimumYPos = yPos + 600;

    this.flip = 1;
    this.flipVel = 0.05;

    this._lastUpdate = this.update;
    this.update = function()
    {
        if(this.flip > 1 || this.flip < -1)
        {
            this.flipVel = -this.flipVel;
        }
        this.flip += this.flipVel;

        if(this.falling)
        {
            cameraGrid.removeReference(this);
            this.yPos += this.gravity;

            if(this.yPos > this.minimumYPos)
            {
                this.yPos = this.minimumYPos;
                this.falling = false;
            }

            this.boundingBox.yPos = this.yPos;
            cameraGrid.addReference(this);
        }

        this._lastUpdate();
    };

    this.onCollide = function(object)
    {
        if(object.arrayName === "player")
        {
            object.dead = false;
            object.maxHp += this.amt;
            object.hp = object.maxHp;

            object.xVel = 0;
            object.yVel = 0;

            talkHandler.start({
                "start" : {
                    messages : [{
                        message : "Your",
                        color : color(255, 255, 255, 170)
                    }, {
                        message : "Max Hp",
                        color : color(14, 140, 280, 200)
                    }, {
                        message : "has increased by",
                        color : color(255, 255, 255, 170)
                    }, {
                        message : this.amt.toString(),
                        color : color(14, 140, 280, 200)
                    }, {
                        message : "!",
                        color : color(255, 255, 255, 170)
                    }],
                    choices : {
                        "---" : "..."
                    }
                },
                "---" : {
                    messages : [{
                        message : "Your",
                        color : color(255, 255, 255, 170)
                    }, {
                        message : "hp bar",
                        color : color(14, 140, 280, 200)
                    }, {
                        message : "has also been filled up!",
                        color : color(255, 255, 255, 170)
                    }],
                    choices : {
                        "exit" : "..."
                    }
                }
            }, "start", "");

            this.amt = 0;

            this.remove();
            this.onCollide = function() {};
        }
    };
};
gameObjects.addObject("heart", createArray(Heart));

var Crystal = function(xPos, yPos, diameter, config)
{
    Circle.call(this, xPos, yPos, diameter);

    this.physics.solidObject = false;
    this.type = "power";

    this.kind = config.kind;

    switch(this.kind)
    {
        case "ninja" :
            this.color = color(105, 0, 200, 80);
            break;

        case "winter" :
            this.color = color(0, 146, 172, 80); 
            break;

        case "underground" :
            this.color = color(1, 0, 0, 100);
            break;

        default :
            this.color = color(0, 0, 0, 80);
            break;
    }

    this.altColor = color(0, 0, 0, 100);

    this.generateTriangles = function()
    {
        this.angles = [];
        this.vels = [];
        this.sizes = [];
        this.colors = [];
        var defaultColor = color(red(this.color), green(this.color), blue(this.color), 100);

        for(var i = 0; i < floor(random(6, 9)); i++)
        {
            this.angles[i] = random(0, 360);
            this.vels[i] = random(-3, 3);
            this.sizes[i] = min((random() + 0.3) * this.radius, this.radius);
            this.colors[i] = (random() < 0.3) ? this.altColor : defaultColor;
        }
    };

    this.generateTriangles();

    
    if(player && player.crystals)
    {
        if(player.crystals[this.kind])
        {
            this.remove();
            this.draw = function() {};
            this.onCollide = function() {};
        }
    }

    var s = this.radius;
    this.draw = function()
    {
        var i, a;
        for(var i = 0; i < this.angles.length; i++)
        {
            this.angles[i] += this.vels[i];
            var a = this.angles[i];
            s = this.sizes[i];

            fill(this.colors[i]);
            triangle(this.xPos + sin(radians(a)) * s, this.yPos + cos(radians(a)) * s, 
                     this.xPos + sin(radians(a + 120)) * s, this.yPos + cos(radians(a + 120)) * s, 
                     this.xPos + sin(radians(a + 240)) * s, this.yPos + cos(radians(a + 240)) * s);
        }

        fill(this.color);
        circle(this.xPos, this.yPos, this.diameter);
    };

    var inter = (this.kind.startsWithVowel() ? "an " : "a ") + this.kind.upper();
   

    if(this.kind === "underground")
    {
        this.messages = {
            up : true,
            "start" : {
                messages : [{
                    message : "You got " + inter, 
                    color : color(255, 255, 255, 150)
                }, {
                    message : "Crystal",
                    color : color(0, 160, 200, 170)
                }, {
                    message : "!",
                    color : color(255, 255, 255, 150)
                }],
                choices : {
                    "next" : "Okay"
                }
            },
            "next" : {
                message : "Now that you've collected all 3 crystals!\nAll you have to do now is find your\nship!",
                choices : {
                    "exit" : "..."
                }
            }
        };
    }else{
        this.messages = {
            up : true,
            "start" : {
                messages : [{
                    message : "You got " + inter, 
                    color : color(255, 255, 255, 150)
                }, {
                    message : "Crystal",
                    color : color(0, 160, 200, 170)
                }, {
                    message : "!",
                    color : color(255, 255, 255, 150)
                }],
                choices : {
                    "exit" : "Okay"
                }
            },
        };
    }

    this.onCollide = function(object)
    {
        if(object.arrayName === "player")
        {
            talkHandler.start(this.messages, "start", "");

            object.crystals[this.kind] = {};

            this.remove();
            this.onCollide = function() {};
        }
    };
};
gameObjects.addObject("crystal", createArray(Crystal));

var PalmTree = function(xPos, yPos, width, height, imageName, flipped)
{
    Rect.call(this, xPos, yPos, width, height);

    this.physics.solidObject = false;

    var variants = ["palmTree", "shortPalmTree", "tallPalmTree"];

    this.imageName = variants[floor(random(0, variants.length))];
   
    if(this.imageName === "tallPalmTree")
    {
        this.xPos += this.width * (2/3);
        this.boundingBox.xPos = this.xPos;
    }

    this.draw = function()
    {
        fastImage(loadedImages[this.imageName], this.xPos, this.yPos, this.width, this.height);
    };
}; 
gameObjects.addObject("palmTree", createArray(PalmTree));

var Lamp = function(xPos, yPos, width, height, useAlt)
{
    Rect.call(this, xPos, yPos, width, height);

    this.physics.solidObject = false;

    // Renders with a light fixture, that's it!

    this.wiggle = 0;
    this.wiggleVel = 0.1;

    this.on = true;
    this.lastOn = this.on;

    this.useAlt = useAlt;

    this.draw = function()
    {   
        var xMiddle = ceil(xPos + this.halfWidth);

        if(this.on)
        {
            // Light!
            var x = xMiddle;
            var y = yPos - 7;

            noStroke();

            if(!this.useAlt)
            {
                fill(200, 175, 23, 130);
                circle(x, y, 18 + this.wiggle);

                fill(200, 175, 23, 60);
                circle(x, y, 40 + this.wiggle);

                fill(200, 175, 23, 193);
                circle(x, y, 5 + this.wiggle * 0.14);
            }else{

                // fill(200, 175, 23, 130);
                // circle(x, y, 18 + this.wiggle);

                fill(200, 175, 23, 60);
                circle(x, y, 40 + this.wiggle);

                fill(200, 175, 23, 86);
                circle(x, y, 17 + this.wiggle * 0.14);
            }
        }

        // Vertical line
        stroke(0, 0, 0, 200);
        strokeWeight(2);
        line(xMiddle, yPos - 2, xMiddle, yPos + height);

        // Base
        noFill();
        $pjs.rect(xMiddle - 6, yPos + height * 0.7, 12, height * 0.3);

        // Lamp
        line(xMiddle - 5, yPos, xMiddle + 5, yPos);
        line(xMiddle - 7, yPos - 14, xMiddle + 7, yPos - 14);
        line(xMiddle - 5, yPos, xMiddle - 7, yPos - 14);
        line(xMiddle + 5, yPos, xMiddle + 7, yPos - 14);
    };

    this.setDynamicTime = 0;

    this.update = function()
    {
        this.wiggle += this.wiggleVel;
        
        if(this.wiggleVel < 0)
        {
            this.wiggleVel = -random(0.05, 0.3) * 2;
        }else{
            this.wiggleVel = random(0.05, 0.3) * 2;
        }

        if(this.wiggle > 3 || this.wiggle < 1)
        {
            this.wiggleVel = -this.wiggleVel;
        }

        this.wiggle = constrain(this.wiggle, -1, 4);

        this.fixturePlace = this.arrayName + this.index;

        if(lighting.fixtures[this.fixturePlace])
        {
            if(this.lastOn !== this.on)
            {
                lighting.fixtures[this.fixturePlace].state = "dynamic";
                this.setDynamicTime = millis();

                if(!this.on)
                {
                    lighting.fixtures[this.fixturePlace].xPos = -999;
                }else{
                    lighting.fixtures[this.fixturePlace].xPos = this.xPos;
                }
            }else{
                if(millis() - this.setDynamicTime > 400)
                {
                    lighting.fixtures[this.fixturePlace].state = "static";
                }
            }
        }

        this.lastOn = this.on;
    };

    this.setFixture = function()
    {
        if(!levelInfo.nightMode)
        {
            return;
        }

        this.fixturePlace = (this.arrayName + this.index);

        this.getPlace = cameraGrid.getPlace(this.xPos + this.halfWidth, this.yPos - 30);
        
        lighting.fixtures[this.fixturePlace] = {
            xPos : this.xPos,
            yPos : this.yPos,
            range : 130,
            brightness : 100, //0-100
            centeredLighting : 80,
            state : "static",
        };

        if(this.useAlt)
        {
            lighting.fixtures[this.fixturePlace].range = 110;
        }

        lighting.fixtures[this.fixturePlace].place = this.getPlace;

        var place = cameraGrid.getPlace(this.xPos, this.yPos);
        cameraGrid[place.col][place.row]._lights[this.fixturePlace] = this.fixturePlace;
    };

    this.toSetAfter = true;
    this.setAfter = function()
    {
        this.setFixture();
    };
};
gameObjects.addObject("lamp", createArray(Lamp));

var Lever = function(xPos, yPos, width, height, colorValue)
{
    Rect.call(this, xPos, yPos, width, height);
    this.color = colorValue || color(155, 155, 155);

    this.physics.solidObject = false;
    this.set = false;

    this.maxX = this.xPos + this.width;
    this.maxY = this.yPos + this.height;

    physics.getMiddleYPos(this);
    physics.getMiddleXPos(this);

    this.quadDiv = 7;

    this.lastSetTime = 0;
    this.maxSetTime = 300;
    this.handleLength = 18;

    this.leftHandleAngle = 360 - 127.5;
    this.rightHandleAngle = 120;

    this.pivotAngle = 105;

    this.handleAngle = this.leftHandleAngle;
    this.setAngleWithRange = function(x)
    {
        this.handleAngle = (this.leftHandleAngle - x) % 360;
    };

    this.draw = function()
    {
        noStroke();
        fill((this.set) ? 255 : 0);

        if(this.set)
        {
            this.setAngleWithRange((this.maxSetTime - constrain(millis() - this.lastSetTime, 0, this.maxSetTime)) * this.pivotAngle / this.maxSetTime);
        }else{
            this.setAngleWithRange(constrain(millis() - this.lastSetTime, 0, this.maxSetTime) * this.pivotAngle / this.maxSetTime);
        }

        var aX = this.middleXPos + sin(radians(this.handleAngle)) * this.handleLength;
        var aY = this.middleYPos + cos(radians(this.handleAngle)) * this.handleLength;

        strokeWeight(4);
        stroke(255, 255, 255, 100);
        line(this.middleXPos, this.middleYPos + 7, aX, aY);

        noStroke();
        fill((this.set) ? color(0, 200, 0, 150) : color(200, 0, 0, 150));
        circle(aX, aY, 10);

        stroke(255, 255, 255, 100);

        fill(120, 120, 120);
        quad(this.xPos, this.maxY, 
             this.maxX, this.maxY, 
             this.maxX - this.quadDiv, this.middleYPos,
             this.xPos + this.quadDiv, this.middleYPos);

        textAlign(CENTER, CENTER);
        textSize(8);
        fill(0, 0, 0);

        if(this.handleAngle <= this.leftHandleAngle || this.handleAngle >= this.rightHandleAngle)
        {
            this.textSf = (this.set) ? "On" : "Off";
        }

        text(this.textSf, this.middleXPos, this.middleYPos + 7.5);
    };

    this.onCollide = function(object, info)
    {
        if(object.activate !== undefined && millis() - this.lastSetTime >= this.maxSetTime && object.activate(this))
        {
            this.set = !this.set;

            this.lastSetTime = millis();
        }

        if(object.arrayName === "xStar")
        {
            object.remove();
        }
    };
};
gameObjects.addObject("lever", createArray(Lever));

var Flypi = function(xPos, yPos, diameter, colorValue)
{
    DynamicCircle.call(this, xPos, yPos, diameter);

    this.color = colorValue || color(0, 0, 0, random(20, 100));

    this.physics.solidObject = false;

    this.gravity = 0;

    this.xSpeed = this.ySpeed = function() 
    {
        return random(-5, 5);
    };

    this.oyVel = this.xSpeed();
    this.oxVel = this.ySpeed();

    var tx = levelInfo.xPos,
        bx = levelInfo.xPos + levelInfo.width;

    var ty = levelInfo.yPos,
        by = levelInfo.yPos + levelInfo.height;

    this.life = 100;
    this.maxLife = 100;
    this.maxRadius = this.radius;
    this.maxColor = this.color;

    this.miniFlypis = createArray(Flypi);

    this._lastDraw = this.draw;
    this.draw = function()
    { 
        this._lastDraw();

        if(this.factory)
        {
            this.miniFlypis.draw();
        }
    };

    this._lastUpdate = this.update;
    this.update = function()
    {
        if(!this.mini)
        {
            if(this.attached)
            {
                var attachObject = gameObjects.getObject(this.attachedArrayName).input(this.attachedIndex);

                this._lastRadius = this.radius;
                this.radius = 8;

                if(observer.colliding(this, attachObject))
                {
                    this.oxVel = attachObject.xVel;
                    this.oyVel = attachObject.yVel;
                }else{
                    this.oyVel = this.xSpeed();
                    this.oxVel = this.ySpeed();
                    this.attached = false;
                }

                this.radius = this._lastRadius;
            }

            if(this.xPos + this.oxVel < levelInfo.xPos - this.radius ||
               this.xPos + this.oxVel > levelInfo.xPos + levelInfo.width + this.radius)
            {
                this.oxVel = -this.oxVel;
            }

            if(this.yPos + this.oyVel < levelInfo.yPos - this.radius || 
               this.yPos > levelInfo.yPos + levelInfo.height + this.radius)
            {
                this.oyVel = -this.oyVel;
            }
        }

        this.xPos += this.oxVel;
        this.yPos += this.oyVel;

        this._lastUpdate();

        if(this.factory)
        {
            if(this.miniFlypis.length < 20)
            {
                var amt = 3;
                var flypis = gameObjects.getObject("flypi");
                var radius = this.radius * 0.25;

                for(var i = amt - 1; i >= 0; i--)
                {
                    this.miniFlypis.add(this.xPos, this.yPos, radius);

                    var miniFlypi = this.miniFlypis.getLast();
                    miniFlypi.mini = true;

                    var a = degrees(atan2(this.oxVel, this.oyVel)) + Math.round(random(-30, 30));
                    var s = Math.round(random(2, 4)) / 2; 
                   
                    miniFlypi.oxVel = -cos(radians(a)) * s;
                    miniFlypi.oyVel = -sin(radians(a)) * s;
                    miniFlypi._index = this.miniFlypis.length - 1;

                    var self = this;
                    miniFlypi.remove = function()
                    {   
                        self.miniFlypis.splice(this._index, 1);
                    };
                }  
            }

            this.miniFlypis.update();
        }
        else if(this.mini)
        {
            this.life -= 1;
            this.radius = this.life * this.maxRadius / this.maxLife;

            var a = (this.maxLife - this.life) * alpha(this.maxColor) / this.maxLife;

            this.color = color(red(this.maxColor), blue(this.maxColor), green(this.maxColor), a);

            if(this.life < 0)
            {
                this.remove();
            }
        }
    };

    this.avoidCollision = function(object)
    {
        return (this.attached && 
                object.arrayName === this.attachedArrayName &&
                object.index === this.attachedIndex);
    };

    this.onCollide = function(object)
    {
        if(object.isLifeForm)
        {
            this.oxVel = 0;
            this.oyVel = 0;
            this.attached = true;
            this.attachedArrayName = object.arrayName;
            this.attachedIndex = object.index;
        }
    };
};
gameObjects.addObject("flypi", createArray(Flypi));

var Gem = function(xPos, yPos, width, height)
{
    Rect.call(this, xPos, yPos, width, height);

    this.physics.solidObject = false;

    this.draw = function()
    {
        image(loadedImages["gem"], this.xPos, this.yPos, this.width * 0.75, this.height * 0.75);
    };

    this.onCollect = function(object)
    {
        if(object.gems === 0)
        {
            talkHandler.start(this.messages, "start", "");
        }else{
            talkHandler.start({
                "start" : {
                    message : "Yay, you found another gem! You now\nhave " + (object.gems + 1) + " gems.",
                    up : true,
                    coices : {
                        "exit" : "okay"
                    }
                }
            }, "start", "");
        }

        object.gems++;

        this.onCollide = function() {};
        this.remove();     
    };

    this.onCollide = function(object)
    {
        if(object.arrayName === "player")
        {
            this.onCollect(object);
        }
    };

    this.messages = {
        "start" : {
            messages : [{
                message : "You've found a"
            }, {
                message : "Gem",
                color : color(0, 148, 117)
            }, {
                message : "!"
            }],
            up : true,
            choices : {
                "explain" : "..."
            }
        }, 
        "explain" : {
            message : "Gems are mysterious crystals designed to\nhelp you through your journey.",
            up : true,
            choices : {
                "last" : "..."
            }
        },
        "last" : {
            message : "Collecting these will help, make sure\nto keep an eye out for them!",
            up : true,
            choices : {
                "exit" : "okay"
            }
        },
    };
};
gameObjects.addObject("gem", createArray(Gem));

game.addFlypis = function()
{
    var amt = (floor(levelInfo.width * levelInfo.height / 25000)) * 1.5;

    var flypis = gameObjects.getObject("flypi");

    var tx = levelInfo.xPos,
        bx = levelInfo.xPos + levelInfo.width;

    var ty = levelInfo.yPos,
        by = levelInfo.yPos + levelInfo.height;

    for(var i = 0; i < amt; i++)
    {   
        var sz = Math.round(random(5, 20)) * 1.5; 

        flypis.add(random(tx + sz, bx - sz), random(ty + sz, by - sz), sz);

        var flypi = flypis.getLast();
        flypi.factory = false;
    }
};

gameObjects.addObject("magicDoor", createArray(Door));

gameObjects.findOrder();

////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
/*****************************************************Level-Object-Creation-Configs********************************************************/
////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
var configAreaSaver = {
    setFromLevelCache : function(level, objectArrayNames, theme)
    {
        //use with f_getArrayNamesToSave

        var objectsExists = levels[level].cache.objectsExists;

        if(typeof objectsExists === "undefined" || 
           typeof theme === "undefined")
        {
            return;
        }

        for(var i = 0; i < objectArrayNames.length; i++)
        {
            var path = ("deleted_" + objectArrayNames[i]);
            var array = gameObjects.getObject(objectArrayNames[i]);

            if(array.fake || typeof objectsExists[path] === "undefined")
            {
                continue;
            }

            for(var j = 0; j < array.length; j++)
            {
                if(!array.input(j).fake && objectsExists[path][j])
                {
                    array.input(j).addedDrops = true;
                    array.input(j).remove();
                    array.applyObject(j);
                }
            }
        }
    },
    gather : function(objectArrayNames)
    {
        //use with f_getArrayNamesToSave

        var recordedObjectBools = {};

        for(var i = 0; i < objectArrayNames.length; i++)
        {
            var path = ("deleted_" + objectArrayNames[i]);
            var array = gameObjects.getObject(objectArrayNames[i]);

            if(array.fake)
            {
                continue;
            }

            recordedObjectBools[path] = [];

            for(var j = 0; j < array.length; j++)
            {
                if(!array.input(j).doNotSave)
                {
                    recordedObjectBools[path].push(array.input(j).fake || false);
                }
            }
        }

        return recordedObjectBools;
    },
    saveToLevelCache : function(level, objectArrayNames, theme)
    {
        if(typeof theme === "undefined")
        {
            return;
        }

        var objectsExists = this.gather(objectArrayNames);

        levels[level].cache.objectsExists = objectsExists;
    },
};

var themes = {
    "ninjaTemple" : {
        afterLoad : function()
        {
            var fireBeakers = gameObjects.getObject("fireBeaker");
            for(var i = 0; i < fireBeakers.length; i++)
            {
                fireBeakers[i].color = color(70, 10, 200, 120);
                fireBeakers[i].particleColor = color(30, 30, 200, 130);
                fireBeakers[i].maxHp = 4;
                fireBeakers[i].hp = 4;
                fireBeakers[i].damage = 1.5;
            }

            var waterBeakers = gameObjects.getObject("waterBeaker");
            for(var i = 0; i < waterBeakers.length; i++)
            {
                waterBeakers[i].color = color(70, 10, 200, 120);
                waterBeakers[i].particleColor = color(30, 30, 200, 130);
                waterBeakers[i].maxHp = 4;
                waterBeakers[i].hp = 4;
                waterBeakers[i].damage = 1.5;
                waterBeakers[i].explosive = true;
            }

            var shooters = gameObjects.getObject("shooter");
            for(var i = 0; i < shooters.length; i++)
            {
                shooters[i].upSpeed = 2.7;
                shooters[i].minDamage = 0.5;
            }
        },
    },
};

var levelScripts = {
    "intro" : {
        apply : function()
        {
            var checkPoint = gameObjects.getObject("checkPoint").input(1);

            if(!checkPoint.checked)
            {
                if(player.username !== undefined)
                {
                    //Prevent the game from not being saved at the start to refrain from dying and going to the wrong check point
                    game.save();

                    this.stop = true;
                    this.apply = function() {};
                }
            }else{
                this.stop = true;
            }
        }
    },
    "villageHouse" : {
        afterLoad : function()
        {
            if(levels[levelInfo.level].save.npcUsedIntros)
            {
                gameObjects.getObject("npc")[0].usedIntro = levels[levelInfo.level].save.npcUsedIntros[0];
                gameObjects.getObject("npc")[1].usedIntro = levels[levelInfo.level].save.npcUsedIntros[1];
            }
        },
        apply : function()
        {
            var npcs = gameObjects.getObject("npc");

            if(npcs[0].usedIntro)
            {
                npcs[0].message = "enjoy";
            }

            if(npcs[1].usedIntro)
            {
                npcs[1].message = "hero";
            }

            if(!levels[levelInfo.level].doors.b.locked)
            {
                npcs[1].message = "thank";
                self.stop = true;
            }

            levels[levelInfo.level].save.npcUsedIntros = [gameObjects.getObject("npc")[0].usedIntro, gameObjects.getObject("npc")[1].usedIntro];
        }
    },
    "coreGround" : {
        apply : function()
        {
            if(levels[levelInfo.level].save.brokeIce)
            {
                gameObjects.getObject("ice").splice(0, 6);
                gameObjects.getObject("lever").getLast().set = true;
                this.stop = true;
            }

            // var player = gameObjects.getObject("player").getLast();
            if(gameObjects.getObject("lever").getLast().set)
            {
                cam.lowerRight.col += 3;
                gameObjects.getObject("ice").clear();
                levels[levelInfo.level].save.brokeIce = true;
                this.stop = true;
            }
        },
    },
    "miniBattle" : {
        afterLoad : function()
        {
            if(levels[levelInfo.level].save.defeatedEnemies)
            {   
                gameObjects.getObject("ninja").length = 0;
                gameObjects.getObject("spaceBreaker").length = 0;
            }else{
                levels[levelInfo.level].doors.a.locked = true;
                levels[levelInfo.level].doors.b.locked = true;
            }
        },
        apply : function()
        {
            var ninjas = gameObjects.getObject("ninja");
            var spaceBreakers = gameObjects.getObject("spaceBreaker");
            
            var defeated = true;
            for(var i = 0; i < ninjas.length; i++)  
            {
                defeated &= (ninjas[i] === undefined || ninjas[i].arrayName !== "ninja" ||
                ninjas[i].hideDelete || ninjas[i].fake);
                if(!defeated)
                {
                    break;
                }
            }
            for(var i = 0; i < spaceBreakers.length; i++)  
            {
                defeated &= (spaceBreakers[i] === undefined || spaceBreakers[i].arrayName !== "spaceBreaker" || 
                spaceBreakers[i].hideDelete || spaceBreakers[i].fake);
                if(!defeated)
                {
                    break;
                }
            }

            if(defeated)
            {
                levels[levelInfo.level].save.defeatedEnemies = true;
                levels[levelInfo.level].doors.a.locked = false;
                levels[levelInfo.level].doors.b.locked = false;
                this.stop = true;
            }
        },
    },
    "ninjaTempleBackyard" : {
        apply : function()
        {
            var chest = gameObjects.getObject("chest").getLast();

            if(chest.goto.isOpen || !chest.goto.hidden)
            {
                gameObjects.getObject("ninja").forEach(function(element, index, array) 
                {
                    element.remove();
                    array.applyObject(index);
                });
                chest.goto.hidden = false;

                try{
                    var key1 = gameObjects.getObject("key").getLast();
                    key1.goto.hidden = false;
                }
                catch(e)
                {
                    console.log(e);
                }

                this.stop = true;
                return;
            }

            var ninjas = gameObjects.getObject("ninja");

            var fakeNinjas = 0;
            ninjas.forEach(function(element, index, array) 
            {
                if(element.fake)
                {
                    fakeNinjas++;
                }
            });

            if(fakeNinjas >= ninjas.length)
            {
                cam.attach(function()
                {
                    var chest = gameObjects.getObject("chest").getLast();

                    if(!game.cutScening)
                    {
                        chest.goto.unHideTimer = millis();
                        chest.goto.unHideTime = 1000;
                    }

                    game.cutScening = true;

                    if(chest.goto.unHideTimer >= 1000)
                    {
                        var key1 = gameObjects.getObject("key").getLast();
                        if(typeof key1 === "object" && typeof key1.goto === "object")
                        {
                            key1.goto.hidden = false;
                        }else{
                            // Okay so the key does not exist.
                            // Because the player already opened the door or collected it.
                        }
                    }

                    return chest;
                }, false, 2000, function()
                {
                    game.cutScening = false;
                });

                this.stop = true;
            }
        },
    },
    "ninjaTemple" : {
        afterLoad : function()
        {
            this.setTime = millis();
        },
        apply : function()
        {
            levelInfo.nightMode = false;
            this.stop = true;
        },
    },
    "ninjaTempleFight" : {
        afterLoad : function()
        {
            this.ninjaIndex = 0;

            var keys = gameObjects.getObject("key");

            (keys.getLast().goto || {}).hidden = true;

            if(keys.length <= 0)
            {
                gameObjects.getObject("ninja").forEach(function(element, index, array) 
                {
                    element.remove();
                    array.applyObject(index);
                });
                gameObjects.getObject("spaceBreaker").forEach(function(element, index, array) 
                {
                    element.remove();
                    array.applyObject(index);
                });
                this.stop = true;
            }
        },
        apply : function()
        {
            var ninja = gameObjects.getObject("ninja")[this.ninjaIndex];

            if(ninja === undefined)
            {
                return;
            }

            var key = gameObjects.getObject("key").getLast();

            if(key.fake)
            {
                this.stop = true;
            }

            if(ninja.fake)
            {
                key.goto.hidden = false;
                this.stop = true;
            }else{
                physics.teleport(key, ninja.xPos, ninja.yPos);
            }
        },
    },
    "ninjaTempleBossRoom" : {
        afterLoad : function()
        {
            this.spikeSpeed = 2.5;

            this.state = this.spikeSpeed;
            this.up = levelInfo.yPos + levelInfo.unitHeight * 3;
            this.down = levelInfo.yPos + levelInfo.height - levelInfo.unitHeight * 3.7;
            this.startWaitTime = 0;
            this.startUpTimer = 0;

            var spikes = gameObjects.getObject("spike");
            spikes.forEach(function(element, index, array)
            {
                element.interval = random(1, 2);
                element.damage = 2.7;
            });

            var bossDefeated = levels[levelInfo.level].save.bossDefeated;

            if(!bossDefeated)
            {
                levels[levelInfo.level].doors.a.locked = true;
                levels[levelInfo.level].doors.b.locked = true;
            }else{
                this.usedIntro = true;

                try{
                    var ninjaBosses = gameObjects.getObject("ninjaBoss");
                    ninjaBosses.input(0).remove();
                    ninjaBosses.applyObject(0);
                }
                catch(e)
                {

                }
            }

            this.doneThis = false;
        },
        apply : function()
        {
            var bossDefeated = gameObjects.getObject("ninjaBoss").input(0).fake;
            var lever = gameObjects.getObject("lever").input(0);
            
            var spikes = gameObjects.getObject("spike");

            if(bossDefeated && !player.dead && !this.doneThis)
            {
                levels[levelInfo.level].doors.a.locked = false;
                levels[levelInfo.level].doors.b.locked = false;
                levels[levelInfo.level].save.bossDefeated = true;
                lever.set = false;
                this.state = -this.spikeSpeed;
                this.doneThis = true;
                return;
            }

            if(!this.usedIntro)
            {
                var started = millis();
                this.createdMessage = false;
                game.cutScening = true;

                var _this = this;
                cam.attach(function()
                {   
                    var ninjaBoss = gameObjects.getObject("ninjaBoss").input(0);

                    if(millis() - started > 1000 && !_this.createdMessage)
                    {
                        screenUtils.createMessage("Ninja Boss", 200, 180, 150, 30,
                        {
                            textSize : 13,
                            textColor : color(250, 250, 250, 300),
                        });

                        _this.createdMessage = true;

                        ninjaBoss.update();
                    }   

                    return ninjaBoss;
                },
                false, 3000, function()
                {
                    game.cutScening = false;
                });

                this.usedIntro = true;
            }

            spikes.forEach(function(element, index, array)
            {
                element.updateMe = true;
            });

            if(this.state !== 0)
            {
                var spikes = gameObjects.getObject("spike");
                var lastElement = {};
                var self = this;

                spikes.forEach(function(element, index, array)
                {
                    if(element.dead)
                    {
                        return;
                    }

                    element.move(0, constrain(element.yPos + self.state * element.interval, self.up, self.down));

                    lastElement = element;
                });

                //Make spikes "move" at the same speed even in 30 fps mode.
                if(game.fps === 30)
                {
                    spikes.forEach(function(element, index, array)
                    {
                        if(element.dead)
                        {
                            return;
                        }

                        element.move(0, constrain(element.yPos + self.state * element.interval, self.up, self.down));

                        lastElement = element;
                    });
                }

                var stateChange = false;

                if(lastElement.yPos + this.state >= this.down)
                {
                    if(this.startUpTimer === 0)
                    {
                        this.startUpTimer = millis();
                    }
                    else if(millis() - this.startUpTimer >= 4000)
                    {
                        lever.set = false;
                        this.state = -this.spikeSpeed;
                        this.startWaitTime = 0;

                        stateChange = true;
                    }
                }

                if(!stateChange)
                {
                    this.state = (lever.set) ? this.spikeSpeed : -this.spikeSpeed;

                    if(!lever.set)
                    {
                        this.startUpTimer = 0;
                    }
                }
            }
        }
    },
    "icyTracks" : {
        beforeLoad : function()
        {
            gameObjects.getObject("water").add(levelInfo.xPos + 3030, levelInfo.yPos + 330, 3000, 4000);
            gameObjects.getObject("water").getLast().freezable = false;
        },
    },
    "icyTracks_2" : {
        beforeLoad : function()
        {
            gameObjects.getObject("water").add(levelInfo.xPos + 10020 - 30, levelInfo.yPos + levelInfo.height + 100, 370, 800);

            this.water = gameObjects.getObject("water").getLast();
            this.water.showNoFreeze = true;

            this.water.physics.movement = "dynamic";
            cameraGrid.addReference(this.water);

            this.water.update = this.water.__lastUpdate;

            this.water.avoidCollision = function(object)
            {
                return object.physics.movement === "static";
            };
        },
        apply : function()
        {
            var lever = gameObjects.getObject("lever").input(0);

            if(lever.set)
            {
                this.water.yPos -= 10;
            }else{
                this.water.yPos += 10;
            }

            this.water.yPos = constrain(this.water.yPos, levelInfo.yPos + 510, levelInfo.yPos + levelInfo.height + 100);

            this.water.updateBoundingBox();

            this.water.update();

            cameraGrid.addReference(this.water);
        }
    },
    "locked_In" : {
        afterLoad : function()
        {
            var chest = gameObjects.getObject("chest").getLast();

            if(chest.goto.isOpen || !chest.goto.hidden)
            {
                gameObjects.getObject("iceBeaker").forEach(function(element, index, array) 
                {
                    element.remove();
                    array.applyObject(index);
                });
                chest.goto.hidden = false;

                this.stop = true;
            }
        },
        apply : function()
        {
            var chest = gameObjects.getObject("chest").getLast();

            if(chest.goto.isOpen || !chest.goto.hidden)
            {
                gameObjects.getObject("iceBeaker").forEach(function(element, index, array) 
                {
                    element.remove();
                    array.applyObject(index);
                });
                chest.goto.hidden = false;

                this.stop = true;
                return;
            }

            var iceBeakers = gameObjects.getObject("iceBeaker");

            var deadIceBeakers = 0;
            iceBeakers.forEach(function(element, index, array) 
            {
                if(element.fake)
                {
                    deadIceBeakers++;
                }
            });

            if(deadIceBeakers >= iceBeakers.length)
            {
                cam.attach(function()
                {
                    var chest = gameObjects.getObject("chest").getLast();

                    if(!game.cutScening)
                    {
                        chest.goto.unHideTimer = millis();
                        chest.goto.unHideTime = 1000;
                    }

                    game.cutScening = true;

                    return chest;
                }, false, 2000, function()
                {
                    game.cutScening = false;
                });

                this.stop = true;
            }
        },
    },
    "entry" : {
        openLoad : function()
        {
            if(levels[levelInfo.level].save.secretUnlocked)
            {
                this.afterSecret();
                this.containsItem = true;
                this.offX = -570;
            }else{
                levels[levelInfo.level].save.secretUnlocked = false;
                this.offX = 0;
            }
        },
        afterLoad : function()
        {
            var chest = gameObjects.getObject("itemChest").input(0);
            var lastDraw = chest.draw;
            chest.draw = function()
            {
                lastDraw.apply(this, arguments);

                if(chest.goto.open)
                {
                    return;
                }

                var vw = this.width * 0.46, vh = this.height * 0.46;
                var px = (cam.focusXPos - cam.halfWidth) + mouseX, py = (cam.focusYPos - cam.halfHeight) + mouseY;

                textSize(12);
                textAlign(CENTER, CENTER);
                fill(255, 255, 255);
                text('?', this.xPos + vw / 2, this.yPos + vh / 2);

                fill(levels[levelInfo.level].save.secretUnlocked ? color(10, 200, 0, 178) : color(10, 0, 200, 178));
                $pjs.rect(this.xPos, this.yPos, vw, vh, 8);

                if(observer.collisionTypes.pointrect.colliding({
                    xPos : px,
                    yPos : py
                }, {
                    xPos : this.xPos,
                    yPos : this.yPos,
                    width : vw,
                    height : vh
                }, 3, 3))
                {
                    fill(255, 255, 255, 255);
                    textSize(9);
                    textAlign(LEFT, CENTER);
                    text(window.bombEmoji || '*', px - 2, py);
                    game.noCursor = true;
                }
            };
        },
        draw : function()
        {
            var self = levelScripts.entry;
            var isGreen = (self.containsItem || levels[levelInfo.level].save.secretUnlocked);

            if(isGreen && !game.cutScening)
            {
                self.offX = Math.max(self.offX - 4, -570);
            }
            
            if(isNaN(self.offX) || self.offX === undefined)
            {
                self.offX = 0;
            }

            stroke(isGreen ? color(10, 200, 170, 160) : color(10, 20, 200, 160));
            strokeWeight(4);
            line(1543, 338, 2275 + self.offX, 338);

            textSize(12);
            textAlign(CENTER, CENTER);
            fill(255, 255, 255);
            text('?', 2275 + 6.9 + self.offX, 338);

            noStroke();
            fill(isGreen ? color(10, 200, 170, 160) : color(10, 20, 200, 160));
            fastRect(2275 + self.offX, 338 - 6.9, 13.8, 13.8);

            var px = (cam.focusXPos - cam.halfWidth) + mouseX, py = (cam.focusYPos - cam.halfHeight) + mouseY;
            if(observer.collisionTypes.pointrect.colliding({
                xPos : px,
                yPos : py
            }, {
                xPos : 2275 + self.offX,
                yPos : 338 - 6.9,
                width : 13.8,
                height : 13.8
            }, 3, 3))
            {
                fill(255, 255, 255, 255);
                textSize(9);
                textAlign(LEFT, CENTER);
                text(window.bombEmoji || '*', px - 2, py);
                game.noCursor = true;
            } 
        },
        apply : function()
        {
            if(this._stop)
            {
                return;
            }

            var chest = gameObjects.getObject("itemChest").input(0);

            if(!this.containsItem)
            {
                chest.goto.items.forEach(item => {
                    if(item.contains === "energy")
                    {
                        this.containsItem = true;
                    }
                });

                if(gameObjects.getObject("ice").length > 110)
                {
                    levels[levelInfo.level].save.secretUnlocked = false;
                }
            }else{
                if(!this._notFirst && gameObjects.getObject("ice").length > 110)
                {
                    levels[levelInfo.level].save.secretUnlocked = false;
                    this.containsItem = false;
                    this._notFirst = true;
                }else{
                    this._stop = true;
                    return;
                }
            }

            if(this.containsItem)
            {
                var self = this;
                self.lastShatterTime = 0;
                self.shatterIndex = 0;
                if(!self.hadShattered)
                {
                    game.cutScening = true;
                }
                cam.attach(function()
                {
                    var object = gameObjects.getObject("ice")[self.shatterIndex];

                    if(!self.lastShatterTime || millis() - self.lastShatterTime >= 300)
                    {
                        if(object.shatter && !object.shattered)
                        {
                            object.shatter();
                            self.hadShattered = true;
                        }
                        self.lastShatterTime = millis();
                        self.shatterIndex++;
                    }

                    var ices = gameObjects.getObject("ice");

                    var vObject = ices[self.shatterIndex];

                    var i = self.shatterIndex;
                    while(true)
                    {
                        if(!vObject || vObject.fake)
                        {
                            i++;
                            vObject = ices[i];

                            if(i >= ices.length)
                            {
                                return false;
                            }

                            continue;
                        }else{
                            break;
                        }
                    }

                    self.shatterIndex = (typeof i === "number") ? i : self.shatterIndex;

                    if(vObject.index >= 28)
                    {
                        return false;
                    }

                    game.cutScening = true;

                    return vObject;
                }, false, 7500, function()
                {
                    game.cutScening = false;
                    delete self.shatterIndex;
                    delete self.lastShatterTime;

                    self.afterSecret(chest);
                });

                this._stop = true;
            }
        },
        afterSecret : function(chest)
        {
            chest = chest || gameObjects.getObject("itemChest").input(0);
            levels[levelInfo.level].save.secretUnlocked = true;

            if(this.hadShattered)
            {
                chest.goto.items.forEach((item, index, items) => {
                    if(item.contains === "energy")
                    {
                        chest.goto.items[index] = {};
                    }
                });
            }
        }
    },
    "icyPuzzles2" : {
        afterLoad : function()
        {
            var level = levels[levelInfo.level];
            level.itemChests.a.hidden = !level.save.roomDefeated;

            if(level.save.roomDefeated)
            {
                gameObjects.getObject("voxelizer").forEach(element => element.remove());
                this.stop = true;
            }
        },
        apply : function()
        {
            var enemiesDefeated = 0;

            var voxelizers = gameObjects.getObject("voxelizer");
            voxelizers.forEach((element, index, array) => {
                if(element.fake)
                {
                    enemiesDefeated++;
                }
            });

            if(enemiesDefeated === voxelizers.length)
            {
                cam.attach(function()
                {
                    var chest = gameObjects.getObject("itemChest")[0];
                    
                    if(!game.cutScening)
                    {
                        chest.goto.unHideTimer = millis();
                        chest.goto.unHideTime = 1000;
                    }

                    game.cutScening = true;

                    return chest;
                },
                false, 2000, function()
                {
                    game.cutScening = false;
                    levels[levelInfo.level].save.roomDefeated = true;
                });
                this.stop = true;
            }
        },
    },
    "IceDragon" : {
        afterLoad: function()
        {   
            if(levels[levelInfo.level].save.roomDefeated)
            {
                // Make sure we can still travel through all the doors.
                levels[levelInfo.level].doors.a.locked = false;

                levels[levelInfo.level].doors.b.hidden = false;
                levels[levelInfo.level].doors.b.locked = false;

                this.stop = true;

                try{

                    // Make sure the ice dragon is removed from the level.
                    var iceDragon = gameObjects.getObject("iceDragon").input(0);

                    if(iceDragon && iceDragon.remove)
                    {
                        iceDragon.remove();
                    }

                    gameObjects.getObject("iceDragon").applyObject(0);
                }
                catch(e)
                {

                }
                return;
            }

            levels[levelInfo.level].doors.a.locked = true;
        },
        apply : function()
        {
            var iceDragon = gameObjects.getObject("iceDragon")[0];

            if(!this.usedIntro && iceDragon.nodes.length > 3)
            {
                var started = millis();
                this.createdMessage = false;
                game.cutScening = true;

                var _this = this;
                cam.attach(function()
                {   
                    var iceDragon = gameObjects.getObject("iceDragon").input(0);

                    if(millis() - started > 1000 && !_this.createdMessage)
                    {
                        screenUtils.createMessage("Ice Dragon", 200, 180, 150, 30,
                        {
                            textSize : 13,
                            textColor : color(250, 250, 250, 300),
                        });

                        _this.createdMessage = true;
                    }   

                    return iceDragon;
                },
                false, 5500, function()
                {
                    game.cutScening = false;
                });

                this.usedIntro = true;
            }

            if(iceDragon.hp <= 0)
            {
                iceDragon.remove();
                gameObjects.getObject("iceDragon").applyObject(0);
            }

            // Prevent game from crashing if there is no ice dragon which there should be.
            if(iceDragon.fake && !game.cutScening)
            {
                this.stop = true;

                game.cutScening = true;

                cam.attach(function()
                {
                    var object = gameObjects.getObject("magicDoor")[0];
                    
                    if(Math.abs(object.xPos - cam.focusXPos) < 80 && Math.abs(object.yPos - cam.focusYPos < 80))
                    {
                        // Set variables after defeating the room!
                        levels[levelInfo.level].doors.a.locked = false;

                        levels[levelInfo.level].doors.b.hidden = false;
                        levels[levelInfo.level].doors.b.locked = false;  

                        levels[levelInfo.level].save.roomDefeated = true;
                    }

                    return object;
                },
                false, 1600, function()
                {
                    game.cutScening = false;

                    // Set variables after defeating the room!
                    levels[levelInfo.level].doors.a.locked = false;

                    levels[levelInfo.level].doors.b.hidden = false;
                    levels[levelInfo.level].doors.b.locked = false;  

                    levels[levelInfo.level].save.roomDefeated = true;
                });

                return;
            }

            if(iceDragon.fake)
            {
                return;
            }

            var _lastXPos = iceDragon.xPos;

            iceDragon.update(true);

            if(Number(game.fps) === 30)
            {
                iceDragon.update(true);
            }
            
            iceDragon.applyCollision(player);

            if(observer.collisionTypes.rectrect.colliding(player.boundingBox, iceDragon.boundingBox))
            {
                observer.collisionTypes.rectrect.solveCollision(player, iceDragon);

                player.xPos -= (_lastXPos - iceDragon.xPos);
            }
        },
        draw : function()
        {
            var iceDragon = gameObjects.getObject("iceDragon").input(0);

            // Prevent game from crashing if there is no ice dragon, which there should be.
            if(iceDragon.fake)
            {
                this.stop = true;
                return;
            }

            iceDragon.draw(true);
        },
    },
    "intersection" : {
        afterLoad : function()
        {
            if(levels[levelInfo.level].save.unlockedSecret)
            {
                gameObjects.getObject("imageBlock").filter(x => x.green).slice(-3).forEach(element => element.remove());
            }

            if(levels[levelInfo.level].save.clearedLava)
            {
                gameObjects.getObject("lava").forEach(element => element.remove());
            }
        },
        apply : function()
        {
            var levers = gameObjects.getObject("lever");

            if(levers[0].set && !levels[levelInfo.level].save.clearedLava && !this.triggeredCutScene)
            {
                var lavas = gameObjects.getObject("lava");
               
                game.cutScening = true;

                var i = lavas.length - 1;
                var _this = this;
                var lastRemoveTime = millis();

                cam.attach(function()
                {
                    var object = lavas[i];

                    if(millis() - lastRemoveTime >= 150)
                    {
                        i--;

                        if(object.remove)
                        {
                            object.remove();
                        }

                        lastRemoveTime = millis();
                    }

                    return object;
                },
                false, (lavas.length + 5) * 150, function()
                {
                    game.cutScening = false;
                    levels[levelInfo.level].save.clearedLava = true;
                    _this.stop = true;
                });

                this.triggeredCutScene = true;
            }

            if(!levels[levelInfo.level].save.unlockedSecret)
            {
                if(levers[1].set && levers[2].set && !levers[3].set && !levers[4].set && levers[5].set)
                {
                    gameObjects.getObject("imageBlock").filter(x => x.green).slice(-3).forEach(element => element.remove());
                    levels[levelInfo.level].save.unlockedSecret = true;
                    this.stop = true;
                }
            }
        }
    },
    "CatRoom!" : {
        afterLoad : function()
        {
            if(levels[levelInfo.level].save.finished)
            {
                // Make sure all doors are unlocked, there are no cats and 
                // stop this script aka don't run apply
                gameObjects.getObject("door").forEach(door => door.goto.locked = false);

                gameObjects.getObject("dirtyCat").forEach(element => element.remove());
                gameObjects.getObject("poisonousSlimeBeaker").forEach(element => element.remove());

                this.stop = true;
            }else{

                // Make sure doors are locked if the room isn't finished
                gameObjects.getObject("door").forEach(door => door.goto.locked = true);
            }
        },
        apply : function()
        {
            // Get every cat and beaker make sure it is "dead"/"fake".
            var cats = gameObjects.getObject("dirtyCat");
            var psbs = gameObjects.getObject("poisonousSlimeBeaker");
                       
            if(!this.emitted && cats.every(cat => cat.fake) && psbs.every(psb => psb.fake))
            {
                var _this = this;
                cam.attach(function()
                {   
                    var door = gameObjects.getObject("door")[0];

                    if(cam.focusXPos - cam.halfWidth < 100)
                    {
                        gameObjects.getObject("door").forEach(door => door.goto.locked = false);
                    }

                    game.cutScening = true;

                    return door;
                }, 
                false, 1500, function()
                {
                    game.cutScening = false;
                    levels[levelInfo.level].save.finished = true;
                    _this.stop = true;
                });  

                this.emitted = true;
            }
        },
    },
    "DEEPEntrance5" : {
        afterLoad : function()
        {
            // Shift over the backblocks in this level to align them with the pillars.
            gameObjects.getObject("backBlock").forEach(function(element)
            {
                element.xPos += levelInfo.unitWidth;
                element.updateBoundingBox();
            });
        },
    },
    "DEEPLeverRoom" : {
        afterLoad : function()
        {
            // Gets the lamp we want flicker on and off
            var _this = this;
            gameObjects.getObject("lamp").some(function(lamp)
            {
                if(lamp.useAlt)
                {
                    _this.lamp = lamp;
                    return true;
                }
            });

            this.code = [true, true, false, false, true];
            this.codeIndex = 0;

            this.lastFlickerTime = 0;
            this.flickerInterval = 500;

            this.shortTime = 120;
            this.longTime = this.shortTime * 4;
            this.offTime = 500;
            this.resetTime = 3000;

            ///////////////////////////////////////////////////////////////////////////////////////////////////////////

            if(levels[levelInfo.level].save.finished)
            {
                gameObjects.getObject("door")[1].goto.locked = false;
            }else{
                gameObjects.getObject("door")[1].goto.locked = true;
            }
        },
        apply : function()
        {
            var lamp = this.lamp;
            var code = this.code;

            if(millis() - this.lastFlickerTime > this.flickerInterval)
            {
                lamp.on = !lamp.on;

                if(lamp.on)
                {
                    if(this.codeIndex < this.code.length)
                    {
                        // Step code.
                        this.flickerInterval = (code[this.codeIndex] ? this.longTime : this.shortTime);
                        this.codeIndex++;
                    }else{
                        // End of code wait 3000 milliseconds until we show the code again.
                        this.codeIndex = 0;
                        lamp.on = false;
                        this.flickerInterval = this.resetTime;
                    }
                }else{
                    this.flickerInterval = this.offTime;
                }

                this.lastFlickerTime = millis();
            }

            ///////////////////////////////////////////////////////////////////////////////////////////////////////////

            if(!levels[levelInfo.level].save.finished && !this.startedCutscene)
            {
                // If the levers match the code
                var levers = gameObjects.getObject("lever");

                if(levers.every(function(element, index)
                {
                    return element.set === code[index];
                }))
                {
                    game.cutScening = true;
                    this.startedCutscene = true;

                    cam.attach(function()
                    {   
                        return gameObjects.getObject("door")[1];
                    }, 
                    false, 2000, function()
                    {
                        game.cutScening = false;
                        levels[levelInfo.level].save.finished = true;
                        gameObjects.getObject("door")[1].goto.locked = false;
                    });
                }
            }
        }
    },
    "DEEPOutside" : {
        apply : function()
        {
            if(levels["LightTowerTopFloor"].save.finished)
            {
                levels["DEEPOutside"].doors.b.locked = false;
            }
        }
    },
    "LightTower" : {
        afterLoad : function()
        {
            var w = levelInfo.unitWidth * 4;
            var h = levelInfo.unitHeight * 4;

            for(var x = 0; x < levelInfo.width; x += w)
            {
                for(var y = 0; y < levelInfo.height; y += h)
                {
                    cameraGrid.addReference(gameObjects.getObject("backBlock").add(x, y, w, h));
                }
            }
        },
    },
    "LightTowerTopFloor" : {
        afterLoad : function()
        {
            if(levels["LightTowerTopFloor"].save.finished && !levels["DEEPOutside"].doors.b.locked)
            {
                this.stop = true;
                return;
            }

            if(levels["LightTowerTopFloor"].save.finished && levels["DEEPOutside"].doors.b.locked)
            {
                this.somethingBroke = true;
            }

            this.doneWithCutScene = false;
        },   
        apply : function()
        {
            var energyAmt = levels["LightTowerTopFloor"].itemChests.a.items.filter(i => i.contains === "energy").length;

            gameObjects.getObject("sign")[0].message = ("Drop something In!\n " + energyAmt + " out of 8 required");

            if((energyAmt === 8 || this.somethingBroke) && levels["DEEPOutside"].doors.b.locked)
            {   
                this.somethingBroke = false;
                var _this = this;

                var playerXPos = player.xPos;
                var playerYPos = player.yPos;

                loader.startLoadLevel("DEEPOutside", "door", 1, function()
                {
                    if(_this.doneWithCutScene)
                    {
                        return;
                    }

                    game.cutScening = true;

                    cam.focusXPos = levelInfo.width * 0.4;

                    var playerDraw = player.draw;
                    player.draw = function() {};
                    player.solidObject = false;

                    cam.attach(function()
                    {   
                        if(gameObjects.getObject("door")[3])
                        {
                            return gameObjects.getObject("door")[3];
                        }else{
                            return gameObjects.getObject("imageBlock")[0];
                        }
                    }, 
                    false, 2000, function()
                    {
                        if(_this.getOutStartTime === undefined)
                        {
                            _this.getOutStartTime = millis();
                            gameObjects.getObject("door")[3].goto.locked = false;

                            // Make sure he's out of view
                            physics.teleport(player, 200, 200);
                        }

                        cam.attach(function()
                        {
                            if(millis() - _this.getOutStartTime > 2000)
                            {
                                physics.teleport(player, playerXPos, playerYPos);
                                delete _this.getOutStartTime;

                                loader.startLoadLevel("LightTowerTopFloor", "door", 1, function()
                                {
                                    physics.teleport(player, playerXPos, playerYPos);
                                    player.draw = playerDraw;

                                    levels["LightTowerTopFloor"].itemChests.a.items = Array(10).fill({});

                                    levels["LightTowerTopFloor"].save.finished = true;

                                    game.cutScening = false;
                                    _this.doneWithCutScene = true;
                                }); 
                            }

                            if(gameObjects.getObject("door")[3])
                            {
                                return gameObjects.getObject("door")[3];
                            }else{
                                return gameObjects.getObject("imageBlock")[0];
                            }           
                        }, 
                        false);
                    });
                });
            }
        }
    },
    "LightTowerP1" : {
        afterLoad : function()
        {
            this.laserCasts = gameObjects.getObject("laserCast");
            this.laserPaths = gameObjects.getObject("laserPath");
            this.laserBlocks = gameObjects.getObject("laserBlock");

            this.laserBlocks.forEach(function(element)
            {
                element.activate();
            });

            if(levels[levelInfo.level].save.finished)
            {
                gameObjects.getObject("exclamationBlock").forEach(element => element.remove());
                return;
            }

            this.counter = 0;

            var _this = this;
            gameObjects.getObject("exclamationBlock").forEach(function(element)
            {
                element.okay = function()
                {
                    return (typeof this.message !== "number" || _this.counter + 1 === this.message);
                };

                element.event = function()
                {   
                    _this.counter++;
                };
            });
        },
        apply : function()
        {
            this.laserCasts = gameObjects.getObject("laserCast");
            this.laserPaths = gameObjects.getObject("laserPath");
            this.laserBlocks = gameObjects.getObject("laserBlock");

            this.laserCasts.forEach(function(element) 
            {
                if(element.move)
                {
                    element.move();

                    cameraGrid.removeReference(element);
                    cameraGrid.addReference(element);

                    gameObjects.applyCollision(element);
                }
            });

            this.laserBlocks.forEach(function(element)
            {
                if(element.laserPath && element.laserCasts)
                {
                    element.laserPath.followMultiple(element.laserCasts);
                }
            });

            if(levels[levelInfo.level].save.finished)
            {
                return;
            }

            var blocks = gameObjects.getObject("exclamationBlock");

            if(this.counter >= blocks.length)
            {
                if(!this._doneThis)
                {
                    var _this = this;
                    game.cutScening = true;
                    var startTime = millis();
                    cam.attach(function()
                    {   
                        var itemChest = gameObjects.getObject("itemChest")[0];

                        if(millis() - startTime > 1000)
                        {
                            itemChest.goto.hidden = false;
                        }

                        return itemChest;
                    }, 
                    false, 2000, function()
                    {
                        game.cutScening = false;
                        levels[levelInfo.level].save.finished = true;
                    });

                    this._doneThis = true;
                }
            }
        },
        draw : function()
        {
            this.laserCasts = gameObjects.getObject("laserCast");
            this.laserPaths = gameObjects.getObject("laserPath");
            this.laserBlocks = gameObjects.getObject("laserBlock");

            this.laserPaths.forEach(function(element) 
            {
                if(element.draw)
                {
                    element.draw();
                }
            });
        }
    },
    "DEEPRoom5" : {
        afterLoad : function()
        {
            this.greenBlocks = gameObjects.getObject("imageBlock").filter(o => o.imageName === "triangleBlockGreen");
        },
        apply : function()
        {
            if(gameObjects.getObject("lever")[0].set)
            {
                this.greenBlocks.forEach((element) => 
                {
                    element.yPos -= 5;

                    element.boundingBox.yPos = element.yPos;

                    cameraGrid.removeReference(element);
                    cameraGrid.addReference(element);
                });
            }
        },
    },
    "FlashLightRoom" : {
        afterLoad : function()
        {
            if(levels[levelInfo.level].save.finished)
            {
                levels[levelInfo.level].chests.a.hidden = false;
                levels[levelInfo.level].doors.a.locked = false;

                levelInfo.nightMode = false;
                lighting.off = true;

                gameObjects.getObject("stomper").forEach(element => element.remove());
                this.stop = true;
                return;
            }

            levels[levelInfo.level].doors.a.locked = true;
            levels[levelInfo.level].chests.a.hidden = true;
        },
        apply : function()
        {
            if(!this.activated && gameObjects.getObject("stomper").every(element => element.fake))
            {
                game.cutScening = true;
                this.activated = true;

                levelInfo.nightMode = false;
                lighting.off = true;

                var _this = this;
                cam.attach(function()
                {
                    return gameObjects.getObject("chest")[0];
                }, 
                false, 2000, function()
                {
                    levels[levelInfo.level].chests.a.hidden = false;
                    levels[levelInfo.level].doors.a.locked = false;

                    levels[levelInfo.level].save.finished = true;
                    game.cutScening = false;
                    _this.stop = true;
                });
            }
        }
    },
    "DEEPBossRoom" : {
        afterLoad : function()
        {
            if(levels[levelInfo.level].save.roomDefeated)
            {
                gameObjects.getObject("captainFleep")[0].remove();
                levels[levelInfo.level].doors.a.locked = false;
                levels[levelInfo.level].doors.b.hidden = false;
                levels[levelInfo.level].doors.b.locked = false;
                delete screenUtils.infoBar.bossArrayName;
                this.stop = true;
                return;
            }

            levels[levelInfo.level].doors.a.locked = true;
        },
        apply : function()
        {
            var captainFleep = gameObjects.getObject("captainFleep")[0];

            if(captainFleep.hp <= 0)
            {
                captainFleep.hp = -1;
                captainFleep.remove();
                gameObjects.getObject("captainFleep").applyObject(0);
            }

            if(!captainFleep.fake)
            {
                captainFleep.update(true);
            }else{
                if(!this.doneThis)
                {
                    game.cutScening = true;

                    levels[levelInfo.level].doors.b.hidden = false;

                    var startTime = millis();
                    var _this = this;
                    cam.attach(function()
                    {
                        if(millis() - startTime > 1000)
                        {
                            levels[levelInfo.level].doors.b.hidden = false;
                            levels[levelInfo.level].doors.b.locked = false;
                        }

                        return gameObjects.getObject("magicDoor")[0];
                    }, 
                    false, 2400, function()
                    {
                        game.cutScening = false;
                        _this.stop = true;
                        levels[levelInfo.level].doors.a.locked = false;
                        levels[levelInfo.level].doors.b.locked = false;
                        levels[levelInfo.level].save.roomDefeated = true;
                    });
                    this.doneThis = true;
                }
               
                return;
            }

            gameObjects.applyCollision(captainFleep);

            cameraGrid.removeReference(captainFleep);
            cameraGrid.addReference(captainFleep);
        }
    },
    "desert y" : {
        afterLoad : function()
        {
            sounds.playSound("zooba.wav");
        }
    },
    "desert oasis" : {
        afterLoad : function()
        {
            var helixShip = gameObjects.getObject("helixShip").add(970, 154, 200, 432);

            if(!shipGoto.launched)
            {
                sounds.playSound("zooba.wav");
            }

            helixShip.update();

            cameraGrid.addReference(helixShip);
        },
        apply : function()
        {
            var helixShip = gameObjects.getObject("helixShip")[0];
            levels["desert oasis"].save.discoveredShip = true;

            if(game.fps === 30)
            {
                helixShip.update();
            }

            if(helixShip.yPos < 0)
            {
                helixShip.update();

                // Above pryamids
                if(helixShip.yPos < -5000)
                {
                    game.dropRate = (abs(helixShip.yPos) - 5000) / abs(helixShip.yVel) * 0.15;
                }

                // In atmosphere
                if(helixShip.yPos < -20000)
                {
                    backgrounds.background = "atmosphere";

                    var usingBackground = backgrounds.backgrounds["atmosphere"];

                    usingBackground.factor -= 0.0007;
                    usingBackground.factor = max(0, usingBackground.factor);
                }

                // In Space
                if(helixShip.yPos < -50000 && backgrounds.background !== "space")
                {
                    backgrounds.backgrounds.space.load();
                }

                if(helixShip.yPos < -55000)
                {
                    backgrounds.backgrounds.atmosphere.starLate = ((abs(helixShip.yPos) - 55000) * 400 / 5000) * 0.4;
                }

                if(helixShip.yPos < -65000)
                {
                    shipGoto.haveNotSavedSince = true;
                    loader.startLoadLevel("space", "player", 0);
                }

                for(var i = 0; i < graphics.inClouds.length; i++)
                {
                    graphics.inClouds[i].yPos += 0.1;
                }
            }
        },
        draw : function()
        {
            var helixShip = gameObjects.getObject("helixShip")[0];
        }
    },
    "space" : {
        afterLoad : function()
        {
            var helixShip = gameObjects.getObject("helixShip").add(levelInfo.width / 2, levelInfo.height - 500, 200, 432);

            helixShip.xPos = shipGoto.xPos || helixShip.xPos;
            helixShip.yPos = shipGoto.yPos || helixShip.yPos;
            if(typeof shipGoto.angle !== "undefined")
            {
                helixShip.angle = shipGoto.angle;
            }
            helixShip.updateBoundingBox();

            helixShip.update();
            cameraGrid.addReference(helixShip);

            var helixShip = gameObjects.getObject("helixShip")[0];

            cam.attach(function()
            {
                return helixShip;
            }, true);

            cam.keepInGrid = true;
            cam.scaled = true;
            cam.scaleOut = -0.6;

            cam.useAnotherScale = true;
            cam.ANScaleX = 0.7;
            cam.ANScaleY = 0.7;

            ///////////////////////////////////////////////

            var talonShip = gameObjects.getObject("talonShip").add(19000, 3600, 200, 300);
            cameraGrid.addReference(talonShip);

            var _this = this;
            talonShip.onHandleDeath = function()
            {
                _this.battling = false;

                gameObjects.getObject("missle").forEach(object => {
                    if(object.remove)
                    {
                        object.remove();
                    }
                });
                gameObjects.getObject("bomb").forEach(object => {
                    if(object.remove)
                    {
                        object.remove();
                    }
                });
                gameObjects.getObject("phaserBlast").forEach(object => {
                    if(object.remove)
                    {
                        object.remove();
                    }
                });

                talkHandler.start({
                    up : true,
                    "start" : {
                        message : "Y-\nYou have done very well.",
                        choices : {
                            "next" : "..."
                        }
                    },
                    "next" : {
                        message : "You're amazing, I know..",
                        choices : {
                            "next2" : "..."
                        }
                    },
                    "next2" : {
                        message : "... I have met my fate...",
                        choices : {
                            "next3" : "..."
                        }
                    },
                    "next3" : {
                        message : "Whats this? A wormhole to Dimension X?",
                        choices : {
                            "next4" : "..."
                        }
                    },
                    "next4" : {
                        message : "But... I'll be eternally stuck\nthere forever!",
                        choices : {
                            "next5" : "..."
                        }
                    },
                    "next5" : {
                        message : "But wait one moment...",
                        choices : {
                            "next6" : "..."
                        }
                    }, 
                    "next6" : {
                        message : "Do you know that those crystals\nbelong to Titan?",
                        choices : {
                            "next7" : "..."
                        },
                    }, 
                    "next7" : {
                        message : "As you should know... you should return\nthose crystals to Titan...",
                        choices : {
                            "next8" : "..."
                        },
                    },
                    "next8" : {
                        message : "otherwise... this galaxy might fall apart\nwithout someone powerful",
                        choices : {
                            "next9" : "..."
                        },
                    },
                    "next9" : {
                        message : "enough to continue controlling them.",
                        choices : {
                            "next10" : "..."
                        }
                    },
                    "next10" : {
                        message : "that is why this portal to\nDimension X formed!",
                        choices : {
                            "last" : "..."
                        }
                    },
                    "last" : {
                        message : "Now it is closing in on me\n\n...I can't believe it! Wai--(whoosh!)",
                        choices : {
                            "exit" : "..."
                        }
                    }
                },
                "start", "Talon");

                setTimeout(function()
                {
                    game.finish();
                }, 
                4000);
            };
        },
        ring : {
            diameter : 6000,
            radius : 6000 / 2,
            diameterSq : 6000 * 6000,
            radiusSq : 6000 * 6000 / 2 / 2
        },
        apply : function()
        {
            var helixShip = gameObjects.getObject("helixShip")[0];

            cameraGrid.removeReference(helixShip);
            cameraGrid.addReference(helixShip);

            if(!levels[levelInfo.level].save.showedControls)
            {
                talkHandler.start({
                    up : true,
                    "start" : {
                        message : "Welcome to space... directional keys to\nmove ship, press Q to load interior.",
                        choices : {
                            "next" : "..."
                        }
                    },
                    "next" : {
                        message : "Space to shoot too, this section\nof space is empty but see if you\ncan find something...",
                        choices : {
                            "exit" : "..."
                        }
                    }
                }, 
                "start", "");

                levels[levelInfo.level].save.showedControls = true;
            }

            var talonShip = gameObjects.getObject("talonShip")[0] || {};
            var helixShip = gameObjects.getObject("helixShip")[0] || {};

            var dx = talonShip.firstMiddleXPos - helixShip.middleXPos;
            var dy = talonShip.firstMiddleYPos - helixShip.middleYPos;

            var ring = levelScripts[levelInfo.level].ring;

            if(this.startBattle !== false && dx * dx + dy * dy < Math.pow(ring.diameter - 1000, 2))
            {
                this.startBattle = true;
            }

            if(this.startBattle)
            {
                var _this = this;
                setTimeout(function()
                {
                    talkHandler.start({
                        up : true,
                        "start" : {
                            message : "<incoming interception>",
                            choices : {
                                "next" : "..."
                            }
                        },
                        "next" : {
                            message : "Ah ha ha! So I've found the hero at last!",
                            choices : {
                                "next.1" : "..."
                            }
                        },
                        "next.1" : {
                            message : "Which means you, /username have escaped\nSearch, collected all ...",
                            choices : {
                                "next.2" : "..."
                            }
                        },
                        "next.2" : {
                            message : "3 crystals, repaired your ship after I\nintentially sent it whirling!",
                            choices : {
                                "next.3" : "..."
                            }
                        },
                        "next.3" : {
                            message : "Yes, a force to be reckoned with!",
                            choices : {
                                "next2" : "..."
                            }
                        },
                        "next2" : {
                            message : "You have surely stood the test of time.\nAnd in doing so you have proven\nyourself worthy as a hero...",
                            choices : {
                                "beforeLast" : "..."
                            }
                        },
                        "beforeLast" : {
                            message : "And that is why...",
                            choices : {
                                "last" : "..."
                            }
                        },
                        "last" : {
                            message : "I've been watching you all this time!\nI planned for you to prove yourself.\nAnd indeed you have...",
                            choices : {
                                "last2" : "..."
                            }
                        },
                        "last2" : {
                            message : "Even when I sent Captain Fleep to\ndemolish you and Leopard X to \"steal\"\nyour coins.",
                            choices : {
                                "last3" : "..."
                            }
                        }   ,
                        "last3" : {
                            message : "And after all this, after\nstanding the test of time hero...",
                            choices : {
                                "final" : "..."
                            }
                        },
                        "final" : {
                            message : "You must pass the final test!\nAre you ready /username?\nDo you have what it takes?",
                            choices : {
                                "finally" : "..."
                            }
                        },
                        "finally" : {
                            message : "If so...\n\n                        All ends now!",
                            choices : {
                                "exit" : "..."
                            }
                        }
                    },
                    "start", "Talon");

                    screenUtils.infoBar.bossArrayName = "talonShip";
                    talonShip.state = "start";

                    _this.battling = true;
                }, 1400);

                this.startBattle = false;

                cam.attach(function()
                {
                    return gameObjects.getObject("talonShip")[0];
                }, 
                1000, false, function()
                {

                });
            }

            if(messageHandler.active)
            {
                return;
            }

            if(this.battling)
            {
                var lengthSq = dx * dx + dy * dy;

                if(lengthSq >= ring.radiusSq)
                {
                    var angle = atan2(dy, dx) + Math.PI;

                    var length = Math.min(ring.radius, Math.sqrt(lengthSq));

                    helixShip.xPos -= (helixShip.xPos - (talonShip.firstMiddleXPos + cos(angle) * length - helixShip.halfWidth))  //0.1;
                    helixShip.yPos -= (helixShip.yPos - (talonShip.firstMiddleYPos + sin(angle) * length - helixShip.halfHeight)) //0.1;

                    helixShip.updateBoundingBox();
                }

                talonShip.update(true); 

                if(game.fps <= 30)
                {
                    talonShip.update(true);
                }     
            }       
        },
        draw : function()
        {
            var talonShip = gameObjects.getObject("talonShip")[0] || {};

            var ring = levelScripts[levelInfo.level].ring;

            // noFill();
            // stroke(80, 150, 200);
            // strokeWeight(4);
            // ellipse(talonShip.firstMiddleXPos, talonShip.firstMiddleYPos, ring.diameter, ring.diameter);
            // noStroke();

            talonShip.draw();
        }
    },
    "helixShip" : {
        afterLoad : function()
        {
            var helixShip = gameObjects.getObject("helixShip").add(9999999, 9999999, 2, 2);
            helixShip.draw = function() {};
            helixShip.update = function() {};

            var door = gameObjects.getObject("door")[1];
            var img = loadedImages["windowSky"];

            var back = gameObjects.getObject("imageBlock").add(levelInfo.unitWidth, levelInfo.unitHeight * 3, img.width * 1.023, img.height * 1.023, "windowSky");
            back.physics.solidObject = false;
            cameraGrid.addReference(back);

            var blockSketchy = gameObjects.getObject("imageBlock").filter(object => object.imageName === "blockSketchy")[0];

            if(shipGoto.inSpace)
            {
                back.draw = function()
                {
                    ctx.drawImage(loadedImages["windowSky"].sourceImg, 0, 0, img.sourceImg.width, img.sourceImg.height, Math.round(this.xPos), Math.round(this.yPos), this.width, this.height);
                    ctx.drawImage(loadedImages["windowSpace"].sourceImg, 0, 0, loadedImages["windowSpace"].sourceImg.width, img.sourceImg.height, Math.round(this.xPos), Math.round(this.yPos), this.width, this.height);
                    blockSketchy.draw();
                };
            }

            var exitBlock = gameObjects.getObject("imageBlock").filter(object => object.imageName === "exit")[0];
           
            exitBlock.physics.solidObject = false;

            if(shipGoto.inSpace)
            {
                cameraGrid.removeReference(exitBlock);
                exitBlock.remove();
            }else{
                exitBlock.onCollide = function(object, info)
                {
                    if(object.arrayName === "player" && object.yVel < 0)
                    {
                        loader.startLoadLevel("desert oasis", "player", 0, function()
                        {
                            var helixShip = gameObjects.getObject("helixShip")[0];

                            player.xPos = helixShip.xPos + helixShip.halfWidth;
                            player.yPos = helixShip.yPos + 180 - player.height;
                            player.updateBoundingBox();

                            cameraGrid.removeReference(player);
                            cameraGrid.addReference(player);

                            player.yVel = 0;

                            cam.attach(function()
                            {
                                return player;
                            },
                            true);

                            setTimeout(function()
                            {
                                cameraGrid.removeReference(player);
                                cameraGrid.addReference(player);
                            }, 3000);
                        });
                    }
                };
            }

            blockSketchy.draw = function()
            {
                ctx.drawImage(loadedImages["blockSketchy"].sourceImg, Math.round(this.xPos), Math.round(this.yPos), levelInfo.unitWidth, levelInfo.unitHeight);
            };

            blockSketchy.onCollide = function(object, info)
            {
                if(object.arrayName === "player" && object.activate && object.activate())
                {
                    controlPanel.open();
                    game.switchGameState(true, "controlPanel", true); 
                }
            };

            door.onCollide = function() {};
            door.draw = function() {};
            door.update = function() {};
        },
        apply : function()
        {
            if(!levels[levelInfo.level].save.shown)
            {
                talkHandler.start({
                    up : true,
                    "start" : {
                        message : "Welcome to your ship /username !",
                        choices : {
                            "next" : "..."
                        }
                    },
                    "next" : {
                        message : "To access the control panel press down on\nthis box right here.",
                        choices : {
                            "next2" : "..."
                        }
                    },
                    "next2" : {
                        message : "To exit, just jump into this '+' shaped box.",
                        choices : {
                            "exit" : "..."
                        }
                    }
                }, 
                "start", "");

                levels[levelInfo.level].save.shown = true;
            }
        }
    },
    "helixShip2" : {
        afterLoad : function()
        {
            var helixShip = gameObjects.getObject("helixShip").add(9999999, 9999999, 2, 2);
            helixShip.draw = function() {};
            helixShip.update = function() {};
            var img = loadedImages["windowSky"];

            var newHeight = 7 * levelInfo.unitHeight;
            var ratio = (newHeight / img.height);

            var back = gameObjects.getObject("imageBlock").add(levelInfo.unitWidth * 5, levelInfo.unitHeight * 3, img.width * ratio, newHeight, "windowSky");
            back.physics.solidObject = false;
            cameraGrid.addReference(back);

            levels[levelInfo.level].save.shown = true;

            if(shipGoto.inSpace)
            {
                back.draw = function()
                {
                    ctx.drawImage(loadedImages["windowSky"].sourceImg, 0, 0, loadedImages["windowSky"].sourceImg.width, loadedImages["windowSky"].sourceImg.height, 
                                Math.round(this.xPos), Math.round(this.yPos), this.width, this.height);
                    ctx.drawImage(loadedImages["windowSpace"].sourceImg, 0, 0, loadedImages["windowSpace"].sourceImg.width, loadedImages["windowSpace"].sourceImg.height, 
                                Math.round(this.xPos), Math.round(this.yPos), this.width, this.height);
                };
            }
        }
    }
};

function _$$_()
{
    for(var j = 2; j <= 8; j++)
    {   
        if(!levels["LightTowerP" + j])
        {
            continue;
        }

        levelScripts["LightTowerP" + j] = {};
        for(var i in levelScripts["LightTowerP1"])
        {
            levelScripts["LightTowerP" + j][i] = levelScripts["LightTowerP1"][i];
        }
    }

    var _lastApply = levelScripts["LightTowerP2"].apply;
    levelScripts["LightTowerP2"].apply = function()
    {
        _lastApply.apply(this, arguments);
        var levers = gameObjects.getObject("lever");
        var greenBlocks = gameObjects.getObject("imageBlock").filter(element => element.imageName === "triangleBlockGreen");

        var blocks = gameObjects.getObject("exclamationBlock");

        blocks[0].message = 1;
        blocks[1].message = 2;

        var lever = levers[0];

        if(lever._lastSet === undefined)
        {
            lever._lastSet = lever.set;
            lever._firstXPos = lever.xPos;
            return;
        }

        if(lever._lastSet !== lever.set)
        {
            if(lever.set)
            {
                greenBlocks[0].xPos = lever._firstXPos;
            }else{
                greenBlocks[0].xPos = lever._firstXPos + levelInfo.unitWidth * 7;
            }

            greenBlocks[0].boundingBox.xPos = greenBlocks[0].xPos;
            cameraGrid.removeReference(greenBlocks[0]);
            cameraGrid.addReference(greenBlocks[0]);
        }

        lever._lastSet = lever.set;
    };


    var _lastApply = levelScripts["LightTowerP4"].apply;
    levelScripts["LightTowerP4"].apply = function()
    {
        _lastApply.apply(this, arguments);

        var blocks = gameObjects.getObject("exclamationBlock");

        blocks[0].message = 1;
        blocks[1].message = 2;
        blocks[2].message = 5;
        blocks[3].message = 4;
        blocks[4].message = 3;

        var levers = gameObjects.getObject("lever");
        var greenBlocks = gameObjects.getObject("imageBlock").filter(element => element.imageName === "triangleBlockGreen");

        var lever = levers[0];

        if(lever._lastSet === undefined)
        {
            lever._lastSet = lever.set;
            greenBlocks[0]._firstXPos = greenBlocks[0].xPos;
            return;
        }

        if(lever._lastSet !== lever.set)
        {
            if(lever.set)
            {
                greenBlocks[0].xPos = greenBlocks[0]._firstXPos;
            }else{
                greenBlocks[0].xPos = greenBlocks[0]._firstXPos + levelInfo.unitWidth * 10;
            }

            greenBlocks[0].boundingBox.xPos = greenBlocks[0].xPos;
            cameraGrid.removeReference(greenBlocks[0]);
            cameraGrid.addReference(greenBlocks[0]);
        }

        lever._lastSet = lever.set;
    };

    var _lastApply = levelScripts["LightTowerP6"].apply;
    levelScripts["LightTowerP6"].apply = function()
    {
        _lastApply.apply(this, arguments);

        var blocks = gameObjects.getObject("exclamationBlock");

        blocks[0].message = 2;
        blocks[1].message = 3;
        blocks[2].message = 1;
    };

    var _lastAfterLoad = levelScripts["LightTowerP7"].afterLoad;
    levelScripts["LightTowerP7"].afterLoad = function()
    {
        _lastAfterLoad.apply(this, arguments);
        
        cam.yMost = -levelInfo.unitHeight * 3;
    };

    var _lastApply = levelScripts["LightTowerP7"].apply;
    levelScripts["LightTowerP7"].apply = function()
    {
        _lastApply.apply(this, arguments);

        var blocks = gameObjects.getObject("exclamationBlock");

        blocks[0].message = 3;
        blocks[1].message = 2;
        blocks[2].message = 1;
        blocks[3].message = 6;
        blocks[4].message = 5;
        blocks[5].message = 4;
    };

    var _lastApply = levelScripts["LightTowerP8"].apply;
    levelScripts["LightTowerP8"].apply = function()
    {
        _lastApply.apply(this, arguments);

        var blocks = gameObjects.getObject("exclamationBlock");

        blocks[6].message = 1;
        blocks[9].message = 2;
        blocks[13].message = 3;
        blocks[12].message = 4;
        blocks[8].message = 5;
        blocks[5].message = 6;
        blocks[1].message = 7;
        blocks[0].message = 8;
        blocks[4].message = 9;
        blocks[7].message = 10;

        blocks[10].message = 11;
        blocks[11].message = 12;

        blocks[2].message = 13;
        blocks[3].message = 14;
    };
}

_$$_();

levelScripts.restart = function()
{
    for(var i in this)
    {
        this[i].stop = false;
    }

    if(levelInfo.theme !== undefined)
    {
        for(var i in themes[levelInfo.theme])
        {
            themes[levelInfo.theme][i].stop = false;
        }
    }
};
levelScripts.openLoad = function()
{
    if(typeof this[levelInfo.level] === "object" && 
       this[levelInfo.level].openLoad !== undefined)
    {
        this[levelInfo.level].openLoad();
    }

    if(levelInfo.theme !== undefined)
    {
        if(typeof themes[levelInfo.theme] === "object" && 
        themes[levelInfo.theme].openLoad !== undefined)
        {
            themes[levelInfo.theme].openLoad();
        }
    }
};
levelScripts.beforeLoad = function()
{
    if(typeof this[levelInfo.level] === "object" && 
       this[levelInfo.level].beforeLoad !== undefined)
    {
        this[levelInfo.level].beforeLoad();
    }

    if(levelInfo.theme !== undefined)
    {
        if(typeof themes[levelInfo.theme] === "object" && 
        themes[levelInfo.theme].beforeLoad !== undefined)
        {
            themes[levelInfo.theme].beforeLoad();
        }
    }
};
levelScripts.onSave = function()
{
    if(typeof this[levelInfo.level] === "object" && 
       this[levelInfo.level].onSave !== undefined)
    {
        this[levelInfo.level].onSave();
    }

    if(levelInfo.theme !== undefined)
    {
        if(typeof themes[levelInfo.theme] === "object" && 
        themes[levelInfo.theme].onSave !== undefined)
        {
            themes[levelInfo.theme].onSave();
        }
    }
};
levelScripts.afterLoad = function()
{
    if(typeof this[levelInfo.level] === "object" && 
       this[levelInfo.level].afterLoad !== undefined)
    {
        this[levelInfo.level].afterLoad();
    }

    if(levelInfo.theme !== undefined)
    {
        if(typeof themes[levelInfo.theme] === "object" && 
        themes[levelInfo.theme].afterLoad !== undefined)
        {
            themes[levelInfo.theme].afterLoad();
        }
    }
};
levelScripts.apply = function()
{
    if(this[levelInfo.level] !== undefined && 
    typeof this[levelInfo.level].apply === "function" && 
    !this[levelInfo.level].stop)
    {
        this[levelInfo.level].apply();
    }

    if(levelInfo.theme !== undefined)
    {
        if(typeof themes[levelInfo.theme] === "object" && 
        themes[levelInfo.theme].apply !== undefined && 
        !themes[levelInfo.theme].stop)
        {
            themes[levelInfo.theme].apply();
        }
    }
};
levelScripts.draw = function()
{
    if(this[levelInfo.level] !== undefined && 
    typeof this[levelInfo.level].draw === "function" && 
    !this[levelInfo.level].stop)
    {
        this[levelInfo.level].apply();
        (this[levelInfo.level].draw || function(){})();
    }

    if(levelInfo.theme !== undefined)
    {
        if(typeof themes[levelInfo.theme] === "object" && 
        themes[levelInfo.theme].draw !== undefined && 
        !themes[levelInfo.theme].stop)
        {
            themes[levelInfo.theme].draw();
        }
    }
};

// Make sure every level has a save place
for(var i in levels)
{
    if(typeof levels[i].save === "undefined")
    {
        levels[i].save = {};
    }
}

// Make sure all chests have 10 slots.
for(var i in levels)
{
    if(typeof levels[i].itemChests === "object")
    {
        for(var j in levels[i].itemChests)
        {
            if(levels[i].itemChests[j].items)
            {
                while(levels[i].itemChests[j].items.length < 10)
                {
                    levels[i].itemChests[j].items.push({});
                }
            }
        }
    }
}

// Levels!
levels.getSymbol = function(col, row, levelPlan)
{
    if(col >= 0 && col < levelPlan[0].length &&
       row >= 0 && row < levelPlan.length)
    {
        return levelPlan[row][col];
    }else{
        return " ";
    }
};
levels.clearCache = function()
{
    for(var i in levels)
    {
        if(typeof levels[i].plan !== "undefined")
        {
            levels[i].cache = {};
        }
    }
};
//Eventually these methods will be with the gameObject arrays (maybe)
levels.setObjectAtCheckPoint = function(object, xPos, yPos)
{
    var checkPoint = gameObjects.getObject("checkPoint").getLast();
    if(object.goto !== undefined && object.goto.travelType === "checkPoint" && object.goto.checkPointIndex === checkPoint.index)
    {
        physics.teleport(object, xPos, yPos - abs(object.height - levelInfo.unitHeight));

        checkPoint.setObjectProps(object);
    }
};
levels.setObjectAtDoor = function(object, xPos, yPos, symbol)
{
    if(object.goto !== undefined && object.goto.travelType === "door" && object.goto.doorSymbol === symbol)
    {
        physics.teleport(object, xPos, yPos + (levelInfo.unitHeight * 2 - object.height));
    }
};
levels.setPlayer = function(xPos, yPos, colorValue)
{
    //Init with a checkPoint
    gameObjects.getObject("checkPoint").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight, undefined, true);
    if(gameObjects.getObject("player").length <= 0)
    {
        player = gameObjects.getObject("player").add(xPos, yPos - abs(levelInfo.unitHeight * 2 - levelInfo.unitHeight), levelInfo.unitWidth, levelInfo.unitHeight * 2, colorValue);

        //Set checkPoint
        gameObjects.getObject("checkPoint").getLast().setObjectProps(player);
    }
    this.setObjectAtCheckPoint(player, xPos, yPos);
};
levels.applySettings = function(level)
{
    var configLevel = ((configs[levelInfo.theme] || {}).level || {});

    levelInfo.nightMode = level.nightMode || configLevel.nightMode;
    levelInfo.daylightCycle = level.daylightCycle || configLevel.daylightCycle;
    levelInfo.laddersWhite = level.laddersWhite || configLevel.laddersWhite;
    levelInfo.useFlypis = level.useFlypis || configLevel.useFlypis;

    levelInfo.cold = configLevel.cold || level.cold;

    levelInfo.regenCoinCost = configLevel.regenCoinCost;

    if(level.background !== undefined)
    {
        backgrounds.setBackground(level.background);
    }
    else if(configLevel.background !== undefined)
    {
        backgrounds.setBackground(configLevel.background);
    }

    if(level.debugMenuWhite !== undefined)
    {
        screenUtils.debugMenuWhite = level.debugMenuWhite;
    }
    else if(configLevel.debugMenuWhite !== undefined) 
    {
        screenUtils.debugMenuWhite = configLevel.debugMenuWhite;
    }else{
        screenUtils.debugMenuWhite = (screenUtils.debugMenuWhite || game.debugMenuWhite);
    }

    if(level.shade !== undefined)
    {
        levelInfo.levelShade = color(level.shade.r || 0, level.shade.g || 0, level.shade.b || 0, level.shade.a || 0);
    }
    else if(configLevel.shade !== undefined)
    {
        levelInfo.levelShade = color(configLevel.shade.r || 0, configLevel.shade.g || 0, configLevel.shade.b || 0, configLevel.shade.a || 0);
    }else{
        levelInfo.levelShade = color(0, 0, 0, 1);
    }

    if(level.inWater || configLevel.inWater)
    {
        gameObjects.getObject("water").add(levelInfo.xPos, levelInfo.yPos, levelInfo.width, levelInfo.height);  
    }
    if(level.darkGrid || configLevel.darkGrid)
    {
        gameObjects.getObject("backBlock").add(levelInfo.xPos, levelInfo.yPos, levelInfo.width, levelInfo.height);
    }

    levelInfo.inWater = level.inWater || configLevel.inWater;

    if(levelInfo.useFlypis)
    {
        game.addFlypis();
    }

    if(level.rumble !== undefined)
    {   
        levelInfo.rumble = level.rumble;
    }else{
        delete levelInfo.rumble;
    }

    levelInfo.backgroundDarkGrid = (level.backgroundDarkGrid || configLevel.backgroundDarkGrid);
    screenUtils.useInverseCircle = level.hideScreen || configLevel.hideScreen;

    levelInfo.lastSong = levelInfo.currentSong || "";
    levelInfo.currentSong = level.song || configLevel.song || "";

    levelInfo.isLightTower = levelInfo.level !== levelInfo.level.replace("LightTower", "");
};
levels.build = function(plan)
{
    var level = this[plan.level];
    
    if(plan.first)
    {
        levelInfo.width = level.plan[0].length * levelInfo.unitWidth;
        levelInfo.height = level.plan.length * levelInfo.unitHeight;
        levelInfo.theme = level.theme;

        this.applySettings(level);
    }

    var done = false;
    var start = max((plan.minRow || 0), 0);
    var end = min((plan.maxRow || level.plan.length), level.plan.length);
    
    var table = (level.table || ((configs[levelInfo.theme] || {}).level || {}).table || {});
    var blockColor = ((typeof levelInfo.theme !== "undefined" && levelInfo.theme.toString() === "ninjaTemple") ? color(90, 20, 180) : color(130, 130, 130));

    for(var row = start; row < end; row++)
    {
        for(var col = 0; col < level.plan[row].length; col++)
        {
            var xPos = levelInfo.xPos + col * levelInfo.unitWidth;
            var yPos = levelInfo.yPos + row * levelInfo.unitHeight;

            /*Prevent objects from generating in the door 
            besides objects that went though the door*/
            var belowSymbol = this.getSymbol(col, row + 1, level.plan);
            if(belowSymbol === 'D')
            {
                for(var i = 0; i < travelObjects.length; i++)
                {
                    var object = gameObjects.getObject(travelObjects[i].arrayName).input(travelObjects[i].index);
                    this.setObjectAtDoor(object, xPos, yPos, level.plan[row][col]);
                }
                continue;
            }

            // Why didn't I just use [...].indexOf?
            // Oh well
            else if(belowSymbol === 'K' || belowSymbol === 'S' ||
            (belowSymbol === 'C' && (level.plan[row][col] === 'r' || 
            level.plan[row][col] === 's')) || belowSymbol === '@' || 
            belowSymbol === '[' || belowSymbol === "$" || 
            belowSymbol === 'B' || belowSymbol === 'H' || 
            belowSymbol === ']')
            {
                continue;
            }

            switch(level.plan[row][col])
            {
                case 'g' :
                    if(table['g'] === "blockSketchy")
                    {
                        gameObjects.getObject("imageBlock").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight, table['g']).physics.solidObject = false;
                    }
                    else if(levelInfo.theme === "underground")
                    {
                        gameObjects.getObject("stomper").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight);
                    }else{
                        gameObjects.getObject("ground").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight, color(107, 83, 60));
                    }
                    break;

                case 'd' :
                    if(levelInfo.theme === "ship")
                    {
                        gameObjects.getObject("rect").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight).color = color(0, 0, 0);
                    }
                    else if(levelInfo.isLightTower)
                    {
                        gameObjects.getObject("laserBlock").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight, 'd');
                    }else{
                        gameObjects.getObject("dirt").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight, color(107, 83, 60));
                    }
                    break;

                case ':' :
                    gameObjects.getObject("stalactite").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight, "BlueStalactite").physics.solidObject = false;
                    break;

                case ';' :
                    gameObjects.getObject("stalactite").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight, "GreenStalactite").physics.solidObject = false;
                    break;

                case ',' :
                    gameObjects.getObject("stalagmite").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight, "BlueStalagmite");
                    break;

                case '!' :
                    gameObjects.getObject("exclamationBlock").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight);
                    break;

                case 'b' : 
                    if(table['b'] === "steelBlock")
                    {
                        gameObjects.getObject("imageBlock").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight, "steelBlock");
                    }
                    else if(levelInfo.theme === "underground")
                    {
                        gameObjects.getObject("imageBlock").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight, "triangleBlockBlue");
                    }else{
                        gameObjects.getObject("block").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight, blockColor);
                    }
                    break;

                case 'w' : 
                    gameObjects.getObject("water").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight);
                    break;

                case 'z' :
                    gameObjects.getObject("lever").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight);
                    break;

                case '1' :
                    gameObjects.getObject(table['1'] || "filterBlock").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight);
                    break;

                case '2' :
                    if(typeof table['2'] !== "undefined")
                    {
                        gameObjects.getObject(table['2']).add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight);
                    }else{
                        var clr = ((typeof levelInfo.theme !== "undefined" && levelInfo.theme.toString() === "ninjaTemple") ? color(60, 18, 170, 214) : color(100, 128, 120, 214));
                        gameObjects.getObject("block").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight, clr);
                        gameObjects.getObject("block").getLast().physics.solidObject = false;
                    }
                    break;

                case '3' :
                    if(typeof table['3'] !== "undefined")
                    {
                        gameObjects.getObject(table['3']).add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight);
                    }
                    break;

                case '4' :
                    if(table['4'] !== undefined && loadedImages[table['4']] !== undefined)
                    {
                        gameObjects.getObject("imageBlock").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight, table['4']);
                    }
                    else if(table['4'] === "snowBlockOther")
                    {
                        gameObjects.getObject("snowBlock").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight, undefined, "other");
                    }
                    else if(typeof table['4'] !== "undefined")
                    {
                        gameObjects.getObject(table['4']).add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight);
                    }
                    break;

                case '5' :
                    if(table['5'] !== undefined && loadedImages[table['5']] !== undefined)
                    {
                        gameObjects.getObject("imageBlock").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight, table['5']);
                    }
                    else if(typeof table['5'] !== "undefined")
                    {
                        gameObjects.getObject(table['5']).add(xPos, yPos, levelInfo.unitWidth * 0.7);
                    }
                    break;

                case '6' :
                    gameObjects.getObject(table['6'] || "dirtyBlock").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight);
                    break;

                case '7' :
                    gameObjects.getObject("voxelizer").add(xPos + 4, yPos + 4, levelInfo.unitWidth - 8, levelInfo.unitHeight - 8);
                    break;

                case '8' :
                    gameObjects.getObject(table['8'] || "catDogStatue").add(xPos, yPos - levelInfo.unitHeight, levelInfo.unitWidth, levelInfo.unitHeight * 2);
                    break;

                case 'k' : 
                    gameObjects.getObject("dirtyCat").add(xPos, yPos, levelInfo.unitWidth * 2.0, levelInfo.unitHeight * 1.28);
                    break;

                case '_' :
                    if(table['_'] !== undefined && loadedImages[table['_']] !== undefined)
                    {
                        gameObjects.getObject("imageBlock").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight, table['_']);
                    }else{
                        gameObjects.getObject("snowLayer").add(xPos, yPos + levelInfo.unitHeight * 1.1, levelInfo.unitWidth, levelInfo.unitHeight * 0.1); 
                    }
                    break;

                case 'Q' :
                    gameObjects.getObject("hardCaseBlock").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight);
                    break;

                case 'G' :
                    gameObjects.getObject("fogMachine").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight);
                    break;

                case 'W' : 
                    if(table['W'] === "unWater")
                    {
                        gameObjects.getObject("water").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight);
                        gameObjects.getObject("water").getLast().freezable = false;
                    }else{
                        gameObjects.getObject("water").add(xPos - levelInfo.unitWidth, yPos - levelInfo.unitHeight, levelInfo.unitWidth * 3, levelInfo.unitHeight * 3);
                    }
                    break;

                case '=' :
                    if(table['='] === "darkBlock")
                    { 
                        gameObjects.getObject("imageBlock").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight, "darkBlock");
                    }
                    break;

                case '0' :
                    if(levelInfo.theme === "underground")
                    {
                        gameObjects.getObject("rect").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight).color = color(0, 0, 0);
                    }
                    else if(table['W'] === "unWater")
                    {
                        gameObjects.getObject("water").add(xPos - levelInfo.unitWidth, yPos - levelInfo.unitHeight, levelInfo.unitWidth * 3, levelInfo.unitHeight * 3);
                        gameObjects.getObject("water").getLast().freezable = false;
                    }
                    break;
                
                case 'T' :
                    if(levelInfo.theme !== "winter")
                    {
                        var w = levelInfo.unitWidth * 2;
                        var h = levelInfo.unitHeight * random(4, 6);
                        gameObjects.getObject("tree").add(xPos, yPos - (h - levelInfo.unitHeight), w, h);
                    }else{
                        var w = levelInfo.unitWidth * 2;
                        var h = levelInfo.unitHeight * 3.6;
                        gameObjects.getObject("tree").add(xPos, yPos - (h - levelInfo.unitHeight), w, h, "fur");
                    }
                    break;

                case 'q' :
                    gameObjects.getObject("quickSand").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight);
                    break;

                case 'i' :
                    gameObjects.getObject("ice").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight);
                    break;
                
                case 'C' :
                    var numX = random(1.5, 2.4);
                    var numY = random(1.4, 1.7);
                    var weather = "";
                    var aboveSymbol = this.getSymbol(col, row - 1, level.plan);
                    if(aboveSymbol === 'r')
                    {
                        weather = "rain";
                    }
                    else if(aboveSymbol === 's')
                    {
                        weather = "snow";
                    }
                    gameObjects.getObject("cloud").add(xPos - levelInfo.unitWidth * numX, yPos - levelInfo.unitHeight * 0.1,
                    levelInfo.unitWidth * numX * 2, levelInfo.unitHeight * numY, undefined, weather, "light", true);
                    break;

                case '#' :
                    gameObjects.getObject("lava").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight);
                    break;
                
                case 'e' :
                    gameObjects.getObject("fireBeaker").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight);
                    break;
                
                case 'E' :
                    if(levelInfo.theme === "surface")
                    {
                       gameObjects.getObject("lavaBeaker").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight);
                    }
                    else if(levelInfo.theme === "underground")
                    {
                       gameObjects.getObject("slimeBeaker").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight);
                    }else{
                       gameObjects.getObject("waterBeaker").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight);
                    }
                    break;
                
                case '%' :
                    if(levelInfo.theme === "underground")
                    {
                        gameObjects.getObject("imageBlock").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight, "triangleBlockGreen").green = true;
                    }else{
                        gameObjects.getObject("shooter").add(xPos + levelInfo.unitWidth / 2, yPos + levelInfo.unitHeight / 2, levelInfo.unitWidth);
                    }
                    break;

                case '9' :
                    //Could be used for grappling hooks
                    gameObjects.getObject("imageBlock").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight, "dark"); 
                    break;

                case '~' :
                    if(table['~'])
                    {
                        if(table['~'] === "palmTree")
                        {
                            gameObjects.getObject("palmTree").add(xPos - levelInfo.unitWidth * 2.0, yPos - levelInfo.unitHeight * 5.0, 
                                                                         levelInfo.unitWidth * 3.0, levelInfo.unitHeight * 6);
                        }else{
                            gameObjects.getObject("imageBlock").add(xPos - levelInfo.unitWidth * 0.5, yPos - levelInfo.unitHeight * 0.5, levelInfo.unitWidth * 1.5, levelInfo.unitHeight * 1.5, table['~']).physics.solidObject = false; 
                        }
                    }else{
                        gameObjects.getObject("imageBlock").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight, "cathodes2"); 
                    }
                    break;

                case '*' :
                    if(levelInfo.theme === "underground")
                    {
                        gameObjects.getObject("undergroundBlock").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight); 
                    }else{
                        gameObjects.getObject("cloudMine").add(xPos + levelInfo.unitWidth / 2, yPos + levelInfo.unitHeight / 2, levelInfo.unitWidth);
                    }
                    break;

                case '&' :
                    if(levelInfo.theme === "underground")
                    {
                        var bat = gameObjects.getObject("bat").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight);

                        if(this.getSymbol(col, row - 1, level.plan) === ' ')
                        {
                            bat.state = "flying";
                        }
                    }else{
                        gameObjects.getObject("skyViper").add(xPos, yPos, levelInfo.unitWidth * 1.35, levelInfo.unitHeight * 1.45);
                    }
                    break;

                case 'I' :
                    if(levelInfo.theme === "underground")
                    {
                        gameObjects.getObject("lamp").add(xPos + levelInfo.unitWidth * 0.25, yPos - levelInfo.unitHeight - 16, levelInfo.unitWidth / 2, levelInfo.unitHeight * 2 + 16, true);
                    }
                    else if(table['I'] === "ice")       
                    {
                        gameObjects.getObject("ice").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight, undefined, undefined, true);
                    }else{
                        gameObjects.getObject("ninja").add(xPos, yPos - levelInfo.unitHeight * 0.7, levelInfo.unitWidth * 1, levelInfo.unitHeight * 1.7);
                    }
                    break;

                case 'A' :
                    gameObjects.getObject("spike").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight);

                    if(levelInfo.theme === "winter")
                    {
                        gameObjects.getObject("spike").getLast().color = color(24, 184, 219);
                    }
                    break;

                case 'V' :
                    gameObjects.getObject("spike").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight, undefined, true);

                    if(levelInfo.theme === "winter")
                    {
                        gameObjects.getObject("spike").getLast().color = color(24, 184, 219);
                        gameObjects.getObject("spike").getLast().falls = true;
                        gameObjects.getObject("spike").getLast().winter = true;
                    }
                    break;

                case 'U' :
                    gameObjects.getObject("ladder").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight, (levelInfo.laddersWhite || backgrounds.background === "dark") ? color(230, 230, 230, 160) : undefined);
                    break;
                    
                case '+' :
                    if(levelInfo.theme === "ship")
                    {
                        gameObjects.getObject("imageBlock").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight, "exit");
                    }
                    else if(levelInfo.theme === "underground")
                    {
                        gameObjects.getObject("slasher").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight);
                    }else{
                        gameObjects.getObject("net").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight);
                    }
                    break;

                case '`' :
                    gameObjects.getObject("sonicBoomer").add(xPos + levelInfo.unitWidth / 2, yPos + levelInfo.unitWidth / 2, levelInfo.unitWidth);
                    break;

                case 'n' : 
                    gameObjects.getObject("movingLava").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight);
                    gameObjects.getObject("movingLava").getLast().xSpeed = 2;
                    break;
                    
                case 'N' : 
                    gameObjects.getObject("movingLava").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight);
                    gameObjects.getObject("movingLava").getLast().ySpeed = 2;
                    break;  
                    
                case 's' :
                    gameObjects.getObject("spring").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight);
                    break;
                    
                case 'P' : 
                    gameObjects.getObject("movingPlatform").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight, color(20, 20, 220), "up", true);
                    break;

                case 'x' :
                    gameObjects.getObject("crate").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight);
                    break;

                case '|' :
                    gameObjects.getObject("pillar").add(xPos, yPos - levelInfo.unitHeight * 3, levelInfo.unitWidth, levelInfo.unitHeight * 4, 122);
                    break;

                case '/' :
                    if(levelInfo.theme === "surface")
                    {
                        gameObjects.getObject("palmTree").add(xPos - levelInfo.unitWidth * 2.0, yPos - levelInfo.unitHeight * 5.0, 
                                                              levelInfo.unitWidth * 3.0, levelInfo.unitHeight * 6);
                    }
                    else if(levelInfo.theme === "underground")
                    {
                        gameObjects.getObject("lamp").add(xPos + levelInfo.unitWidth * 0.25, yPos - levelInfo.unitHeight - 16, levelInfo.unitWidth / 2, levelInfo.unitHeight * 2 + 16);
                    }else{
                        gameObjects.getObject("pillar").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight, 122, true);
                    }
                    break;

                case 'X' :
                    gameObjects.getObject("crate").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight, undefined, true);
                    break;

                case 'm' :
                    if(levelInfo.theme !== "winter")
                    {
                        gameObjects.getObject("movingPlatform").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight, color(200, 200, 20), "up");
                        gameObjects.getObject("movingPlatform").getLast().xSpeed = 1.5;
                    }else{
                        var platform = gameObjects.getObject("movingPlatform").add(xPos, yPos, levelInfo.unitWidth * 3 - levelInfo.unitWidth * 0.6, levelInfo.unitHeight, color(200, 200, 20), "up");
                        platform.xSpeed = 1.6;
                        platform.type = "blocks";
                    }
                    break;

                case 'M' :
                    if(table['M'] === "windowSky")
                    {
                        gameObjects.getObject("imageBlock").add(xPos, yPos, 236/2, 180/2, "windowSky").physics.solidObject = false;
                    }
                    else if(levelInfo.theme !== "winter")
                    {
                        gameObjects.getObject("movingPlatform").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight, color(200, 200, 20), "up");
                        gameObjects.getObject("movingPlatform").getLast().ySpeed = 1.5;
                    }else{
                        var platform = gameObjects.getObject("movingPlatform").add(xPos, yPos, levelInfo.unitWidth * 3 - levelInfo.unitWidth * 0.6, levelInfo.unitHeight, color(200, 200, 20), "up");
                        platform.ySpeed = 1.6;
                        platform.type = "blocks";
                    }
                    break;

                case 'c' : 
                    gameObjects.getObject("coin").add(xPos + levelInfo.unitWidth / 2, yPos + levelInfo.unitHeight / 2, levelInfo.unitWidth / 2);
                    break;
                    
                case 'h' :
                    gameObjects.getObject("hpCoin").add(xPos + levelInfo.unitWidth / 2, yPos + levelInfo.unitHeight / 2, levelInfo.unitWidth / 2, 0, 3);
                    break;

                case 'o' :
                    gameObjects.getObject("circle").add(xPos + levelInfo.unitHeight / 2, yPos + levelInfo.unitHeight / 2, levelInfo.unitWidth);
                    gameObjects.getObject("circle").getLast().color = color(175, 175, 175);
                    break;

                case 'O' :
                    gameObjects.getObject("ring").add(xPos + levelInfo.unitWidth, yPos + levelInfo.unitHeight, levelInfo.unitWidth * 2, color(175, 175, 175));
                    break;

                case 'F' : 
                    var fallingBlock = gameObjects.getObject("fallingBlock").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight);

                    if(levelInfo.theme === "winter")
                    {
                        fallingBlock.color = fallingBlock.originalColor = color(0, 0, 0, 90);
                    }
                    break;

                case 'u' : 
                    if(levelInfo.isLightTower)
                    {
                        gameObjects.getObject("laserBlock").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight, 'u');
                    }else{
                        gameObjects.getObject("backBlock").add(xPos, yPos, levelInfo.unitWidth * 4, levelInfo.unitHeight * 4);
                    }
                    break;

                case '<' : case '>' : case '^' : case 'v' :
                    var oneWay = gameObjects.getObject("oneWay").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight, color(120, 96, 81), ({
                        '<' : "left",
                        '>' : "right",
                        '^' : "up",
                        'v' : "down"
                    }[level.plan[row][col]]));

                    // Kind of lazy here...
                    if(level.specialOneWays || ((configs[levelInfo.theme] || {}).level || {}).specialOneWays)
                    {
                        switch(level.plan[row][col])
                        {
                            case '<' :
                                oneWay.draw = function()
                                {
                                    $pjs.pushMatrix();
                                    translate(this.xPos, this.yPos + this.height);
                                    rotate(270);
                                    image(loadedImages["up"], 0, 0, this.width, this.height);
                                    $pjs.popMatrix();
                                };
                                break;

                            case '>' :
                                oneWay.draw = function()
                                {
                                    $pjs.pushMatrix();
                                    translate(this.xPos + this.width, this.yPos);
                                    rotate(90);
                                    image(loadedImages["up"], 0, 0, this.width, this.height);
                                    $pjs.popMatrix();
                                };
                                break;

                            case '^' :
                                oneWay.draw = function()
                                {
                                    image(loadedImages["up"], this.xPos, this.yPos, this.width, this.height);
                                };
                                break;

                            case 'v' :
                                oneWay.draw = function()
                                {
                                    $pjs.pushMatrix();
                                    translate(this.xPos, this.yPos + this.height);
                                    scale(1, -1);
                                    image(loadedImages["up"], 0, 0, this.width, this.height);
                                    $pjs.popMatrix();
                                };
                                break;
                        }
                    }
                    break;

                case 'l' :
                    if(levelInfo.isLightTower)
                    {
                        gameObjects.getObject("laserBlock").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight, 'l');
                        break;
                    }

                case 'r' :
                    if(levelInfo.isLightTower)
                    {
                        gameObjects.getObject("laserBlock").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight, 'r');
                        break;
                    }

                case 'l' : case 'r' : case 'L' : case 'R' :
                    var clr = (level.theme !== "winter") ? color(0, 0, 0, 150) : color(33, 178, 227, 200);
                    gameObjects.getObject("slope").add(xPos, yPos, levelInfo.unitWidth * 2, levelInfo.unitHeight, clr);
                    gameObjects.getObject("slope").getLast().direction = ({
                        'l' : "leftup",
                        'r' : "rightup",
                        'L' : "leftdown",
                        'R' : "rightdown",
                    }[level.plan[row][col]]);

                    if(level.theme === "winter")
                    {
                        gameObjects.getObject("slope").getLast().slippy = true;
                    }
                    break;
                 
                case '@' :
                    var aboveSymbol = this.getSymbol(col, row - 1, level.plan);
                    gameObjects.getObject("npc").add(xPos, yPos - levelInfo.unitHeight, levelInfo.unitWidth, levelInfo.unitHeight * 2);
                    if(level.npcs !== undefined && level.npcs[aboveSymbol] !== undefined)
                    {
                        var npc = gameObjects.getObject("npc").getLast();
                        if(npcData[level.npcs[aboveSymbol].name] !== undefined)
                        {
                            npc.name = (level.npcs[aboveSymbol].name || "npc");

                                      /*[Primary, Secondary, FallBack]*/
                            npc.img = (npcData[level.npcs[aboveSymbol].name].img || level.npcs[aboveSymbol].img || npc.name);
                            npc.message = (level.npcs[aboveSymbol].input || npcData[level.npcs[aboveSymbol].name].input || npc.message);
                            npc.messagePattern = (npcData[level.npcs[aboveSymbol].name].pattern || level.npcs[aboveSymbol].pattern || npc.messagePattern);
                        }else{
                            npc.name = level.npcs[aboveSymbol].name || "npc";
                            npc.img = level.npcs[aboveSymbol].img;
                            npc.message = level.npcs[aboveSymbol].input || npc.message;
                            npc.messagePattern = level.npcs[aboveSymbol].pattern || npc.messagePattern;
                        }   
                    }
                    break;
                
                case 'B' :
                    var aboveSymbol = this.getSymbol(col, row - 1, level.plan);
                    if(level.bosses !== undefined && level.bosses[aboveSymbol] !== undefined)
                    {
                        switch(level.bosses[aboveSymbol].name)
                        {
                            case "ninjaBoss" :
                                gameObjects.getObject("ninjaBoss").add(xPos, yPos - levelInfo.unitHeight, 11 * 2.7, floor(28 * 2.7));
                                screenUtils.infoBar.bossArrayName = "ninjaBoss";
                                break;

                            case "iceDragon" :
                                gameObjects.getObject("iceDragon").add(xPos, yPos, 140, 74);
                                screenUtils.infoBar.bossArrayName = "iceDragon";
                                break;

                            case "captainFleep" :
                                gameObjects.getObject("captainFleep").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight);
                                screenUtils.infoBar.bossArrayName = "captainFleep";
                                break;
                        }
                    }
                    break;

                case 'H' :
                    var aboveSymbol = this.getSymbol(col, row - 1, level.plan);
                    if(level.hearts !== undefined && level.hearts[aboveSymbol] !== undefined)
                    {
                        gameObjects.getObject("heart").add(xPos, yPos, levelInfo.unitWidth, level.hearts[aboveSymbol].amt);
                    }
                    break;

                case 'S' :
                    var message = "";
                    var textColor = 0;
                    var colorValue;
                    var fontName;
                    var symbol = this.getSymbol(col, row - 1, level.plan);
                    var condition = (level.signs !== undefined && level.signs[symbol] !== undefined);

                    if(condition)
                    {
                        message = level.signs[symbol].message;
                        textColor = level.signs[symbol].textColor;
                        fontName = level.signs[symbol].font;

                        colorValue = level.signs[symbol].color;
                        var colorPack = level.signs[symbol].colorPack;
                        if(colorPack !== undefined)
                        {
                            colorValue = color(colorPack.red || 255, colorPack.green || 255, colorPack.blue || 255, colorPack.alpha || 255);
                        }
                    }

                    gameObjects.getObject("sign").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight, colorValue, message, textColor, fontName);

                    if(condition)
                    {
                        var sign = gameObjects.getObject("sign").getLast();
                        sign.adjustX = level.signs[symbol].adjustX;
                        sign.adjustY = level.signs[symbol].adjustY || -40;
                        sign.adjustW = level.signs[symbol].adjustW || 100;
                        sign.adjustH = level.signs[symbol].adjustH || 35;
                        sign.textSize = level.signs[symbol].textSize;

                        var textColorPack = level.signs[symbol].textColorPack;
                        if(textColorPack !== undefined)
                        {
                            sign.textColor = color(textColorPack.red || 255, textColorPack.green || 255, textColorPack.blue || 255, textColorPack.alpha || 255);
                        }

                        sign.load();
                    }
                    break; 
                    
                case 'p' :
                    levels.setPlayer(xPos, yPos, color(200, 10, 30));
                    break;
                    
                case 'D' :
                    var aboveSymbol = this.getSymbol(col, row - 1, level.plan);
                    var doorColor = ((level.doors[aboveSymbol].level !== plan.level) ? color(11 + 40, 68 + 40, 153 + 40) : undefined);

                    var arrayName = !level.doors[aboveSymbol].magic ? "door" : "magicDoor";
                    gameObjects.getObject(arrayName).add(xPos, yPos - levelInfo.unitHeight, levelInfo.unitWidth, levelInfo.unitHeight * 2, doorColor);
                    var door = gameObjects.getObject(arrayName).getLast();
                    door.goto = level.doors[aboveSymbol];
                    door.symbol = aboveSymbol;
                    door.magic = level.doors[aboveSymbol].magic;

                    //Reminder
                    if(level.doors[aboveSymbol].symbol === undefined)
                    {
                        println("Error : missing goto symbol in door '" + aboveSymbol + "'"); 
                    }
                    break;
                    
                case 'f' :
                    gameObjects.getObject("checkPoint").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight);
                    var checkPoint = gameObjects.getObject("checkPoint").getLast();
                    if(checkPoint.goto === undefined)
                    {
                        checkPoint.goto = {};
                    }
                    checkPoint.goto.level = levelInfo.level;
                    for(var i = 0; i < travelObjects.length; i++)
                    {
                        this.setObjectAtCheckPoint(gameObjects.getObject(travelObjects[i].arrayName).input(travelObjects[i].index), xPos, yPos);
                    }
                    break;
                    
                case 'K' :
                    var entered = this.getSymbol(col, row - 1, level.plan);
                    var scope = level.keys[entered];

                    if(!scope.collected && levels[scope.level].doors[scope.symbol] !== undefined && levels[scope.level].doors[scope.symbol].locked)
                    {
                        gameObjects.getObject("key").add(xPos + levelInfo.unitWidth * 0.2, yPos, levelInfo.unitWidth / 2, levelInfo.unitHeight);
                        gameObjects.getObject("key").getLast().goto = scope;
                        gameObjects.getObject("key").getLast().goto.entered = entered;
                    }
                    break;

                case '$' :
                        try{
                            var entered = this.getSymbol(col, row - 1, level.plan);
                            var scope = level.special[entered];
                            scope.arguments = scope.arguments || {}; 
                            switch(scope.shape)
                            {
                                case "circle" :
                                    gameObjects.getObject(scope.arrayName).add(xPos, yPos, scope.diameter || levelInfo.unitWidth, scope.arguments['4']);
                                    break;

                                case "rect" : default :
                                    gameObjects.getObject(scope.arrayName).add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight);
                                    break;
                            }
                        }
                        catch(e)
                        {
                            console.log(e);
                        }
                    break;

                case '[' :
                    gameObjects.getObject("chest").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight);
                    if(level.chests !== undefined)
                    {
                        var scope = level.chests[this.getSymbol(col, row - 1, level.plan)];
                        gameObjects.getObject("chest").getLast().drops = scope.drops;
                        gameObjects.getObject("chest").getLast().goto = scope;
                    }
                    break;

                case ']' :
                    gameObjects.getObject("itemChest").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight);

                    if(level.itemChests !== undefined)
                    {
                        var scope = level.itemChests[this.getSymbol(col, row - 1, level.plan)];
                        gameObjects.getObject("itemChest").getLast().goto = scope;
                    }
                    break;

                case 't' :
                    gameObjects.getObject("spaceBreaker").add(xPos + levelInfo.unitWidth / 2, yPos + levelInfo.unitHeight / 2, levelInfo.unitWidth / 2); 
                    break;

                case '.' :
                    gameObjects.getObject("point").add(xPos + levelInfo.unitWidth / 2, yPos + levelInfo.unitHeight / 2, levelInfo.unitWidth * 0.7);
                    break;

                case '\'':
                    gameObjects.getObject("gem").add(xPos, yPos, levelInfo.unitWidth, levelInfo.unitHeight);
                    break;
            }
            done = (row >= level.plan.length - 1);
        }
    }
    return done;
};

////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
/**************************************************************Game-Loader*****************************************************************/
////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

var f_getArrayNamesToSave = function(level, theme)
{
    var lvl = level || levelInfo.level;
    var thm = theme || levelInfo.theme;

    var preSelect = (levels[lvl].arraysToSave || 
    (configs[thm] || {level : {}}).level.arraysToSave) || [];

    preSelect.push("gem");

    if(typeof levels[lvl].addArraysToSave !== "undefined")
    {
        preSelect = preSelect.concat(levels[lvl].addArraysToSave);
    }

    if(typeof levels[lvl].removeArraysToSave !== "undefined")
    {
        var rmv = levels[lvl].removeArraysToSave;

        for(var i = 0; i < rmv.length; i++)
        {
            preSelect = preSelect.filter(arrayName => arrayName !== rmv[i]);
        }
    }

    return preSelect;
};

game.startFade = function(top)
{
    screenUtils.fade.start(20, (top) ? 20 : 0);
};
loader.setProps = function(level)
{
    this.loops = 0;
    this.levelStepRows = this.levelStepRows || 1;
    //+ The amount of steps - 1, that we can not calculate
    this.estLoops = (levels[level].plan.length / this.levelStepRows) + 4;
    this.point = 0;
    this.step = 0;
    this.returned = {};
};
loader.startLoadLevel = function(level, actType, objectIndex, onToLoadFunc)
{
    levelInfo._lastLevel = levelInfo.level; 
    this.level = level;
    game.cutScening = false;
    game.startFade(this.firstLoad);
    screenUtils.needsScreenShot = true;
    game.tempState = game.gameState;
    game.gameState = "load";
    loader.setProps(level);

    levelScripts.openLoad();

    this.objectIndex = objectIndex;
    this.actType = actType;

    this.onToLoadFunc = onToLoadFunc;

    if(actType === "door")
    {
        configAreaSaver.saveToLevelCache(levelInfo._lastLevel, f_getArrayNamesToSave(levelInfo._lastLevel, levelInfo.theme), levelInfo.theme);
    }
};
loader.loadLevel = function(level, step, levelStep)
{
    var toReturn = {};
    this.loops++;
    switch(step)
    {
        case 0 :
            var player = gameObjects.getObject("player").getLast();
            if(player.dead && saver.current.loaded)
            {
                saver.current.loaded = false;
            }
            game.loadSave(saver.current.saveDataName);
            levelInfo.lastLevel = levelInfo.level;
            levelInfo.level = level;
            gameObjects.removeObjects();
            levelScripts.restart();
            levelScripts.beforeLoad();
            lighting.end();
            delete screenUtils.infoBar.bossArrayName;
            delete cam.yMost;
            cam.keepInGrid = true;
            delete game.dropRate;
            delete cam.useAnotherScale;
            delete cam.ANScaleX;
            delete cam.ANScaleY;
            break;
        
        case 1 :
            if(!levels.build({
                level : level,
                minRow : this.levelStepRows * levelStep,
                maxRow : this.levelStepRows * (levelStep + 1),
                first : (levelStep === 0),
            }))
            {
                toReturn = {
                   setStep : 1, 
                   levelStep : levelStep + 1,
                }; 
            }
            break;
        
        case 2 :
            if(levels[levelInfo.level].createStars)
            {
                if(levelInfo.cellWidth !== 800)
                {
                    levelInfo.lastCellWidth = levelInfo.cellWidth;
                }
                if(levelInfo.cellHeight !== 800)
                {
                    levelInfo.lastCellHeight = levelInfo.cellHeight;
                }

                levelInfo.cellWidth = cellWidth = 800;
                levelInfo.cellHeight = cellHeight = 800;

                levelInfo.width = 800 * 30;
                levelInfo.height = 800 * 30;
            }else{
                levelInfo.cellWidth = levelInfo.lastCellWidth || levelInfo.cellWidth;
                levelInfo.cellHeight = levelInfo.lastCellHeight || levelInfo.cellHeight;
            }

            //Grids of the game (Important)
            cameraGrid.setup(levelInfo.xPos, levelInfo.yPos, levelInfo.width / levelInfo.cellWidth, levelInfo.height / levelInfo.cellHeight, levelInfo.cellWidth, levelInfo.cellHeight);
            gameObjects.addObjectsToCameraGrid();
            if((levelInfo.nightMode || levelInfo.daylightCycle) && !this.firstLoad)
            {
                lighting.create();
            }
            gameObjects.setAfter();
            break;
            
        case 3 :
            backgrounds.load();
            if(levelInfo.daylightCycle)
            {
                if(levelInfo.nightMode)
                {
                    daylightCycle.setState("night");
                }else{
                    daylightCycle.setState("day");
                }
            }
            break;
            
        case 4 :
            var conf = configs[(levels[levelInfo.level] || {}).theme];
            if(conf && conf.level && conf.level.noSong && levelInfo.lastSong && sounds.sounds[levelInfo.lastSong])
            {
                sounds.stopSound(levelInfo.lastSong);
            }
            else if(levelInfo.currentSong !== levelInfo.lastSong)
            {
                sounds.playSound(levelInfo.currentSong, true);
            }

            // Make sure we're not playing multiple songs at once!
            for(var i in sounds.sounds)
            {
                if(sounds.sounds[i].type === "song" && i !== levelInfo.currentSong)
                {
                    sounds.stopSound(i, true);
                }
            }

            for(var i in storedImages)
            {
                if(storedImages[i].__isDirty)
                {
                    storedImages[i].updatePixels();
                }

                if(!storedImages[i].toImageData && storedImages[i].loadPixels)
                {
                    storedImages[i].loadPixels();
                }

                if(!storedImages[i].noSourceImg && storedImages[i].toImageData)
                {
                    storedImages[i].sourceImg = getSourceImg(storedImages[i]);
                }
            }

            // Set player reference and attach it to the camera directly
            player = gameObjects.getObject("player").input(0);

            if(levels[levelInfo.level].createStars)
            {
                if(player._places)
                {
                    cameraGrid.removeReference(player);
                }
            }

            cam.attach(function()
            {
                return player;
            }, true);

            game.loadSaveAfterLoad();
            player.safeRevive(); // Revive the player when dead
            levelScripts.afterLoad();

            configAreaSaver.setFromLevelCache(loader.level, f_getArrayNamesToSave(loader.level, levelInfo.theme), levelInfo.theme);

            if(loader.onToLoadFunc !== undefined)
            {
                loader.onToLoadFunc();
                delete loader.onToLoadFunc;
            }

            toReturn = {
                loaded : true,
            };
            break;
    }
    return toReturn;
};
loader.update = function()
{
    if(this.firstLoad)
    {
        backgrounds.primeLoad();
        buttons.load();
        sliders.load();
        lighting.create();
        screenUtils.load();
        levels.clearCache();
        debugTool.setup();
        ctx.restore();

        this.loadCount = 0;
    }
    
    if(screenUtils.fade.full() || (!this.tempLoaded && this.step >= 1))
    {
        frameRate(game.loadFps || game.fps);

        this.returned = this.loadLevel(this.level, this.step, (this.returned.levelStep || 0));
        this.tempLoaded = this.returned.loaded;
        this.step++;
        if(this.returned.setStep !== undefined)
        {
            this.step = this.returned.setStep;  
        }
        screenUtils.fade.stopped = !this.tempLoaded;
        if(!this.firstLoad && this.tempLoaded && game.tempState !== "menu")
        {
            // var player = gameObjects.getObject("player").getLast();
            game.play(game.tempState !== "play" && player.goto.travelType !== "door", true);
            screenUtils.messages.length = 0;

            if(!scaled)
            {
                screenUtils.screenShot = get(0, 0, width, height);
            }else{
                screenUtils.screenShot = get(0, 0, screen.width, screen.height);
            }
        }

        this.firstLoad = false;
        debugTool.active = false;
    }

    /*A little hack to stop the background from snapping*/
    if(backgrounds.backgrounds[backgrounds.background].moves)
    {
        var object = player;

        if(this.loadCount >= (firstGameState === "play" ? 0 : 2) && object && object.xPos)
        {
            cam.focusXPos = object.boundingBox.xPos + (object.boundingBox.width / 2);
            cam.focusYPos = object.boundingBox.yPos + (object.boundingBox.height / 2);

            cam.focusXPos = constrain(cam.focusXPos, levelInfo.xPos + cam.halfWidth, 
                                    levelInfo.xPos + levelInfo.width - cam.halfWidth);
            cam.focusYPos = constrain(cam.focusYPos, levelInfo.yPos + cam.halfHeight, 
                                    levelInfo.yPos + levelInfo.height - cam.halfHeight);
        }
    }

    if(!screenUtils.fade.fading)
    {
        this.tempLoaded = false;
        game.gameState = (game.tempState !== "load") ? game.tempState : "play";

        if(game.gameState === "play" && firstGameState !== "play")
        {
            game.tryShowNewArea();
        }

        frameRate(game.fps);

        this.loadCount++;
    }

    if(screenUtils.screenShot !== undefined && !screenUtils.fade.full())
    {
        image(screenUtils.screenShot, 0, 0, width, height);
    }
};
loader.startLoadLevel(levelInfo.level);

game.tryShowNewArea = function()
{
    if(typeof configs[levelInfo.theme] !== "undefined" && !configs[levelInfo.theme].shownName &&
    levelInfo.theme === levels[levelInfo.level].theme && configs[levelInfo.theme].name !== undefined && !configs[levelInfo.theme].hidden)
    {
        screenUtils.createMessage(configs[levelInfo.theme].name, 200, 180, 150, 30, {
            textSize : 13,
            textColor : color(250, 250, 250, 300),
        });

        screenUtils.createMessage(configs[levelInfo.theme].area, 200, 220, 60, 15, {
            textSize : 9,
            textColor : color(250, 250, 250, 300),
        });

        configs[levelInfo.theme].shownName = true;
    }
};
game.loadSave = function(saveDataName)
{
    if(saver.current.loaded)
    {
        return;
    }

    if(!saver.setCurrent(saveDataName))
    {
        saver.current.loaded = true;
        return;
    }

    this.data = saver.readSaveData(saveDataName);

    levelInfo.level = this.data.level || levelInfo.level;
    loader.level = levelInfo.level;
    
    this.configAreas = this.data.configAreas || this.configAreas;
    levels.clearCache();

    var discoveredAreas = this.data.discoveredAreas || {};

    for(var i in discoveredAreas)
    {
        (configs[i] || {}).shownName = discoveredAreas[i].shownName;
    }

    if(typeof this.data.ship === "object")
    {
        var _shipGoto = this.data.ship.goto || shipGoto;

        // if(_shipGoto.inSpace)
        // {
            for(var i in _shipGoto)
            {
                shipGoto[i] = _shipGoto[i];
            }
        // }

        // if(this.data.ship && this.data.ship.goto)
        // {
        //     for(var i in this.data.ship.goto)
        //     {
        //         shipGoto[i] = this.data.ship.goto[i];
        //     }
        // }
    }

    if(player.dead)
    {
        gameObjects.getObject("chest").forEach(function(element, index, array)
        {
            if(element.opened)
            {
                element.goto.isOpen = false;
                element.opened = false;
            }
        });
    }

    //Load in doors
    this.usedDoors = this.data.doors;
    for(var i in this.data.doors)
    {
        var door = this.data.doors[i];
        try{
            levels[door.level].doors[door.symbol].locked = door.locked;
        }
        catch(e) {}
    }

    if(this.data.openedChests !== undefined)
    {
        for(var i in this.data.openedChests)
        {
            if(levels[i].chests !== undefined)
            {
                for(var j in this.data.openedChests[i])
                {
                    if(levels[i].chests[j].save) 
                    {
                        if(this.data.openedChests[i][j].isOpen !== undefined)
                        {
                            levels[i].chests[j].isOpen = this.data.openedChests[i][j].isOpen;
                        }
                        if(this.data.openedChests[i][j].hidden !== undefined)
                        {
                            levels[i].chests[j].hidden = this.data.openedChests[i][j].hidden;
                        }

                        if(this.data.openedChests[i][j].openDrops !== undefined)
                        {
                            for(var l in levels[i].chests[j].drops)
                            {
                                if(levels[i].chests[j].drops[l].col1)
                                {
                                    try{
                                        delete levels[i].chests[j].drops[l].col1;
                                    }
                                    catch(e) {}
                                } 
                            }
                            for(var k in this.data.openedChests[i][j].openDrops)
                            {
                                if(this.data.openedChests[i][j].openDrops[k])
                                {
                                    try{
                                        levels[i].chests[j].drops[k].col1 = true;
                                    }
                                    catch(e) {}
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    if(this.data.itemChestGotos !== undefined)
    {
        var itemChestGotos = this.data.itemChestGotos;

        for(var i in itemChestGotos)
        {
            try{
                if(levels[i] !== undefined && levels[i].itemChests !== undefined)
                {
                    for(var j in itemChestGotos[i])
                    {
                        if(levels[i].itemChests[j] === undefined)
                        {
                            delete itemChestGotos[i][j];
                            continue;
                        } 

                        levels[i].itemChests[j] = itemChestGotos[i][j];
                    }
                }
            }
            catch(e) 
            {
                console.log(e);
            }
        }
    }

    if(this.data.custom !== undefined)
    {
        for(var i in this.data.custom)
        {
            if(levels[i] !== undefined)
            {
                levels[i].save = this.data.custom[i];
            }
        }
    }

    //Load in the key info
    if(this.data.player !== undefined && this.data.player.goto.keysHolding !== undefined)
    {
        var keys = this.data.player.goto.keysHolding;
        for(var i in keys)
        {
            if(keys[i] !== undefined && levels[keys[i].level].keys !== undefined)
            {
                if(levels[keys[i].level].keys[keys[i].entered] !== undefined)
                {
                    levels[keys[i].level].keys[keys[i].entered] = keys[i];
                }
            }
        }
    }

    if(this.configAreas !== undefined)
    {
        for(var area in this.configAreas)
        {
            for(var level in this.configAreas[area].levels)
            {
                levels[level].cache.objectsExists = convertToBoolean(this.configAreas[area].levels[level].objectsExists || {});
            }
        }
    }
};
game.loadSaveAfterLoad = function()
{
    if(this.data === undefined || saver.current.loaded)
    {
        return;
    }

    //Find Player
    // player = gameObjects.getObject("player").getLast();
    player.alias = saver.current.name;
    player.username = removeEndIfNum(saver.current.name);

    /*Player save-loading*/
    if(this.data.player !== undefined)
    {
        player.coins = this.data.player.coins || player.coins;
        player.gems = this.data.player.gems || player.gems;
        player.score = this.data.player.score || player.score;
        player.defense = this.data.player.defense || player.defense;
        player.goto = this.data.player.goto || player.goto;
        player.hp = this.data.player.hp || player.hp;
        player.maxHp = this.data.player.maxHp || player.maxHp;
        player.name = this.data.name || player.name;
        player.crystals = this.data.player.crystals || player.crystals;

        var inventory = this.data.player.inventory;

        if(inventory && inventory.items && inventory.slots)
        {
            player.inventory.slots = 10;

            // Commented out for now because this enables item duplication glitch
            // Unless we restored every chest which we do not want to do yet...

            if(!this.savedThis)
            {
                player.inventory.items = Array(10).fill({});
                for(var i = 0; i < inventory.items.length; i++)
                {
                    player.inventory.items[i] = (inventory.items[i]);
                }

                this.savedThis = true;
            }

            // if(typeof player.inventory.items !== "array")
            // {
            //     player.inventory.items = Array(10).fill({});
            // }
            // while(player.inventory.items.length < 10)
            // {
            //     player.inventory.items.push({});
            // }
        }else{
            console.warn("Could not restore item slots using last items instead...");
        }

        if(typeof this.data.autoCheckPoints === "boolean")
        {
            game.autoCheckPoints = this.data.autoCheckPoints;
        }

        if(typeof this.data.hideKeys === "boolean")
        {
            game.hideKeys = this.data.hideKeys;
        }

        if(this.data.player.autoRun !== undefined && !this._ft_autoRun)
        {
            player.autoRun = this.data.player.autoRun;
        }
        this._ft_autoRun = true;

        if(!this._ft_settings && this.data.settings && !game.overrideDebugSettings)
        {
            var lastFps = game.fps;
            game.fps = this.data.settings.fps || game.fps;
            game.fpsType = this.data.settings.fpsType || game.fpsType;

            if(!game.fps)
            {
                game.fps = 60;
            }

            if(lastFps !== game.fps)
            {
                game.applyFps();
            }

            game.debugMode = (this.data.settings.debugMode !== undefined) ? this.data.settings.debugMode : game.debugMode;
            game.showDebugPhysics = (this.data.settings.showDebugPhysics !== undefined) ? this.data.settings.showDebugPhysics : game.showDebugPhysics;
            game.boundingBoxes = (this.data.settings.boundingBoxes !== undefined) ? this.data.settings.boundingBoxes : game.boundingBoxes;
 
            this.ft_settings = true;
        }

        player.discoveredPowers = this.data.player.discoveredPowers || player.discoveredPowers;
        player.discoveredPowersHandler.init();
        player.discoveredPowersHandler.setChangePowers();

        //Who wants to die and and keep on having to switch power-ups? So just keep the current power-up when you die.
        if(!this.everAfterLoaded)
        {
            player.discoveredPowersHandler.currentPower = this.data.player.currentPower || player.discoveredPowersHandler.currentPower;
        }

        //Make sure the player is at the right checkPoint!
        var checkPoints = gameObjects.getObject("checkPoint");
        if((player.goto.checkPointLevel === levelInfo.level || 
           player.goto.checkPointLevel === loader.level) &&
           player.goto.checkPointIndex !== undefined && 
           player.goto.checkPointIndex < checkPoints.length)
        {
            var checkPoint = checkPoints[player.goto.checkPointIndex];
            physics.teleport(player, checkPoint.xPos, checkPoint.yPos - abs(player.height - levelInfo.unitHeight));
            checkPoint.setObjectProps(player);
        }

        if(this.data.player.powers !== undefined)
        {
            player.setPowers(this.data.player.powers);
        }
    }

    if(!this.revertFirst)
    {
        /*Sound save-loading*/
        if(typeof this.data.soundPercent === "number")
        {
            sounds.setMainVolume(this.data.soundPercent / 100);
            this.percent = this.data.soundPercent / 100;
        }
        if(typeof this.data.soundOff === "boolean")
        {
            sounds.settings.off = this.data.soundOff;

            for(var i in sounds.sounds)
            {
                sounds.sounds[i].muted = (sounds.settings.off);
            }
        }
        if(typeof this.data.soundSong === "boolean")
        {
            sounds.settings.song = this.data.soundSong;

            game.sound.applySongs();
        }

        this.revertFirst = true;
    }

    saver.current.loaded = true;
    this.everAfterLoaded = true;
};
game.save = function(checkPoint)
{
    this.customSaveData = {};

    var openedChests = {};
    for(var i in levels)
    {
        this.customSaveData[i] = levels[i].save || {};

        if(levels[i].chests !== undefined)
        {
            openedChests[i] = {};
            for(var j in levels[i].chests)
            {
                openedChests[i][j] = {};
                if(levels[i].chests[j].save)
                {
                    if(levels[i].chests[j].isOpen !== undefined)
                    {
                        openedChests[i][j].isOpen = levels[i].chests[j].isOpen;
                    }
                    if(levels[i].chests[j].hidden !== undefined)
                    {
                        openedChests[i][j].hidden = levels[i].chests[j].hidden;
                    }

                    if(openedChests[i][j].openDrops === undefined)
                    {
                        openedChests[i][j].openDrops = {};
                    }

                    for(var k in levels[i].chests[j].drops)
                    {
                        if(levels[i].chests[j].drops[k].col1)
                        {
                            openedChests[i][j].openDrops[k] = true;
                        }
                    }
                }
            }
        }
    }

    configAreaSaver.saveToLevelCache(levelInfo.level, f_getArrayNamesToSave(levelInfo.level, levelInfo.theme), levelInfo.theme);

    if(this.configAreas === undefined)
    {
        //You've never been in any areas before? Add it!

        this.configAreas = {};

        for(var i in configs)
        {
            this.configAreas[i] = {
                levels : {},
            };
        }

        for(var i in levels)
        {
            if(typeof levels[i].theme === "string" && 
               typeof configs[levels[i].theme] !== "undefined")
            {
                this.configAreas[levels[i].theme].levels[i] = {};
            }
        }
    }else{
        //Cover new areas added to the game

        for(var i in configs)
        {
            if(typeof this.configAreas[i] === "undefined" || typeof this.configAreas[i].levels === "undefined")
            {
                this.configAreas[i] = {
                    levels : {},
                };

                for(var j in levels)
                {
                    if(typeof levels[j].theme !== "undefined" && 
                        levels[j].theme.toString() === i.toString())
                    {
                        this.configAreas[i].levels[j] = {};
                    }
                }

                continue;
            }

            for(var j in levels)
            {
                if(typeof this.configAreas[i].levels[j] === "undefined" && 
                    typeof levels[j].theme !== "undefined" && 
                    levels[j].theme.toString() === i.toString())
                {
                    this.configAreas[i].levels[j] = {};
                }
            }
        }
    }

    var discoveredAreas = {};

    for(var i in configs)
    {
        discoveredAreas[i] = {
            shownName : configs[i].shownName,
        };
    }

    for(var area in this.configAreas)
    {
        for(var level in this.configAreas[area].levels)
        {
            this.configAreas[area].levels[level].objectsExists = convertToBinary(
                levels[level].cache.objectsExists ||
                this.configAreas[area].levels[level].objectsExists || {});
        }
    }

    var itemChestGotos = {};

    for(var i in levels)
    {
        try{
            if(levels[i].itemChests !== undefined)
            {
                itemChestGotos[i] = levels[i].itemChests;
            }
        }
        catch(e) 
        {
            console.log(e);
        }
    }

    levelScripts.onSave();

    for(var i in player.crystals)
    {
        delete player.crystals[i].object;
    }

    var saveSettings = (!game.overrideDebugSettings) ? {
        fps : game.fps,
        fpsType : game.fpsType,
        debugMode : game.debugMode,
        showDebugPhysics : game.showDebugPhysics,
        boundingBoxes : game.boundingBoxes
    }
    : ((this.data || {}).settings || {});

    var inventory = {};

    inventory.slots = player.inventory.slots || 10;
    inventory.items = Array(inventory.slots).fill({});

    for(var i = 0; i < player.inventory.items.length; i++)
    {
        inventory.items[i] = player.inventory.items[i] || {};
    }

    var _shipGoto = {};
    for(var i in shipGoto)
    {
        if(typeof shipGoto[i] !== "function")
        {
            _shipGoto[i] = shipGoto[i];
        }
    }

    if(shipGoto.inSpace && shipGoto.haveNotSavedSince)
    {
        shipGoto.haveNotSavedSince = false;
    }

    var success = saver.overWriteSaveData(saver.current.saveDataName, {
        name : saver.current.name,
        level : player.goto.checkPointLevel || levelInfo.level,
        dead : player.dead,
        soundPercent : sounds.getMainVolume() * 100,
        soundOff : sounds.settings.off,
        soundSong : sounds.settings.song,
        player : {
            autoRun : player.autoRun,
            coins : player.coins,
            gems : player.gems,
            score : player.score,
            defense : player.defense,
            goto : player.goto,
            hp : player.hp,
            maxHp : player.maxHp,
            inventory : inventory,
            crystals : player.crystals,
            powers : player.getPowers(),
            discoveredPowers : player.discoveredPowers,
            currentPower : player.discoveredPowersHandler.currentPower,
            shipGoto : _shipGoto
        },
        ship : {
            goto : _shipGoto
        },
        autoCheckPoints: game.autoCheckPoints,
        hideKeys: game.hideKeys,
        settings : saveSettings,
        doors : this.usedDoors || {},
        openedChests : openedChests,
        custom : this.customSaveData || {},
        configAreas : this.configAreas,
        discoveredAreas : discoveredAreas,
        itemChestGotos : itemChestGotos,
    });

    if(success)
    {
        console.log("Helix's Adventure: Game successfully saved!");
    }

    // Set checkpoint...
    if(checkPoint !== undefined)
    {
        player.goto.checkPointLevel = (checkPoint.goto !== undefined) ? checkPoint.goto.level || levelInfo.level : levelInfo.level;
        player.goto.checkPointIndex = checkPoint.index;
    }
};

////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
/**************************************************************Game-Scenes*****************************************************************/
////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

game.load = function()
{
    loader.update();
};
game.switchGameState = function(condition, state, needsScreenShot, func)
{
    if(condition)
    {
        this.startFade();
        this.switchedState = true;
        this.switchState = state;

        if(needsScreenShot)
        {
            screenUtils.needsScreenShot = true;
        }

        if(this[this.gameState].done)
        {
            this[this.gameState].done = false;
        }

        if(!this[this.switchState].done)
        {
            this[this.switchState].done = true; 
            this.lastState = this.gameState;
            (this[this.switchState].onEnter || function(){})();

            if(typeof func === "function")
            {
                func.apply(this, []);
            }
        }
    }
};
game.restart = function()
{
    if(MODE === "ka")
    {
        Program.restart();
    }else{
        window.location.reload();
    }
};
game.how = function()
{
    textFont(fonts.menu);

    fill(0, 0, 0, 60);
    fastRect(75, 0, width - 75 * 2, height);
    fill(11, 68, 153, 80);
    $pjs.rect(102, 100, 206, 238, 10);
    fill(200, 200, 200, 150);
    textAlign(NORMAL, NORMAL);
    text("  Use the arrow keys to move or wasd." +
    " Press down to go through doors or to activate checkpoints." +
    " Press 'p' to pause, 'r' to restart, 't' to print what" +
    " signs say if you can't read it and 'm' to go directly to the menu." +
    "\n\n   This is basically the sequel to Planet Search If you haven't played that first " +
    "please play it right now (press '1').\n\n        Created by ProlightHub on Github & Phantom Falcon on Khan Academy (same).", 106, 110, 200, 225);
    fill(0, 0, 0, 100);
    text(game.version, 334, 394); 
    buttons.back2.draw();
    this.switchGameState(buttons.back2.clicked(), "menu");

    if(keys["1"])
    {
        window.location.href = "https://prolighthub.itch.io/planet-search";
    }
};
game.settings = function()
{
    textFont(fonts.menu);

    textSize(40);
    fill(31, 173, 88);
    textAlign(CENTER, CENTER);
    text("Debug", 200, 110);
    fill(0, 0, 0, 60);
    fastRect(75, 0, width - 75 * 2, height);
    fill(0, 0, 0, 100);
    textSize(12);
    text(game.version, 364, 390); 
    buttons.back2.draw();
    this.switchGameState(buttons.back2.clicked(), "extras");
    buttons.debugMode.draw();
    buttons.debugMode.message = "DebugMode " + game.debugMode;
    buttons.debugPhysics.draw();
    buttons.debugPhysics.message = "DebugPhysics " + (game.showDebugPhysics || false);
    buttons.boundingBoxes.draw();
    buttons.boundingBoxes.message = "BoundingBoxes " + (game.boundingBoxes || false);
    buttons.info.draw();
    
    if(buttons.info.clicked())
    {
        noStroke();
        $pjs.rect(100, 340, 200, 40, 10);
        textAlign(CENTER, NORMAL);
        fill(200, 200, 200, 200);
        textSize(8);
        text("In debug mode you can press right click to show the Cartesian System (Grid).\nDelag buttons: F9/F10/F11", 100, 350, 200, 40);
    }
};
game.settings.mousePressed = function()
{
    if(buttons.debugMode.clicked())
    {
        game.debugMode = !game.debugMode;
    }
    if(buttons.debugPhysics.clicked())
    {
        game.showDebugPhysics = !game.showDebugPhysics;
    }
    if(buttons.boundingBoxes.clicked())
    {
        game.boundingBoxes = !game.boundingBoxes;
    }
};
game.extras = function()
{
    textFont(fonts.menu);

    textSize(40);
    fill(31, 173, 88);
    textAlign(CENTER, CENTER);
    text("Extras", 200, 110);
    fill(0, 0, 0, 60);
    fastRect(75, 0, width - 75 * 2, height);
    fill(0, 0, 0, 100);
    textSize(12);
    text(game.version, 364, 390); 
    buttons.back2.draw();
    this.switchGameState(buttons.back2.clicked(), "menu");
    buttons.settings.draw();
    this.switchGameState(buttons.settings.clicked(), "settings");
    buttons.sound.draw();
    this.switchGameState(buttons.sound.clicked(), "sound");
    buttons.other.draw();
    this.switchGameState(buttons.other.clicked(), "other");
    buttons.controls.draw();
    this.switchGameState(buttons.controls.clicked(), "controls");

    textSize(12);
    text("Note: These changes will not save\nuntil you save your game!", 200, 364);
};
game.controls = function()
{
    textFont(fonts.menu);

    textSize(40);
    fill(31, 173, 88);
    textAlign(CENTER, CENTER);
    text("Controls", 200, 110);
    fill(0, 0, 0, 60);
    fastRect(75, 0, width - 75 * 2, height);
    fill(0, 0, 0, 100);
    textSize(12);
    text(game.version, 364, 390);

    buttons.back2.draw();
    this.switchGameState(buttons.back2.clicked(), "extras");
    buttons.auto.draw();

    fill(0, 0, 0, 134);
    textAlign(CENTER, CENTER);
    textSize(11);
    textFont(fonts.menu);

    buttons.auto.message = "Auto save " + game.autoCheckPoints;

    if(observer.collisionTypes.pointrect.colliding({xPos : mouseX, yPos : mouseY}, buttons.auto))
    {
        text("Automatically use checkpoints\n and Hp regenerators", 200, 362);
    }

    text("Make sure you save your game for\nthese changes to take effect!", 200, 314);
};
game.controls.mousePressed = function()
{
    if(buttons.auto.clicked())
    {
        game.autoCheckPoints = !game.autoCheckPoints;
    }
    buttons.auto.message = "Auto save " + game.autoCheckPoints;
};
game.other = function()
{
    textSize(40);
    fill(31, 173, 88);
    textAlign(CENTER, CENTER);
    text("Fps", 200, 110);
    fill(0, 0, 0, 60);
    fastRect(75, 0, width - 75 * 2, height);
    fill(0, 0, 0, 100);
    textSize(12);
    text(game.version, 364, 390);

    buttons.back2.draw();
    buttons.fps.draw();
    buttons.fpsType.draw();

    buttons.fps.message = "Fps " + game.fps;
    buttons.fpsType.message = ("Fps Type " + game.fpsType);
};
game.other.mousePressed = function()
{
    if(buttons.fps.clicked())
    { 
        game.fps = {"60": 30, "30": 60}[game.fps.toString()];

        if(game.fps === undefined)
        {
            game.fps = 60;
        }

        buttons.fps.message = "Fps " + game.fps;
    }
    else if(buttons.fpsType.clicked())
    { 
        game.fpsType = (game.fpsType === "auto") ? "manual" : "auto";

        buttons.fpsType.message = ("Fps Type " + game.fpsType);
    }

    game.applyFps();

    game.switchGameState(buttons.back2.clicked(), "extras");
};
game.sound = function()
{
    textFont(fonts.menu);

    textSize(40);
    fill(31, 173, 88);
    textAlign(CENTER, CENTER);
    text("Sound", 200, 110);
    fill(0, 0, 0, 60);
    fastRect(75, 0, width - 75 * 2, height);
    fill(0, 0, 0, 100);
    textSize(12);
    text(game.version, 364, 390); 
    buttons.back2.draw();
    this.switchGameState(buttons.back2.clicked(), "extras");
    buttons.volumeOn.draw();
    buttons.volumeOn.message = "Volume " + (sounds.settings.off ? "off" : "on");

    buttons.music.draw();
    buttons.music.message = "Music " + (sounds.settings.song ? "on" : "off");

    sliders.volume.draw();

    this.percent = sliders.volume.getPercent();
    sliders.volume.message = Math.floor(this.percent) + "%";

    var mouse = {
        xPos : mouseX,
        yPos : mouseY,
    };

    if(mouseIsPressed && sliders.volume.isInside(mouse))
    {
        game.wasInSound = true;
        sliders.volume.onClick(mouse);
    }

    for(var i in sounds.sounds)
    {
        sounds.sounds[i].muted = (sounds.settings.off);
    }

    sounds.setMainVolume(this.percent / 100);
};
game.sound.onEnter = function()
{
    sliders.volume.set(sounds.getMainVolume() * 100);
};
game.sound.applySongs = function()
{
    if(!sounds.settings.song)
    {
        for(var i in sounds.sounds)
        {
            if(sounds.sounds[i].type === "song")
            {
                sounds.stopSound(i, true);
            }
        }
    }
    else if(levelInfo.currentSong)
    {
        sounds.playSound(levelInfo.currentSong, true);
    }
};
game.sound.mousePressed = function()
{
    if(buttons.volumeOn.clicked())
    {
        sounds.settings.off = !sounds.settings.off;
    }
    else if(buttons.music.clicked())
    {
        sounds.settings.song = !sounds.settings.song;
        this.applySongs();
    }
};
game.sound.mouseReleased = function()
{
    if(game.wasInSound)
    {
        sounds.playSound("coinSound.mp3");
        this.wasInSound = false;
    }
};

if(game.gameState === "start")
{
    sounds.playSound(game.sounds.titleScreen, true);
}

game.start = function()
{
    this.drawTitle();

    textFont(fonts.menu);
    fill(0, 0, 0, 100);
    textAlign(CENTER, CENTER);
    textSize(17);
    text("Press any key to play!", 200, 230);

    //If the set background is not a background 
    //we can see the start screen with, change it
    if(backgrounds.background !== "spaceFromEarth")
    {
        backgrounds.setBackground("spaceFromEarth");
    }

    if(keyIsPressed)
    {
        this.switchGameState(true, "story");
        return;
    }

    textSize(12);
    fill(0, 0, 0, 100);
    text(game.version, 364, 390);

    if((mouseIsPressed || keyIsPressed) && !this.startedPlaying)
    {
        sounds.playSound(game.sounds.titleScreen, true);
        this.startedPlaying = true;
    }

    game.fps = 60;
};
game.selectSaveFile = function()
{
    textFont(fonts.menu);

    fill(0, 0, 0, 60);
    fastRect(0, 80, width, height - 70 * 2);

    if(saveDataHandler.saveFiles.length <= 0 || saveDataHandler.saveFiles.length >= saverInfo.maxSaves)
    {
        $pjs.rect(110, 115, 180, 30, 5);
    }else{
        $pjs.rect(80, 115, 240, 30, 5);
    }

    fill(31, 173, 88);
    textSize(17);
    textAlign(CENTER, NORMAL);

    if(saveDataHandler.saveFiles.length >= saver.maxSaves)
    {
        game.selectSaveFile.newSave = false;
    }

    if(game.selectSaveFile.rename)
    {
        fill(0, 0, 0, 100);
        $pjs.rect(110, 200, 180, 100, 7);
        fill(31, 173, 88);
        text("Renaming Save", 200, 135);  
        textBoxes.naming.draw();
        buttons.back4.draw();
        buttons.rename.draw();
        textSize(13);
        fill(31, 173, 88);
        text("Change your name", 200, 215);

        buttons.rename.color = ((textBoxes.naming.message !== "") ? BTN_COLOR : color(153, 55, 11, 200));
    }
    else if(game.selectSaveFile.newSave)
    {
        fill(0, 0, 0, 100);
        $pjs.rect(110, 200, 180, 100, 7);
        fill(31, 173, 88);
        text("New Save", 200, 135);  
        textBoxes.naming.draw();
        buttons.back4.draw();
        buttons.create.draw();
        textSize(13);
        fill(31, 173, 88);
        text("Type your name!", 200, 215);
    }
    else if(!saveDataHandler.erasePrompt)
    {
        if(saveDataHandler.saveFiles.length <= 0)
        {
            text("Create a save file", 200, 135);
        }
        else if(saveDataHandler.saveFiles.length >= saverInfo.maxSaves)
        {
            text("Select a save file", 200, 135);
        }else{
            text("Select or create a save file", 200, 135);
        }

        saveDataHandler.draw();
        saveDataHandler.update();

        buttons.back5.draw();
    }else{
        this.seSaveFile = saveDataHandler.getSelectedSaveFile();
        fill(0, 0, 0, 100);
        $pjs.rect(110, 200, 180, 70, 7);
        fill(31, 173, 88);
        text("Erase", 200, 135);
        textSize(13);
        text("Erase save file " + this.seSaveFile.name + "?", 200, 220);
        buttons.erase.draw();
        buttons.back3.draw();
    }

    fill(0, 0, 0, 140);
    textSize(14);
    textAlign(NORMAL, NORMAL);
    text("Saves " + saveDataHandler.saveFiles.length + "/" + saver.maxSaves, 13, 115);

    textAlign(CENTER, CENTER);
    textSize(12);
    fill(0, 0, 0, 100);
    text(game.version, 364, 390);

    if(game.selectSaveFile.stopErase === undefined)
    {
        game.selectSaveFile.stopErase = 0;
    }

    game.selectSaveFile.stopErase--;

    this.exited = false;

    game.fps = 60;
};
game.selectSaveFile.keyPressed = function()
{
    if(screenUtils.fade.fading)
    {
        return;
    }

    if(this.rename)
    {
        if(ENTER_KEY)
        {
            this.renameSaveFile();
            textBoxes.naming.input = [];
        }else{
            textBoxes.naming.selected = true; //Make sure we can type!
            textBoxes.naming.edit();
            keys = [];
        }

        ENTER_KEY = false;
    }
    else if(game.selectSaveFile.newSave)
    {
        if(ENTER_KEY)
        {
            this.createSaveFile();
        }else{
            textBoxes.naming.selected = true; //Make sure we can type!
            textBoxes.naming.edit();
            keys = [];
        }
    }
    else if(ENTER_KEY || keys[32])
    {
        this.activateSaveFile();
        keys[keyCode] = false;
        keys[key.toString() || ""] = false;

        sounds.stopSound(game.sounds.titleScreen);
    }
};
game.selectSaveFile.renameSaveFile = function()
{
    if(textBoxes.naming.message === "")
    {
        return;
    }

    saveDataHandler.renameSaveFile(textBoxes.naming.message);
    this.rename = false;
    textBoxes.naming.message = "";
};
game.selectSaveFile.afterNew = function()
{
    saver.setCurrent(game.selectSaveFile.saveName);
    game.gameState = "menu";
    loader.startLoadLevel(levelInfo.level);

    sounds.stopSound(game.sounds.titleScreen);
};
game.selectSaveFile.createSaveFile = function()
{
    var message = (textBoxes.naming.message !== "") ? textBoxes.naming.message : "Helix";
        game.selectSaveFile.saveName = saveDataHandler.addNew(undefined, message);
        game.selectSaveFile.newSave = false;
        game.selectSaveFile.afterNew();
};
game.selectSaveFile.activateSaveFile = function(noSetFile)
{
    if(!noSetFile)
    {
        this.seSaveFile = saveDataHandler.getSelectedSaveFile();
    }
    if(this.seSaveFile)
    {
        saver.setCurrent(this.seSaveFile.saveFileName);
        game.gameState = "menu";
        game.tempState = "menu";
        //Make sure we load the right level!
        levelInfo.level = saver.saveData[this.seSaveFile.saveFileName].level || levelInfo.level;
        loader.startLoadLevel(levelInfo.level);
    }
};
game.selectSaveFile.mousePressed = function()
{
    /*Safety fix -we don't want to mess up the save files until they are loaded*/
    if(screenUtils.fade.fading)
    {
        return;
    }

    if(game.selectSaveFile.rename)
    {
        if(buttons.back4.clicked())
        {
            game.selectSaveFile.rename = false;
            textBoxes.naming.message = "";
        }
        else if(buttons.rename.clicked())
        {
            this.renameSaveFile();
        }
    }
    else if(game.selectSaveFile.newSave)
    {
        if(buttons.back4.clicked())
        {
            game.selectSaveFile.newSave = false;
            textBoxes.naming.message = "";
            textBoxes.naming.input = [];
        }
        else if(buttons.create.clicked())
        {
            this.createSaveFile();
        }
    }
    else if(saveDataHandler.buttons.copy.clicked() && this.stopErase <= 0 && !saveDataHandler.erasePrompt)
    {
        saveDataHandler.copySelectedSaveFile();
    }
    else if(buttons.back5.clicked())
    {
        game.switchGameState(true, "start");
    }
    else if(saveDataHandler.erasePrompt)
    {
        this.stopErase = 60;

        if(buttons.back3.clicked())
        {
            saveDataHandler.erasePrompt = false;
        }
        else if(buttons.erase.clicked())
        {
            if(this.seSaveFile)
            {
                saveDataHandler.erase(this.seSaveFile.saveFileName, this.seSaveFile);
            }
            saveDataHandler.erasePrompt = false;
        }
    }else{
        this.seSaveFile = saveDataHandler.getSelectedSaveFile();
        if(this.seSaveFile)
        {
            if(saveDataHandler.buttons.play.clicked())
            {
                this.activateSaveFile();
                sounds.stopSound(game.sounds.titleScreen);
                return;
            }
            else if(saveDataHandler.buttons.erase.clicked())
            {
                saveDataHandler.erasePrompt = true;
            }
            else if(saveDataHandler.buttons.rename.clicked())
            {
                var self = this;
                // if(textBoxes.naming.message === "")
                // {
                    textBoxes.naming.message = (function() 
                    { 
                        return self.seSaveFile.name;
                    }());
                // }
                textBoxes.naming.selected = false;
                this.rename = true;
            }
        }
        if(saveDataHandler.buttons.new.clicked())
        {
            game.selectSaveFile.newSave = true;
            textBoxes.naming.selected = false;
        }
    }
};
game.story = function()
{
    textFont(fonts.menu);

    fill(0, 0, 0, 150);
    fastRect(50, 0, width - 100, height);

    textAlign(CENTER, CENTER)

    this.story.timer++;
    if(this.story.timer > 20 && this.story.timer < 255)
    {
        fill(30, 170, 100, 255 - this.story.timer);
        text("Press Enter/click for next page.", width * 0.5, 385);
        this.endMillis = millis();
    }
    if(this.endMillis !== undefined && millis() - this.endMillis > 400)
    {
        fill(30, 170, 100, 255 - ((millis() - this.endMillis - 400) * 255 / 2500));
        text("Press any other key to skip.", width * 0.5, 385);
        if(millis() - this.endMillis > 2900)
        {
            this.endMillis = undefined;
        }
    }

    if(this.story.needsInit)
    {
        storyHandler.message = "";
        storyHandler.storyIndex = 0;
        storyHandler.done = false;
        this.story.needsInit = false;
    }

    storyHandler.show();
    textSize(12);
    $pjs.pushMatrix();
    textAlign(CENTER, CENTER);
    translate(0, storyHandler.scroll);
    fill(storyHandler.color || color(31, 173, 88));
    text(storyHandler.message || (screenUtils.fade.fading ? "" : "Press any key to exit"), width * 0.5, HALF_HEIGHT);
    $pjs.popMatrix();

    if(!this.exited)
    {
        sounds.getSound(game.sounds.titleScreen).muted = true;
    }

    if(this.story.timer > 20 && (storyHandler.storyIndex >= storyHandler.story.length || keyIsPressed && !ENTER_KEY))
    {   
        game.story.needsInit = true;
        this.story.timer = 0;
        sounds.getSound(game.sounds.titleScreen).muted = false;
        this.exited = true;

        this.switchGameState(true, "selectSaveFile");
    }

    game.fps = 60;
};
game.story.needsInit = true;
game.story.timer = 0;

game.drawTitle = function()
{
    fill(0, 0, 0, 60);
    fastRect(75, 0, width - 75 * 2, height);
    fill(41, 98, 213, 100);  
    textFont(fonts.title);
    textAlign(CENTER, CENTER);
    // textSize(43);
    // text("Planet\nSearch 2", 200, 83);
    // text("Helixs\nAdventure", 200, 83);
    textSize(34);
    text("Helix's\nAdventure", 200, 83);

    textSize(26);
    fill(0, 0, 0, 30);
    $pjs.rect(150, 146, 100, 30, 5);
    fill(31, 173, 88);
    text("Amber", 200, 160);

    textFont("");
};
game.gameOver = function()
{
    textFont(fonts.menu);

    background(0, 0, 0);
    textAlign(CENTER, CENTER);
    textSize(20);
    text("GameOver!", 200, 200);
    textSize(11);
    text("Press any key to continue...", 200, 300);

    screenUtils.infoBar.draw(true);
};
game.gameOver.keyPressed = function()
{
    game.restart();
};
game.pauseMenu = function()
{
    textFont(fonts.menu);

    image(screenUtils.screenShot, 0, 0, width, height);
    textSize(40);
    fill(31, 173, 88);
    textAlign(CENTER, CENTER);
    text("Paused", 200, 110);
    fill(0, 0, 0, 60);
    fastRect(75, 0, width - 75 * 2, height);
    cursor(ARROW);
    game.cursor = ARROW;
    
    buttons.back.draw();
    this.switchGameState((buttons.back.clicked() || keys[80]) && !ENTER_KEY, "play");
    
    var restartButtonDisabled = (shipGoto.launched && (!shipGoto.inSpace || shipGoto.haveNotSavedSince) || levelInfo.theme === "space" || levelInfo.level === "LightTowerTopFloor");

    buttons.restart.draw();

    if(restartButtonDisabled)
    {
        buttons.restart.highlightColor = color(0, 0, 0, 100);
    }else{
        delete buttons.restart.highlightColor;
    }
    if(!restartButtonDisabled && buttons.restart.clicked())
    {
        this.gameState = "play";
        talkHandler.end(); // Make sure we're not talking to the npc anymore
        player.handleDeath();
        shipGoto.launched = false;
    }
    
    buttons.menu.draw();
    this.switchGameState(buttons.menu.clicked(), "menu");

    buttons.save.draw();
};
game.pauseMenu.mousePressed = function()
{
    if(buttons.save.clicked())
    {
        //game.save();
        //game.switchGameState(true, "start");

        //Restart the program, a quick fix to make sure 
        //we don't accidently unproperly load the same
        //save file as the currently opened one, if the same one was opened.
        if(MODE === "pjs")
        {
            game.restart();
        }
    }
};
game.menu = function()
{
    this.drawTitle();

    textFont(fonts.menu);

    textSize(12);
    fill(0, 0, 0, 100);
    text(game.version, 364, 390); 
    
    buttons.play.draw();
    buttons.how.draw();
    buttons.extras.draw();
};
game.menu.mousePressed = function()
{
    game.switchGameState(buttons.play.clicked(), "play");
    game.switchGameState(buttons.how.clicked(), "how");
    game.switchGameState(buttons.extras.clicked(), "extras");
},
game.menu.keyPressed = function()
{
    if(!keys[32] && ENTER_KEY)
    {
        game.switchGameState(true, "play");
    }
};

game.inventoryMenu = function()
{
    textFont(fonts.menu);

    image(screenUtils.screenShot, 0, 0, width, height);

    keys[27] = false;
    ESC_KEY = false;

    inventoryMenu.update();
    inventoryMenu.draw();

    game.switchGameState(inventoryMenu.state === "closed", "play"); 
};
game.inventoryMenu.mousePressed = function()
{
    if(mouseY < 60 || mouseY > 340)
    {
        inventoryMenu.tryToClose(function() 
        {
            return mouseButton === LEFT;
        });
    }
};
game.inventoryMenu.keyPressed = function()
{
    keys[27] = false;
    ESC_KEY = false;

    if(!inventoryMenu.oFuncs || !inventoryMenu.oFuncs.close)
    {
        inventoryMenu.tryToClose();
    }
};

game.controlPanel = function()
{
    textFont(fonts.menu);

    image(screenUtils.screenShot, 0, 0, width, height);

    keys[27] = false;
    ESC_KEY = false;

    controlPanel.update();
    controlPanel.draw();

    game.switchGameState(controlPanel.state === "closed", "play"); 
};
game.controlPanel.mousePressed = function()
{    
    controlPanel.mousePressed();
    
    if(controlPanel.state === "closed" || mouseButton === RIGHT)
    {
        return;
    }

    if(mouseY < 60 || mouseY > 340)
    {
        controlPanel.close();
    }
};
game.controlPanel.keyPressed = function()
{
    if(controlPanel.state === "closed")
    {
        return;
    }

    if(keys.e || keys.s || keys[DOWN])
    {
        controlPanel.close();
    }
};

game.applyFps = function()
{   
    if(Number(this.fps) === 30)
    {
        loader.levelStepRows = loader.lastLevelStepRows * 2;
        cam.speed = cam.lastSpeed * 2; 
        processing.doSt();
    }else{
        loader.levelStepRows = loader.lastLevelStepRows;
        cam.speed = cam.lastSpeed;
    }

    frameRate(game.fps);

    if(Number(this.fps) === 60)
    {
        processing.doRaf();
    }
};
window.game = game;

game.finish = function()
{
    var siId = setInterval(() => 
    {
        if(messageHandler.active)
        {
            return;
        }

        backgrounds.backgrounds.space2.load();

        game.switchGameState(true, "credits");

        clearInterval(siId);
    }, 1000);
};

var CreditsHandler = function(credits)
{
    var cursive = createFont("cursive");

    this.scroll = -400;

    /*
        Bosses:
            ninjaBoss
            iceDragon
            captainFleep
            talonShip

        Enemies:
            waterBeaker
            fireBeaker
            skyViper
            
            ninja
            spaceBreaker
            ninjaBeaker

            iceBeaker
            wisp
            dirtyCat
            catDogStatue
            voxelizer

            bat
            slimeBeaker
            poisonousSlimeBeaker
            slasher
            stomper
    */

    this.enemies = [
        {   
            message : "waterBeaker",
        }, {
            message : "fireBeaker",
        }, {
            message : "skyViper"
        }, {////////////////////////
            message : "ninja"
        }, {
            message : "spaceBreaker"
        }, {
            message : "ninjaBeaker"
        }, {///////////////////////
            message : "iceBeaker"
        }, {
            message : "wisp"
        }, {
            message : "dirtyCat"
        }, {
            message : "catDogStatue"
        }, {
            message : "voxelizer"
        }, {///////////////////////
            message : "bat"
        }, {
            message : "slimeBeaker"
        }, {
            message : "poisonousSlimeBeaker"
        }, {
            message : "slasher"
        }, {
            message : "stomper"
        }, {
            message : "lavaBeaker"
        }
    ];

    this.bosses = [
        {
            message : "ninjaBoss"
        }, {
            message : "iceDragon"
        }, {
            message : "captainFleep"
        }, {
            message : "talonShip"
        }
    ];

    this.draw = function()
    {
        textAlign(CENTER, CENTER);

        pushMatrix();
            translate(0, -this.scroll);

            fill(32, 200, 67, 210);
            textFont(cursive, 16);

            if(this.scroll < 2200)
            {   
                text("# Credits #", 200, 100);

                fill(12, 123, 145);
                text("Enemies", 200, 200);            

                fill(255, 255, 255, 210);
                textFont(cursive, 12);

                var obj;
                for(var i = 0; i < this.enemies.length; i++)
                {
                    fill(255, 255, 255, 210);

                    text(this.enemies[i].message.upper().match(/[A-Z][a-z]+/g).toString().replace(",", " ").replace(",", " "), 200, 250 + i * 120);

                    try{
                        if(this.enemies[i].message === "ninjaBeaker")
                        {
                            obj = (gameObjects[gameObjects.references["fireBeaker"]] || [])[1];

                        }else{
                            obj = (gameObjects[gameObjects.references[this.enemies[i].message]] || [])[0];
                        }

                        if(obj)
                        {
                            obj.xPos = 200 - (obj.halfWidth || obj.width / 2 || 0);
                            obj.yPos = 250 + (i) * 120 + 60 - (obj.halfHeight || obj.height / 2 || obj.radius);

                            if(obj.arrayName === "wisp" || obj.arrayName === "spaceBreaker")
                            {
                                obj.yPos += 14;

                                obj.update();
                            }

                            obj.draw();
                        }
                    }
                    catch(e)
                    {
                        console.log("ERROR: " + e.toString());
                    }
                }
            }
            if(this.scroll > 1800 && this.scroll < 3000)
            {
                translate(0, 400);
                fill(32, 200, 67, 210);
                textFont(cursive, 16);

                fill(12, 123, 145);
                text("--Bosses--\n\n", 200, 2000);

                fill(255, 255, 255, 210);
                textFont(cursive, 12);

                var obj;

                for(var i = 0; i < this.bosses.length; i++)
                {
                    fill(255, 255, 255, 210);

                    text(this.bosses[i].message.upper().match(/[A-Z][a-z]+/g).toString().replace(",", " ").replace(",", " ") + (this.bosses[i].message === "talonShip" ? " (X-Falcon-Lite)" : ""), 200, 2020 + i * 120);

                    try{
                        if(obj = (gameObjects[gameObjects.references[this.bosses[i].message]] || [])[0])
                        {
                            obj.xPos = 200 - (obj.halfWidth || obj.width / 2 || 0);
                            obj.yPos = 2030 + i * 120 + 50 - (obj.halfHeight || obj.height / 2 || obj.radius);

                            obj.updateBoundingBox();
                            physics.getMiddleXPos(obj);
                            physics.getMiddleYPos(obj);

                            obj.draw(true);
                        }
                    }
                    catch(e)
                    {
                        console.log("ERROR: " + e.toString());
                    }
                }
            }

        popMatrix();

        pushMatrix();
            translate(0, -this.scroll);

            translate(0, -400);
            fill(32, 200, 67, 210);
                textFont(cursive, 16);

                fill(12, 123, 145);
                text("Other(s)", 200, 3330);

                fill(255, 255, 255, 210);
                textFont(cursive, 12);
                text("Helix", 200, 3360);

                player.xPos = 185;
                player.yPos = 3380;
                player.draw();

                text("Helix's Ship (tri-Nexus)", 200, 3470);

                pushMatrix();
                    translate(200, 3530);
                    rotate(270);
                    fastImage(loadedImages["helixShip"], -100 * 0.4, -216 * 0.4, 200 * 0.4, 432 * 0.4);
                popMatrix();
            translate(0, 400);

            translate(0, -600);

            if(this.scroll > 2200 && this.scroll < 4000)
            {
                fill(32, 200, 67, 210);
                textFont(cursive, 16);

                fill(12, 123, 145);
                text("Sound effects", 200, 3820);

                fill(133, 192, 217, 200);
                textFont(cursive, 12);

                text("Some sounds effects are by Khan Academy\n(they have their license for them)", 200, 3860);
                text("All others were made using\nBfxr and Chiptone (under cc0 license)", 200, 3920);

                fill(32, 200, 67, 210);
                textFont(cursive, 16);

                fill(12, 123, 145);
                text("Libraries", 200, 4000);

                fill(133, 192, 217, 200);
                textFont(cursive, 12);

                text("Modified processing js", 200, 4030);

                fill(32, 200, 67, 210);
                textFont(cursive, 16);

                fill(12, 123, 145);
                text("Websites", 200, 4090);

                fill(133, 192, 217, 200);
                textFont(cursive, 12);

                text("stackoverflow, (helped a lot when I got stuck)\n  www.piskelapp.com (for making 2d sprites) \n " + 
                     "paletton.com (for making color palettes)\n sfbgames.com/chiptone (for making sounds fx)", 200, 4140);

            }

            if(this.scroll > 3000)
            {
                fill(32, 200, 67, 210);
                textFont(cursive, 16);

                fill(12, 123, 145);
                text("Creators", 200, 4600);

                fill(133, 192, 217, 200);
                textFont(cursive, 12);

                text("Einkurogane\n (made most the music for this game)", 200, 4640);

                text("silvanus1\n (A friend of mine, he made Talon's spaceship sprite)", 200, 4700);

                text("(shotty) My brother\n (sprite artist)", 200, 4760);

                text("ProlightHub\n (Game coder, Artist, playtester, sound fx maker etc etc.)", 200, 4820);

                text("And you!\n\nBecause of " + player.name + ", they get their\nname in the credits.\n\nAnd you, " + player.name + "! ", 200, 4960);
            }
        popMatrix();

        if(this.scroll > 4700)
        {
            this.done = true;
        }

        if(!this.addedObjects)
        {
            gameObjects.removeObjects();

            var array;
            for(var i = 0; i < this.enemies.length; i++)
            {
                try{
                    array = gameObjects.getObject(this.enemies[i].message);

                    switch(this.enemies[i].message)
                    {
                        case "ninja" :
                            array.add(0, i * 40, 30, 60).update();
                            break;

                        case "ninjaBeaker" :
                            var ninjaBeaker = gameObjects.getObject("fireBeaker").add(0, i * 40, 30, 30);

                            ninjaBeaker.color = color(70, 10, 200, 120);
                            ninjaBeaker.particleColor = color(30, 30, 200, 130);
                            ninjaBeaker.update();
                            break;

                        case "spaceBreaker" :
                            var obj = array.add(0, i * 40, 27);
                            obj.maxXVel = 0;
                            obj.maxYVel = 0;
                            break;

                        case "dirtyCat" :
                            array.add(0, i * 40, 30 * 2.0, 30 * 1.28);
                            break;

                        case "wisp" :
                            array.add(0, i * 40, 30 * 0.7);
                            break;

                        case "fireBeaker" : case "lavaBeaker" : 
                            var obj = array.add(0, i * 40, 30, 30);
                            obj.drawParticles = function() {};
                            obj.draw = obj.lastDrawB;
                            break;

                        default :
                            array.add(0, i * 40, 30, 30).update();
                            break;
                    }
                }
                catch(e)
                {
                    console.log("ERROR: " + e.toString());
                    console.log(this.enemies[i].message);
                }
            }

            gameObjects.getObject("ninjaBoss").add(0, 1 * 40, 30, 60);
            gameObjects.getObject("iceDragon").add(0, 2 * 40, 140 * 0.6, 74 * 0.6);
            gameObjects.getObject("captainFleep").add(0, 3 * 40, 30, 30);
            gameObjects.getObject("talonShip").add(0, 3 * 40, 100, 150).update();

            this.addedObjects = true;
        }
    };

    this.move = function()
    {
        this.scroll += 0.9;
    };
};
var creditHandler = new CreditsHandler();

game.credits = function()
{
    backgrounds.backgrounds.space2.drawBackground();

    if(backgrounds.backgrounds.space2.stars.length <= 3)
    {
        backgrounds.backgrounds.space2.load();
    }

    if(!this.shownAfterBattle)
    {
        var hasAcquiredAllGems = (gameObjects.getObject("player")[0].gems >= controlPanel.gems.max);

        if(hasAcquiredAllGems)
        {
            talkHandler.start({
                up : true,
                "start" : {
                    message : "And so...\nwith Talon defeated, locked away in\nDimension X...",
                    choices : {
                        "next" : "..."
                    }
                },
                "next" : {
                    message : "/username had acquired all 4 crystals...\nand can now properly wield these\ncrystals.",
                    choices : {
                        "next2" : "..."
                    }
                },
                "next2" : {
                    message : "/username has once again restored his\nstatus as a hero... (meaning you've restored\nbalance to the universe)",
                    choices : {
                        "inter" : "..."
                    }
                },
                "inter" : {
                    message : "A true hero...\n\nbut Titan has yet to be found...",
                    choices : {
                        "next3" : "..."
                    }
                },
                "next3" : {
                    message : "But what about Talon? Will he ever show\nin person? Will he ever find a way out of\nDimension X?",
                    choices : {
                        "next4" : "..."
                    }
                },
                "next4" : {
                    message : "We may never know...",
                    choices : {
                        "next5" : "..."
                    }
                },
                "next5" : {
                    message : "And thus your journey finally\ncomes to an end...",
                    choices : {
                        "next6" : "..."
                    }
                },
                "next6" : {
                    message : "May we meet in another time and space",
                    choices : {
                        "exit" : "..."
                    }
                }
            },
            "start", "");
        }else{
            talkHandler.start({
                up : true,
                "start" : {
                    message : "And so...\nwith Talon defeated, locked away in\nDimension X...",
                    choices : {
                        "next" : "..."
                    }
                },
                "next" : {
                    message : "/username had acquired all 4 crystals...\nbut was not powerful enough to\ncontain them.",
                    choices : {
                        "next2" : "..."
                    }
                },
                "next2" : {
                    message : "And as a result...\nthe universe became unstable,\nthus they need to be returned.",
                    choices : {
                        "inter0" : "..."
                    }
                },
                "inter0" : {
                    message : "Your search began...\nyou searched...\nand searched...",
                    choices : {
                        "inter" : "..."
                    }
                },
                "inter" : {
                    message : "Until...",
                    choices : {
                        "inter2" : "..."
                    }
                },
                "inter2" : {
                    message : "Titan was found! The planet we have\nbeen looking for all this time!",
                    choices : {
                        "inter4" : "..."
                    }
                },
                "inter4" : {
                    message : "You traveled there and returned the\ncrystals, and restored stability to\nthe universe.",
                    choices : {
                        "inter5" : "..."
                    }
                },
                "inter5" : {
                    message : "If you only had the power to wield\nthese crystals then you would become\na true hero!",
                    choices : {
                        "next3" : "..."
                    }
                },
                "next3" : {
                    message : "But what about Talon? Will he ever show\nin person? Will he ever find a way out of\nDimension X?",
                    choices : {
                        "next4" : "..."
                    }
                },
                "next4" : {
                    message : "We may never know...",
                    choices : {
                        "next5" : "..."
                    }
                },
                "next5" : {
                    message : "And thus your journey finally\ncomes to an end...",
                    choices : {
                        "next6" : "..."
                    }
                },
                "next6" : {
                    message : "May we meet in another time and space",
                    choices : {
                        "exit" : "..."
                    }
                }
            },
            "start", "");
        }

        this.shownAfterBattle = true;
    }

    if(messageHandler.active)
    {
        return;
    }

    game.switchGameState(creditHandler.done, "theEnd", true);

    // If draw returns a truthy value move won't update.
    // This is smart for short circuiting techniques.
    creditHandler.draw() || creditHandler.move(); 
};
game.credits.mouseReleased = function()
{
    talkHandler.mouseReleased();
};
game.credits.keyPressed = function()
{
    talkHandler.keyPressed();
};
game.credits.keyReleased = function()
{
    talkHandler.keyReleased();
};

game.theEnd = function()
{
    if(gameObjects.getObject("player")[0].gems >= controlPanel.gems.max)
    {
        fastImage(loadedImages["space"], 0, 0, width, height);

        textAlign(CENTER, CENTER);
        textFont(fonts.title, 16);
        fill(255, 133, 61);

        text("The End", 42, 385);

        return;
    }

    fastImage(loadedImages["theEnd"], 0, 0, width, height);

    textAlign(CENTER, CENTER);
    textFont(fonts.title, 16);
    fill(255, 133, 61);

    text("The End", 42, 385);
};

////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
/**************************************************************Final-loop******************************************************************/
////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

game.play = function(noDraw, remote)
{
    $pjs.pushMatrix();
        cam.view();
        screenUtils.manageShake();
        backgrounds.drawForeground();
        gameObjects.update(remote);
        gameObjects.draw(noDraw);
        gameObjects.drawBoundingBoxes();
        // cameraGrid.draw();
        // cam.draw();
        screenUtils.withCamera();
        
        levelScripts.draw();
    $pjs.popMatrix();

    daylightCycle.update();
    levelScripts.apply();
    // cam.drawOutline();

    if(shipGoto.launched && levelInfo.level === "desert oasis")
    {
        var helixShip = gameObjects.getObject("helixShip")[0];

        if(helixShip && helixShip.yPos + helixShip.height < -1000)
        {
            var shipWidth = helixShip.width * 0.6;
                shipHeight = helixShip.height * 0.6;

            if(helixShip.hp > 0)
            {
                pushMatrix();
                    scale(0.6, 0.6);
                    translate(200 * (1 / 0.6), 310);

                    helixShip.flames.draw();
                    helixShip.flames.update();

                popMatrix();
            }

            image(loadedImages["helixShip"], width / 2 - shipWidth / 2, height / 2 - shipHeight / 2, shipWidth, shipHeight);
        }
    }

    $pjs.pushMatrix();
        cam.scaleZoom();
        lighting.draw();
    $pjs.popMatrix();

    debugTool.apply();

    if(!messageHandler.active && !debugTool.active && !game.disablePause)
    {
        // Menu
        this.switchGameState(keys[77], "menu"); // On key 'm' switch to menu
        this.switchGameState(keys[80] || ESC_KEY, "pauseMenu", true); // On key 'p' switch to pause menu
    }
};
game.play.keyPressed = function()
{
    if(keys[F12] && (!game.cutScening || debugTool.active) && game.debugMode)
    {
        debugTool.active = !debugTool.active;
        game.cutScening = debugTool.active;

        if(debugTool.active)
        {
            screenUtils.infoBar.sBH = screenUtils.infoBar.showBottomHud;
            screenUtils.infoBar.showBottomHud = false;
        }else{
            screenUtils.infoBar.showBottomHud = screenUtils.infoBar.sBH;
        }
    }

    debugTool.keyPressed();

    if(debugTool.active)
    {
        return;
    }

    player.keyPressed();

    talkHandler.keyPressed();

    if(messageHandler.active)
    {
        return;
    }

    if(keys[F11] && game.debugMode)
    {
        game.fpsType = (game.fpsType === "auto") ? "manual" : "auto";
    }
    else if(keys[F10] && game.debugMode)
    {
        game.fps = {"60": 30, "30": 60}[game.fps.toString()];

        if(game.fps === undefined)
        {
            game.fps = 60;
        }

        game.applyFps();
    }
    else if(keys[F9] && game.debugMode)
    {
        gameObjects.delag(false, true);      
    }
    else if(keys[F6])
    {
        screenUtils.infoBar.showBottomHud = !screenUtils.infoBar.showBottomHud;
    }

    if(keys[F7])
    {
        game.hideKeys = !game.hideKeys;
    }

    game.switchGameState(inventoryMenu.tryToOpen() && !(shipGoto.launched && !shipGoto.inSpace && levelInfo.level === "desert oasis"), "inventoryMenu", true); 
};
game.play.keyReleased = function()
{
    talkHandler.keyReleased();
    player.discoveredPowersHandler.keyReleased();
};
game.play.mousePressed = function()
{
    try{
        player.discoveredPowersHandler.mousePressed();
    }
    catch(e)
    {
        console.log(e);
    }
};

game.doCursor = function()
{
    game.cursor = false;
    game.noCursor = false;

    // Set player if he/she doesn't exist.
    if(!player || !player.draw)
    {
        player = gameObjects.getObject("player")[0];

        if(player && player.draw)
        {
            // Make sure we're done checking if the player exists or not!
            game.doCursor = function()
            {
                game.cursor = false;
                game.noCursor = false;
            };
        }
    }
};

var draw = function()
{
    game.doCursor();
    backgrounds.drawBackground();
    game[game.gameState]();
    screenUtils.update();
};

var lastMouseReleased = mouseReleased;
mouseReleased = function()
{
    lastMouseReleased();
    screenUtils.mouseReleased();
};

/* Inputs */ //Binding the inputs with game scenes/states
var inputs = {"mousePressed" : mousePressed,
              "keyPressed" : keyPressed,
              "mouseReleased" : mouseReleased,
              "keyReleased" : keyReleased};
inputs.set = function(name, input)
{
    processing[name] = function() 
    {
        input();
        if(game[game.gameState][name] !== undefined)
        {
            game[game.gameState][name]();
        }
    };
};
inputs.load = function()
{
    for(var i in this)
    {
        inputs.set(i, this[i]);
    }
};

//Load the inputs
inputs.load();

/*function showError(e, fatal)
{
    processing.width = 600;
    processing.height = 600;

    background(0, 60, 200);

    resetMatrix();

    if(this.sec)
    {
        scale(6 / 4, 6 / 4);
    }

    this.sec = true;

    processing.width = 400;
    processing.height = 400;

    fill(255, 255, 255, 100);
    textSize(width * 0.037);
    textAlign(CENTER, CENTER)
    text("Oops! An " + ((!fatal) ? "" : "fatal") + " error occurred!", width / 2, height * 0.35);

    textSize(width * 0.026);
    text(((!fatal) ? "Press any key to continue." : "Failure to continue,\n restarting ..."), width / 2, height * 0.55);

    var crashText = e.toString();
    var crashStack = e.stack;
    var crashLineNumber = e.stack.toString().split("\n")[4];

    console.log(crashText);
    console.log(crashStack);

    if(crashText.toString() === "TypeError: Cannot read property 'xPos' of undefined")
    {
        console.warn("(Player is missing!)");
    }

    console.log("Line:" + crashLineNumber);

    textSize(width * 0.02);

    textAlign(LEFT, CENTER);
    text(crashText + "\n" + "Line:\n" + crashLineNumber, 1, height * 0.8);
}

function initErrorHandler()
{
    processing.lastDraw = draw;
    draw = function()
    {
        try{
            processing.lastDraw();
        }
        catch(e)
        {
            resetMatrix();
            showError(e);
            noLoop();

            var time = millis();

            processing["_lastKeyReleased" + time] = keyReleased;
            keyReleased = function()
            {
                if(key.toString() === '-')
                {
                    return;
                }

                try{
                    processing["_lastKeyReleased" + time]();
                    processing.lastDraw();
                    loop();
                }
                catch(e)
                {
                    showError(e, true);

                    keyReleased = function() {};

                    if(game.reload)
                    {
                        window.setInterval(function()
                        {
                            window.location.reload();
                        }, 3000);
                    }
                }
            };
        }
    };
};

// Try out the error handler
initErrorHandler();*/

processing.scaledCondition = function()
{
    return (game.gameState !== "load");
};

// Other browsers have slowdowns
if(browserDetection.isFireFox)
{
    game.fpsType = "auto";
}

/* Globalize things for debugging */
if(game.globalize)
{
    window.gameObjects = gameObjects;
    window.cam = cam;
    window.storedImages = storedImages;
    window.cameraGrid = cameraGrid;
    window.levelInfo = levelInfo;
    window.lighting = lighting;
    window.backgrounds = backgrounds;
    window.screenUtils = screenUtils;
    window.f_getArrayNamesToSave = f_getArrayNamesToSave;
    window.talkHandler = talkHandler;
}

// Done!

// Close the wrapper
    }
    if(typeof draw !== 'undefined') processing.draw = draw;
};

// Apply to the sketch to the canvas
window.canvas = document.getElementById("canvas");
window.processing = new Processing(canvas, sketch);
window.processing.chrome = browserDetection.isChrome; 

function updateSize(pjs, w, h, w2, h2)
{
    var screen = {
        width : w2,
        height : h2,
        normalWidth : w,
        normalHeight : h,
    };

    pjs.size(screen.width, screen.height);

    processing.screen = screen;

    var ratios = {};
    function setRatios()
    {
        ratios = {
            smallWidth : screen.normalWidth / screen.width,
            smallHeight : screen.normalHeight / screen.height,
            bigWidth : screen.width / screen.normalWidth,
            bigHeight :  screen.height / screen.normalHeight,
        };
    }

    setRatios();

    var tempCanvas = document.createElement("canvas");
    var tctx = tempCanvas.getContext("2d");

    var ctx = canvas.getContext("2d");

    function resizeTo(canvas, pctW, pctH, noLarge)
    {
        var cw = canvas.width;
        var ch = canvas.height;
        tempCanvas.width = cw;
        tempCanvas.height = ch;

        tctx.drawImage(canvas, 0, 0);

        if(!noLarge)
        {
            canvas.width *= pctW;
            canvas.height *= pctH;
        }

        ctx.drawImage(tempCanvas, 0, 0, cw, ch, 0, 0, cw * pctW, ch * pctH);
    }
        
    function begin()
    {
        pjs.lastMouseX = pjs.mouseX;
        pjs.lastMouseY = pjs.mouseY;
        pjs.mouseX = pjs.lastMouseX * (ratios.smallWidth);
        pjs.mouseY = pjs.lastMouseY * (ratios.smallHeight);

        pjs.width = screen.normalWidth;
        pjs.height = screen.normalHeight;
    }

    function end()
    {
        if(pjs.scaled)
        {
            pjs.width = screen.width;
            pjs.height = screen.height;
        }
        pjs.mouseX = pjs.lastMouseX;
        pjs.mouseY = pjs.lastMouseY;
    }

    pjs. _lastMouseReleased = pjs.mouseReleased;
    pjs.mouseReleased = function()
    {
        begin();
        pjs._lastMouseReleased();
        end();
    };

    pjs. _lastMousePressed = pjs.mousePressed;
    pjs.mousePressed = function()
    {
        begin();
        pjs._lastMousePressed();
        end();
    };

    pjs.scaledCondition = pjs.scaledCondition || function() {};

    var ctx = pjs.externals.context;

    ctx.imageSmoothingEnabled = false;

    pjs.lastLoop = pjs.draw;
    pjs.draw = function()
    {
        pjs.pushMatrix();

        // canvas.width = 400;
        // canvas.height = 400;
        if(ctx.imageSmoothingEnabled)
        {
            ctx.imageSmoothingEnabled = false;
        }

        if(pjs.scaledCondition() && pjs.scaled !== undefined)
        {
            pjs.scale(ratios.bigWidth, ratios.bigHeight);

            pjs.scaled = true;
        }else{
            pjs.scaled = false;
        }

        begin();

        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 1;

        pjs.lastLoop();
 
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 1;

        if(!pjs.scaled)
        {
            resizeTo(canvas, ratios.bigWidth, ratios.bigHeight, true);
        }

        end();
        
        pjs.popMatrix();

        ctx.restore();
    };

    pjs.doAuto();
};

updateSize(processing, 400, 400, 600, 600);

var oEvents = ["Backspace"];

document.addEventListener('keydown', function()
{
    if(oEvents.indexOf(event.key.toString()) !== -1) 
    {
        event.preventDefault();
    }
});
document.addEventListener('keyup', function()
{
    if(oEvents.indexOf(event.key.toString()) !== -1) 
    {
        event.preventDefault();
    }
});

try{
    window.bombEmoji = '💣';
}
catch(e) 
{
    console.log(e);
}